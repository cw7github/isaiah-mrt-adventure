<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <title>Isaiah's MRT Food Adventure</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link
    href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;600;700;800&family=Fredoka:wght@400;500;600;700&family=Outfit:wght@400;500;600;700;800&display=swap"
    rel="stylesheet">

  <!-- Preload critical images for instant station loading -->
  <link rel="preload" href="assets/mascot.png" as="image">
  <link rel="preload" href="assets/train.png" as="image">
  <link rel="preload" href="assets/food_fruit.jpeg" as="image">
  <link rel="preload" href="assets/food_drink.jpeg" as="image">
  <link rel="preload" href="assets/food_bakery.png" as="image">
  <link rel="preload" href="assets/food_pizza.jpeg" as="image">
  <link rel="preload" href="assets/food_icecream.png" as="image">
  <link rel="preload" href="assets/food_fishshop.png" as="image">
  <link rel="preload" href="assets/food_cheese.png" as="image">
  <link rel="preload" href="assets/food_noodle.png" as="image">
  <link rel="preload" href="assets/icon_fruit.svg" as="image">
  <link rel="preload" href="assets/icon_drink.svg" as="image">
  <link rel="preload" href="assets/icon_bakery.svg" as="image">
  <link rel="preload" href="assets/icon_pizza.svg" as="image">
  <link rel="preload" href="assets/icon_icecream.svg" as="image">
  <link rel="preload" href="assets/icon_fish.svg" as="image">
  <link rel="preload" href="assets/icon_cheese.svg" as="image">
  <link rel="preload" href="assets/icon_noodle.svg" as="image">

  <!-- UI Improvements (Autism-Friendly Design System) -->
  <link rel="stylesheet" href="ui_improvements.css">

  <style>
    /* ===== CSS RESET & BASE ===== */
    *,
    *::before,
    *::after {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    /* ===== DESIGN PHILOSOPHY =====
     * "Soft Storybook" - A warm, hand-crafted aesthetic that feels like
     * flipping through a beloved children's picture book. Every element
     * has gentle edges, subtle texture, and comforting depth.
     *
     * Signature Elements:
     * 1. Paper-like texture overlay for warmth
     * 2. Soft, pillowy shadows that feel tactile
     * 3. Warm color palette inspired by watercolors
     * 4. Gentle floating animations like turning pages
     * 5. Hand-drawn inspired borders and decorations
     */

    /* ===== CSS VARIABLES ===== */
    :root {
      /* === PRIMARY PALETTE: Warm Cream & Sky === */
      /* Base backgrounds with warmth and depth */
      --bg-cream: #FDF9F3;
      --bg-cream-warm: #FBF6EE;
      --bg-cream-cool: #F8F5F0;
      --bg-soft-blue: #EEF6FA;
      --bg-soft-blue-deep: #E3F0F7;
      --bg-elevator: #EAE6E0;

      /* Paper texture overlay color */
      --paper-texture: rgba(255, 250, 240, 0.4);

      /* === MRT JOURNEY COLORS === */
      /* Primary blue - softer, more approachable */
      --mrt-blue: #4A90C2;
      --mrt-blue-deep: #3A7DB0;
      --mrt-blue-soft: #6AADDA;
      --mrt-blue-pale: #C5E1F2;
      --mrt-blue-whisper: #E8F3FA;

      /* === TAIPEI MRT LINE COLORS === */
      /* Authentic Taipei MRT system colors */
      --line-red: #E3002C;
      --line-red-light: #FF4D6D;
      --line-red-pale: #FFE5EA;

      --line-blue: #0070BD;
      --line-blue-light: #4DA6FF;
      --line-blue-pale: #E5F2FF;

      --line-green: #008659;
      --line-green-light: #4DB88D;
      --line-green-pale: #E5F7F1;

      --line-orange: #F8B61C;
      --line-orange-light: #FFD166;
      --line-orange-pale: #FFF6E5;

      --line-brown: #C48C31;
      --line-brown-light: #E0B86D;
      --line-brown-pale: #F7F0E5;

      --line-yellow: #FFDB00;
      --line-yellow-light: #FFE84D;
      --line-yellow-pale: #FFFBE5;

      --line-purple: #8E44AD;
      --line-purple-light: #BB8FCE;
      --line-purple-pale: #F4ECF7;

      /* Taipei MRT aliases for existing code compatibility */
      --taipei-red: #E3002C;
      --taipei-blue: #0070BD;
      --taipei-green: #008659;
      --taipei-orange: #F8B61C;
      --taipei-brown: #C48C31;
      --taipei-yellow: #FFDB00;

      /* Transit design tokens */
      --transit-font: 'Outfit', var(--font-display);
      --station-size: 40px;
      --station-size-sm: 32px;
      --line-width: 8px;
      --line-width-thin: 4px;

      /* === ACCENT PALETTE: Watercolor Inspired === */
      /* Each color has 3 variants: base, soft, pale */
      --accent-coral: #F28B82;
      --accent-coral-soft: #F8ADA6;
      --accent-coral-pale: #FCE4E2;

      --accent-golden: #F9D56E;
      --accent-golden-soft: #FBE49E;
      --accent-golden-pale: #FEF5DC;

      --accent-mint: #81D4C2;
      --accent-mint-soft: #A8E4D8;
      --accent-mint-pale: #E0F5F1;

      --accent-lavender: #B8A4D0;
      --accent-lavender-soft: #D0C1E0;
      --accent-lavender-pale: #F0EBF5;

      --accent-peach: #FFCAB0;
      --accent-peach-soft: #FFE0D0;
      --accent-peach-pale: #FFF3ED;

      /* === TEXT COLORS === */
      /* Warm charcoal instead of cold black */
      --text-primary: #3B3B3B;
      --text-secondary: #6B6B6B;
      --text-tertiary: #9B9B9B;
      --text-inverse: #FFFFFF;

      /* === UI ELEMENT COLORS === */
      --panel-silver: #E2E2E2;
      --panel-silver-dark: #C8C8C8;
      --panel-dark: #5A5A5A;
      --panel-glow: #7DD590;

      /* === FEEDBACK COLORS === */
      --success-green: #7DD590;
      --success-green-soft: #A8E5B5;
      --success-green-pale: #E5F6E9;
      --success-glow: rgba(125, 213, 144, 0.35);

      --error-soft: #F5A3A3;
      --error-pale: #FDECEC;

      /* === SHADOW SYSTEM === */
      /* Layered, soft shadows for depth */
      --shadow-xs: 0 1px 2px rgba(60, 60, 60, 0.06);
      --shadow-sm: 0 2px 4px rgba(60, 60, 60, 0.08), 0 1px 2px rgba(60, 60, 60, 0.04);
      --shadow-md: 0 4px 8px rgba(60, 60, 60, 0.08), 0 2px 4px rgba(60, 60, 60, 0.04);
      --shadow-lg: 0 8px 16px rgba(60, 60, 60, 0.08), 0 4px 8px rgba(60, 60, 60, 0.04);
      --shadow-xl: 0 12px 24px rgba(60, 60, 60, 0.1), 0 6px 12px rgba(60, 60, 60, 0.05);
      --shadow-glow: 0 0 20px rgba(106, 173, 218, 0.25);
      --shadow-inner: inset 0 2px 4px rgba(60, 60, 60, 0.06);

      /* Colored shadows for special elements */
      --shadow-coral: 0 4px 12px rgba(242, 139, 130, 0.3);
      --shadow-golden: 0 4px 12px rgba(249, 213, 110, 0.35);
      --shadow-mint: 0 4px 12px rgba(129, 212, 194, 0.3);
      --shadow-blue: 0 4px 12px rgba(74, 144, 194, 0.25);

      /* === TYPOGRAPHY === */
      --font-display: 'Fredoka', sans-serif;
      --font-reading: 'Nunito', sans-serif;

      /* Type scale with comfortable reading sizes */
      --text-xs: 0.75rem;
      --text-sm: 0.875rem;
      --text-base: 1rem;
      --text-lg: 1.125rem;
      --text-xl: 1.25rem;
      --text-2xl: 1.5rem;
      --text-3xl: 2rem;
      --text-4xl: 2.5rem;

      /* === SPACING RHYTHM === */
      --space-2xs: 0.25rem;
      --space-xs: 0.5rem;
      --space-sm: 0.75rem;
      --space-md: 1rem;
      --space-lg: clamp(0.75rem, 2vh, 1.5rem);
      --space-xl: clamp(1rem, 2.5vh, 2rem);
      --space-2xl: clamp(1.5rem, 3vh, 3rem);
      --space-3xl: clamp(2rem, 4vh, 4rem);

      /* === BORDER RADIUS === */
      /* Soft, rounded corners throughout */
      --radius-sm: 8px;
      --radius-md: 12px;
      --radius-lg: 16px;
      --radius-xl: 24px;
      --radius-2xl: 32px;
      --radius-full: 9999px;

      /* === TOUCH TARGETS === */
      /* Generous sizes for accessibility */
      --touch-min: clamp(60px, 10vh, 80px);
      --touch-lg: clamp(80px, 12vh, 100px);
      --touch-target: clamp(40px, 6vh, 44px);

      /* === ANIMATION TIMING === */
      /* Gentle, calming motion */
      --anim-instant: 0.1s;
      --anim-fast: 0.2s;
      --anim-medium: 0.35s;
      --anim-slow: 0.5s;
      --anim-slower: 0.8s;

      /* Custom easing curves */
      --ease-out-soft: cubic-bezier(0.25, 0.8, 0.25, 1);
      --ease-bounce: cubic-bezier(0.68, -0.55, 0.265, 1.55);
      --ease-gentle: cubic-bezier(0.4, 0, 0.2, 1);

      /* === GRAIN TEXTURE === */
      /* Subtle noise for organic feel */
      --grain-opacity: 0.03;
    }

    /* Respect reduced motion preference */
    @media (prefers-reduced-motion: reduce) {

      *,
      *::before,
      *::after {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
      }

      /* Keep the ride scene readable (slow, gentle motion) */
      #mrtRideScreen .mrt-train {
        animation-duration: 8s !important;
        animation-iteration-count: infinite !important;
        animation-timing-function: linear !important;
      }

      #mrtRideScreen .train-track,
      #mrtRideScreen .track-ties {
        animation-duration: 1.3s !important;
        animation-iteration-count: infinite !important;
      }

      #mrtRideScreen .mrt-wheel {
        animation-duration: 1.6s !important;
        animation-iteration-count: infinite !important;
      }
    }

    /* ===== CALM MODE ===== */
    /* Muted, soothing palette for overwhelm moments */
    body.calm-mode {
      --accent-coral: #D4B5B2;
      --accent-coral-soft: #E5D0CE;
      --accent-golden: #DDD4B8;
      --accent-golden-soft: #EBE5D4;
      --accent-mint: #B5CFC6;
      --accent-mint-soft: #D0E3DD;
      --accent-lavender: #C5BACE;
      --accent-lavender-soft: #DAD2DF;
      --mrt-blue: #8AAEC8;
      --mrt-blue-soft: #A8C5D8;
      --success-green: #A8CDB4;
      --grain-opacity: 0.02;
    }

    body.calm-mode .reward-animation,
    body.calm-mode .celebration {
      display: none !important;
    }

    /* Calm mode reduces distracting motion, but should not freeze the whole app */
    body.calm-mode * {
      transition-duration: 0.15s !important;
    }

    body.calm-mode .sparkle,
    body.calm-mode .sparkle-layer,
    body.calm-mode .themed-floaters,
    body.calm-mode .cloud,
    body.calm-mode .cloud-layer,
    body.calm-mode .mrt-car,
    body.calm-mode .taipei-bird,
    body.calm-mode .taipei-balloon,
    body.calm-mode .taipei-lantern {
      animation: none !important;
    }

    /* Keep the train ride feeling alive, but slower */
    body.calm-mode #mrtRideScreen .mrt-train {
      animation-timing-function: linear !important;
      animation-duration: 10s !important;
    }

    body.calm-mode #mrtRideScreen .train-track,
    body.calm-mode #mrtRideScreen .track-ties {
      animation-duration: 1.1s !important;
    }

    body.calm-mode #mrtRideScreen .mrt-wheel {
      animation-duration: 1.4s !important;
    }

    /* ===== GLOBAL GRAIN TEXTURE ===== */
    /* SVG-based noise texture for organic paper feel */
    @keyframes grain-shift {

      0%,
      100% {
        transform: translate(0, 0);
      }

      10% {
        transform: translate(-1%, -1%);
      }

      30% {
        transform: translate(1%, 0%);
      }

      50% {
        transform: translate(-1%, 1%);
      }

      70% {
        transform: translate(1%, -1%);
      }

      90% {
        transform: translate(0%, 1%);
      }
    }

    /* ===== BASE STYLES ===== */
    html,
    body {
      height: 100%;
      overflow: hidden;
    }

    body {
      font-family: var(--font-reading);
      font-size: 18px;
      line-height: 1.7;
      letter-spacing: 0.02em;
      color: var(--text-primary);
      background: var(--bg-cream);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: clamp(0.5rem, 1vh, 1.5rem);
      /* Prevent iOS rubber-banding */
      overscroll-behavior: none;
      -webkit-tap-highlight-color: transparent;
      /* Smooth font rendering */
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    /* Subtle paper texture background */
    body::before {
      content: '';
      position: fixed;
      inset: 0;
      background:
        /* Soft radial gradient for warmth */
        radial-gradient(ellipse at 30% 20%, rgba(249, 213, 110, 0.08) 0%, transparent 50%),
        radial-gradient(ellipse at 70% 80%, rgba(129, 212, 194, 0.06) 0%, transparent 50%),
        /* Very subtle dot pattern */
        radial-gradient(circle at 1px 1px, rgba(0, 0, 0, 0.015) 1px, transparent 0);
      background-size: 100% 100%, 100% 100%, 20px 20px;
      pointer-events: none;
      z-index: 0;
    }

    /* Grain overlay for organic texture */
    body::after {
      content: '';
      position: fixed;
      inset: 0;
      background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.85' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)'/%3E%3C/svg%3E");
      opacity: var(--grain-opacity);
      pointer-events: none;
      z-index: 9999;
    }

    /* ===== iPAD MINI OPTIMIZATIONS (744-820px) ===== */
    /* Primary target: iPad Mini 6 (744x1133) and iPad Mini 5 (768x1024) */
    @media screen and (min-width: 700px) and (max-width: 850px) {

      /* === BASE LAYOUT === */
      body {
        padding: 12px;
        font-size: 18px;
      }

      .app-container {
        max-height: 100%;
        height: 100%;
        border-radius: 0;
        max-width: 100%;
      }

      /* Hide decorative corners on iPad Mini for cleaner look */
      .app-container::before,
      .app-container::after {
        display: none;
      }

      /* === HEADER === */
      .header {
        padding: 12px 16px;
      }

      .header-title {
        font-size: 1.1rem;
      }

      .control-btn {
        width: 44px;
        height: 44px;
        font-size: 1.3rem;
      }

      /* === WELCOME SCREEN === */
      .station-sign-hero {
        padding: 1.35rem 2.9rem;
        margin-bottom: 1.35rem;
      }

      .station-sign-hero .station-name-zh {
        font-size: 2rem;
      }

      .station-sign-hero .station-name-en {
        font-size: 1.2rem;
        letter-spacing: 0.12em;
      }

      .welcome-action-bar {
        gap: 1.25rem;
      }

      .welcome-user-chip {
        padding: 12px 20px 12px 14px;
        gap: 12px;
      }

      .welcome-user-chip .user-avatar {
        font-size: 1.8rem;
      }

      .welcome-user-chip .user-name {
        font-size: 1.15rem;
      }

      .board-btn {
        padding: 18px 36px;
        font-size: 1.22rem;
        gap: 14px;
      }

      .board-btn-icon {
        font-size: 1.4em;
      }

      .welcome-message {
        margin-top: 16px;
        padding: 10px 24px;
        font-size: 0.95rem;
      }

      /* Train scene - more height for iPad Mini */
      .mrt-train-scene {
        height: clamp(180px, 30vh, 250px);
      }

      .floating-food {
        font-size: clamp(1.6rem, 4vw, 2.2rem);
      }

      /* === MRT MAP SCREEN === */
      .mrt-title {
        font-size: 1.4rem;
        margin-bottom: 8px;
      }

      .mrt-map {
        padding: 1.5rem 1.25rem;
      }

      .station-btn {
        min-height: 80px;
        padding: 16px 20px 16px 90px;
        margin-bottom: 18px;
        border-radius: 18px;
      }

      .station-btn::before {
        width: 28px;
        height: 28px;
        left: 26px;
        border-width: 6px;
      }

      .station-icon,
      .station-icon-img {
        width: 56px;
        height: 56px;
        font-size: 2.2rem;
        left: 80px;
      }

      .station-name {
        font-size: 1.15rem;
      }

      .station-desc {
        font-size: 0.9rem;
      }

      .station-status {
        font-size: 0.85rem;
        padding: 8px 16px;
      }

      .station-level {
        font-size: 0.75rem;
        padding: 4px 10px;
      }

      /* === RESTAURANT/LESSON SCREEN === */
      .reading-section {
        border-radius: 24px;
        margin: 0 8px;
      }

      .reading-section::before {
        padding: 14px 20px;
        font-size: 1.05rem;
      }

      .sentence-display {
        font-size: 1.5rem !important;
        line-height: 1.8;
        padding: 20px 24px;
      }

      .mrt-line-indicator {
        font-size: 0.8rem;
        padding: 8px 16px;
        gap: 10px;
      }

      .mrt-line-indicator .line-dot {
        width: 12px;
        height: 12px;
      }

      /* Answer buttons - larger touch targets */
      .answer-btn {
        padding: 18px 24px;
        font-size: 1.15rem;
        border-radius: 16px;
        min-height: 64px;
      }

      .answer-grid {
        gap: 14px;
        padding: 16px 20px;
      }

      /* Navigation buttons */
      .reading-nav {
        padding: 16px 20px;
        gap: 14px;
      }

      .reading-nav .big-btn {
        padding: 14px 28px;
        font-size: 1.05rem;
        min-height: 56px;
      }

      /* === PROGRESS BAR === */
      .mrt-progress-bar {
        padding: 12px 20px;
        margin: 12px auto 16px;
        border-radius: 16px;
      }

      .mrt-progress-info {
        font-size: 0.9rem;
      }

      .mrt-progress-stop {
        width: 14px;
        height: 14px;
      }

      .mrt-progress-train svg {
        width: 28px;
        height: 28px;
      }

      /* === ELEVATOR SCREEN === */
      .elevator-shaft {
        max-width: 400px;
      }

      .floor-display {
        font-size: 4rem;
      }

      .floor-btn {
        min-height: 80px;
        padding: 16px;
      }

      .floor-btn .floor-num {
        font-size: 1.8rem;
      }

      .floor-btn .floor-name {
        font-size: 0.95rem;
      }

      /* === WARMUP SCREEN === */
      .warmup-title {
        font-size: 1.5rem;
      }

      .warmup-subtitle {
        font-size: 1rem;
      }

      .word-chip {
        padding: 14px 22px;
        font-size: 1.15rem;
      }

      /* === MODALS & OVERLAYS === */
      .modal-content {
        max-width: 480px;
        padding: 28px;
      }

      .modal-title {
        font-size: 1.4rem;
      }

      .modal-action-btn {
        padding: 14px 24px;
        font-size: 1.05rem;
        min-height: 52px;
      }

      /* === BUDDY CHARACTER === */
      .buddy-container {
        top: 14px;
        right: 14px;
      }

      .buddy-character {
        width: 56px;
        height: 68px;
      }

      .buddy-cup {
        width: 46px;
        height: 52px;
      }

      .buddy-menu {
        min-width: 180px;
      }

      .buddy-menu-item {
        padding: 14px 18px;
        font-size: 1rem;
      }
    }

    /* === iPAD MINI LANDSCAPE === */
    @media screen and (min-width: 900px) and (max-height: 600px) and (orientation: landscape) {
      .app-container {
        max-height: 100%;
      }

      .welcome-content {
        padding: 1rem 2rem;
      }

      .station-sign-hero {
        padding: 0.8rem 2rem;
        margin-bottom: 0.8rem;
      }

      .station-sign-hero .station-name-zh {
        font-size: 1.4rem;
      }

      .mrt-train-scene {
        height: clamp(120px, 35vh, 180px);
      }

      .elevator-screen {
        flex-direction: row;
      }

      .elevator-panel {
        width: 200px;
        flex-direction: column;
      }
    }

    /* Landscape phones/small tablets */
    @media screen and (max-height: 500px) and (orientation: landscape) {
      .app-container {
        max-height: 95vh;
      }

      .welcome-content {
        padding: 0.5rem 1rem;
      }

      .station-sign-hero {
        padding: 0.5rem 1.5rem;
        margin-bottom: 0.5rem;
      }

      .mrt-train-scene {
        height: clamp(100px, 40vh, 140px);
      }

      .big-btn {
        min-height: 50px;
        padding: var(--space-xs) var(--space-md);
      }
    }

    /* ===== MAIN CONTAINER ===== */
    .app-container {
      width: 100%;
      max-width: 900px;
      height: 100%;
      max-height: 98vh;
      background: var(--bg-cream-warm);
      border-radius: var(--radius-2xl);
      box-shadow:
        var(--shadow-xl),
        0 0 0 1px rgba(255, 255, 255, 0.5);
      overflow: hidden;
      display: flex;
      flex-direction: column;
      position: relative;
      z-index: 1;
      /* Subtle inner border for depth */
      border: 1px solid rgba(255, 255, 255, 0.6);
    }

    /* Decorative corner accents - storybook feel */
    .app-container::before,
    .app-container::after {
      content: '';
      position: absolute;
      width: 40px;
      height: 40px;
      pointer-events: none;
      z-index: 100;
      opacity: 0.15;
    }

    .app-container::before {
      top: 8px;
      left: 8px;
      border-top: 3px solid var(--mrt-blue);
      border-left: 3px solid var(--mrt-blue);
      border-radius: 8px 0 0 0;
    }

    .app-container::after {
      top: 8px;
      right: 8px;
      border-top: 3px solid var(--mrt-blue);
      border-right: 3px solid var(--mrt-blue);
      border-radius: 0 8px 0 0;
    }

    /* ===== HEADER ===== */
    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: clamp(0.5rem, 1vh, 1rem) clamp(0.75rem, 1.5vh, 1.5rem);
      background:
        linear-gradient(135deg, var(--mrt-blue) 0%, var(--mrt-blue-soft) 100%);
      color: var(--text-inverse);
      position: relative;
      overflow: hidden;
    }

    /* Subtle wave pattern in header */
    .header::before {
      content: '';
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 6px;
      background:
        radial-gradient(ellipse 24px 6px at 12px 0, transparent 24px, var(--bg-cream-warm) 24px);
      background-size: 24px 6px;
    }

    /* Soft glow behind header */
    .header::after {
      content: '';
      position: absolute;
      inset: 0;
      background: radial-gradient(ellipse at 50% 150%, rgba(255, 255, 255, 0.15) 0%, transparent 60%);
      pointer-events: none;
    }

    .header-title {
      font-family: var(--font-display);
      font-size: clamp(1rem, 2.5vh, 1.25rem);
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: var(--space-sm);
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
      position: relative;
      z-index: 2;
      min-width: 0;
      overflow: hidden;
    }

    .header-home {
      appearance: none;
      border: none;
      background: transparent;
      color: inherit;
      font: inherit;
      padding: 0;
      margin: 0;
      cursor: pointer;
      text-align: left;
      display: inline-flex;
      align-items: center;
      gap: var(--space-sm);
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
      max-width: 100%;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .header-home:focus-visible {
      outline: 3px solid rgba(255, 255, 255, 0.6);
      outline-offset: 4px;
      border-radius: 10px;
    }

    .header-title .icon {
      font-size: 1.5rem;
      filter: drop-shadow(0 1px 2px rgba(0, 0, 0, 0.15));
    }

    .header-controls {
      display: flex;
      gap: 14px;
      flex-wrap: wrap;
      justify-content: flex-end;
      align-items: center;
      position: relative;
      z-index: 3;
    }

    .control-btn {
      width: var(--touch-target);
      height: var(--touch-target);
      border-radius: var(--radius-md);
      border: none;
      background: rgba(255, 255, 255, 0.18);
      backdrop-filter: blur(4px);
      color: var(--text-inverse);
      font-size: 1.2rem;
      cursor: pointer;
      transition: all var(--anim-fast) var(--ease-out-soft);
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: var(--shadow-sm);
    }

    .control-btn.control-text-btn {
      --arch-offset: 0px;
      width: auto;
      min-width: var(--touch-target);
      padding: 0 12px;
      font-family: var(--font-display);
      font-size: 0.95rem;
      font-weight: 700;
      letter-spacing: 0.01em;
      /* Floating text style (no pill background) */
      background: transparent;
      backdrop-filter: none;
      box-shadow: none;
      position: relative;
      transform: translateY(var(--arch-offset));
      text-shadow: 0 1px 10px rgba(0, 0, 0, 0.22);
    }

    @media (min-width: 769px) {

      /* Slight arch on desktop: middle item a touch higher. */
      #skillsBtn {
        --arch-offset: 3px;
      }

      #soundToggle {
        --arch-offset: 0px;
      }

      #settingsBtn {
        --arch-offset: 3px;
      }
    }

    .control-btn.control-text-btn::after {
      content: '';
      position: absolute;
      left: 10px;
      right: 10px;
      bottom: 9px;
      height: 2px;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.0);
      opacity: 0;
      transform: scaleX(0.4);
      transition: opacity var(--anim-fast) var(--ease-out-soft), transform var(--anim-fast) var(--ease-out-soft);
    }

    .control-btn:not(.control-text-btn):hover {
      background: rgba(255, 255, 255, 0.28);
      transform: translateY(-1px);
      box-shadow: var(--shadow-md);
    }

    .control-btn.control-text-btn:hover {
      background: transparent;
      box-shadow: none;
      transform: translateY(calc(var(--arch-offset) - 1px));
      text-shadow:
        0 2px 16px rgba(0, 0, 0, 0.28),
        0 0 18px rgba(255, 255, 255, 0.16);
    }

    .control-btn.control-text-btn:hover::after {
      opacity: 0.55;
      transform: scaleX(1);
      background: rgba(255, 255, 255, 0.9);
    }

    .control-btn:not(.control-text-btn):active {
      transform: translateY(0);
      background: rgba(255, 255, 255, 0.35);
    }

    .control-btn.control-text-btn:active {
      transform: translateY(var(--arch-offset));
      opacity: 0.9;
    }

    .control-btn:not(.control-text-btn).active {
      background: var(--accent-golden);
      color: var(--text-primary);
      box-shadow: var(--shadow-golden);
    }

    .control-btn.control-text-btn.active {
      opacity: 1;
    }

    .control-btn.control-text-btn:not(.active) {
      opacity: 0.85;
    }

    .control-btn.control-text-btn.active::after {
      opacity: 1;
      transform: scaleX(1);
      background: linear-gradient(90deg,
          rgba(255, 255, 255, 0) 0%,
          rgba(248, 182, 28, 0.95) 35%,
          rgba(248, 182, 28, 0.95) 65%,
          rgba(255, 255, 255, 0) 100%);
      box-shadow: 0 0 14px rgba(248, 182, 28, 0.35);
    }

    /* Skills screen filter buttons */
    .skills-filter-btn {
      width: auto;
      height: auto;
      padding: 8px 12px;
      border-radius: 999px;
      font-size: 0.95rem;
      line-height: 1;
    }

    /* ===== BUBBLE TEA BUDDY CHARACTER ===== */
    /* Kawaii companion that replaces header during immersive screens */

    .buddy-container {
      position: fixed;
      top: 12px;
      right: 12px;
      z-index: 1000;
      display: none;
      /* Hidden by default, shown via JS */
    }

    .buddy-container.visible {
      display: block;
    }

    /* The bubble tea character */
    .buddy-character {
      width: 52px;
      height: 64px;
      cursor: pointer;
      position: relative;
      filter: drop-shadow(0 4px 8px rgba(0, 0, 0, 0.15));
      transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
      animation: buddyFloat 3s ease-in-out infinite;
    }

    .buddy-character:hover {
      transform: scale(1.1);
    }

    .buddy-character:active {
      transform: scale(0.95);
    }

    @keyframes buddyFloat {

      0%,
      100% {
        transform: translateY(0);
      }

      50% {
        transform: translateY(-4px);
      }
    }

    /* Bubble tea cup body */
    .buddy-cup {
      position: absolute;
      bottom: 0;
      left: 50%;
      transform: translateX(-50%);
      width: 42px;
      height: 48px;
      background: linear-gradient(135deg, #FFE4C9 0%, #FFDAB9 50%, #FFD4A8 100%);
      border-radius: 6px 6px 12px 12px;
      border: 2.5px solid #E8C4A0;
      overflow: hidden;
    }

    /* Milk tea color inside - filled up nicely */
    .buddy-tea {
      position: absolute;
      bottom: 4px;
      left: 4px;
      right: 4px;
      height: 36px;
      background: linear-gradient(180deg, #D4A574 0%, #C89660 100%);
      border-radius: 8px 8px 8px 8px;
      /* Rounded top like liquid surface */
    }

    /* Boba pearls - floating in the tea below the face */
    .buddy-boba {
      position: absolute;
      width: 6px;
      height: 6px;
      background: radial-gradient(circle at 30% 30%, #4A3728 0%, #2C1810 100%);
      border-radius: 50%;
    }

    /* Scattered in middle of cup */
    .buddy-boba:nth-child(1) {
      bottom: 12px;
      left: 6px;
    }

    .buddy-boba:nth-child(2) {
      bottom: 15px;
      left: 15px;
    }

    .buddy-boba:nth-child(3) {
      bottom: 11px;
      right: 8px;
    }

    .buddy-boba:nth-child(4) {
      bottom: 16px;
      right: 14px;
      width: 5px;
      height: 5px;
    }

    .buddy-boba:nth-child(5) {
      bottom: 13px;
      left: 23px;
      width: 5px;
      height: 5px;
    }

    .buddy-boba:nth-child(6) {
      bottom: 10px;
      left: 11px;
      width: 5px;
      height: 5px;
    }

    .buddy-boba:nth-child(7) {
      bottom: 14px;
      left: 3px;
      width: 4px;
      height: 4px;
    }

    .buddy-boba:nth-child(8) {
      bottom: 12px;
      right: 4px;
      width: 4px;
      height: 4px;
    }

    /* Dome lid */
    .buddy-lid {
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      width: 46px;
      height: 20px;
      background: linear-gradient(180deg, rgba(255, 255, 255, 0.95) 0%, rgba(240, 240, 240, 0.9) 100%);
      border-radius: 50% 50% 0 0;
      border: 2px solid rgba(200, 200, 200, 0.6);
      border-bottom: none;
    }

    /* Straw */
    .buddy-straw {
      position: absolute;
      top: 0;
      left: 50%;
      transform: translateX(-50%);
      width: 8px;
      height: 24px;
      background: linear-gradient(90deg, #FF8FAB 0%, #FF6B8A 50%, #FF8FAB 100%);
      border-radius: 4px 4px 0 0;
      border: 1.5px solid #E85A7A;
    }

    /* Cute face */
    .buddy-face {
      position: absolute;
      top: 28px;
      left: 50%;
      transform: translateX(-50%);
      width: 32px;
      height: 16px;
    }

    .buddy-eye {
      position: absolute;
      width: 7px;
      height: 8px;
      background: #2C1810;
      border-radius: 50%;
      top: 0;
      animation: buddyBlink 4s ease-in-out infinite;
    }

    .buddy-eye.left {
      left: 4px;
    }

    .buddy-eye.right {
      right: 4px;
    }

    .buddy-eye::after {
      content: '';
      position: absolute;
      top: 1px;
      left: 2px;
      width: 3px;
      height: 3px;
      background: white;
      border-radius: 50%;
    }

    @keyframes buddyBlink {

      0%,
      45%,
      55%,
      100% {
        transform: scaleY(1);
      }

      50% {
        transform: scaleY(0.1);
      }
    }

    .buddy-smile {
      position: absolute;
      bottom: 0;
      left: 50%;
      transform: translateX(-50%);
      width: 10px;
      height: 5px;
      border: 2px solid #2C1810;
      border-top: none;
      border-radius: 0 0 10px 10px;
    }

    /* Cheek blush */
    .buddy-blush {
      position: absolute;
      top: 6px;
      width: 8px;
      height: 4px;
      background: rgba(255, 150, 150, 0.5);
      border-radius: 50%;
    }

    .buddy-blush.left {
      left: -2px;
    }

    .buddy-blush.right {
      right: -2px;
    }

    /* Glow effect when tapped */
    .buddy-character.tapped {
      animation: buddyPulse 0.5s ease-out;
    }

    @keyframes buddyPulse {
      0% {
        filter: drop-shadow(0 4px 8px rgba(0, 0, 0, 0.15));
      }

      50% {
        filter: drop-shadow(0 0 20px rgba(255, 180, 100, 0.6));
      }

      100% {
        filter: drop-shadow(0 4px 8px rgba(0, 0, 0, 0.15));
      }
    }

    /* ===== BUDDY MENU ===== */
    .buddy-menu-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.3);
      backdrop-filter: blur(4px);
      z-index: 999;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s ease;
    }

    .buddy-menu-overlay.open {
      opacity: 1;
      pointer-events: auto;
    }

    .buddy-menu {
      position: fixed;
      top: 80px;
      right: 12px;
      background: linear-gradient(145deg, #FFF9F0 0%, #FFF5E8 100%);
      border-radius: 20px;
      padding: 12px;
      box-shadow:
        0 8px 32px rgba(0, 0, 0, 0.15),
        0 2px 8px rgba(0, 0, 0, 0.08),
        inset 0 1px 0 rgba(255, 255, 255, 0.8);
      z-index: 1001;
      transform: translateX(120%) scale(0.8);
      opacity: 0;
      transition: all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
      min-width: 160px;
    }

    .buddy-menu.open {
      transform: translateX(0) scale(1);
      opacity: 1;
    }

    .buddy-menu-item {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 14px 16px;
      border-radius: 14px;
      background: transparent;
      border: none;
      width: 100%;
      font-family: var(--font-display);
      font-size: 1rem;
      font-weight: 600;
      color: var(--text-primary);
      cursor: pointer;
      transition: all 0.2s ease;
      text-align: left;
    }

    .buddy-menu-item:hover {
      background: rgba(255, 200, 150, 0.3);
      transform: translateX(4px);
    }

    .buddy-menu-item:active {
      transform: scale(0.97);
    }

    .buddy-menu-item .menu-icon {
      font-size: 1.3rem;
      width: 28px;
      text-align: center;
    }

    .buddy-menu-item .menu-label {
      flex: 1;
    }

    /* Divider between menu items */
    .buddy-menu-divider {
      height: 1px;
      background: linear-gradient(90deg, transparent, rgba(200, 180, 150, 0.3), transparent);
      margin: 6px 8px;
    }

    /* Audio toggle state indicator */
    .buddy-menu-item.audio-on .menu-icon::after {
      content: ' âœ“';
      font-size: 0.8rem;
      color: var(--success-green);
    }

    /* Header visibility control */
    .header.buddy-mode {
      display: none !important;
    }

    /* ===== PROGRESS BAR ===== */
    .progress-container {
      padding: clamp(0.35rem, 0.75vh, 0.75rem) clamp(0.75rem, 1.5vh, 1.5rem);
      background:
        linear-gradient(180deg, var(--bg-soft-blue-deep) 0%, var(--bg-soft-blue) 100%);
      display: flex;
      align-items: center;
      gap: var(--space-md);
      border-bottom: 1px solid rgba(0, 0, 0, 0.04);
    }

    .progress-label {
      font-family: var(--font-display);
      font-size: var(--text-sm);
      font-weight: 500;
      color: var(--text-secondary);
      white-space: nowrap;
      letter-spacing: 0.02em;
    }

    .progress-bar {
      flex: 1;
      height: 10px;
      background: rgba(255, 255, 255, 0.8);
      border-radius: var(--radius-full);
      overflow: hidden;
      box-shadow: var(--shadow-inner);
      position: relative;
    }

    .progress-fill {
      height: 100%;
      background:
        linear-gradient(90deg,
          var(--accent-mint) 0%,
          var(--success-green) 50%,
          var(--accent-mint-soft) 100%);
      background-size: 200% 100%;
      border-radius: var(--radius-full);
      transition: width var(--anim-slower) var(--ease-out-soft);
      position: relative;
    }

    /* Animated shimmer on progress */
    .progress-fill::after {
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(90deg,
          transparent 0%,
          rgba(255, 255, 255, 0.4) 50%,
          transparent 100%);
      animation: shimmer 2s ease-in-out infinite;
    }

    @keyframes shimmer {
      0% {
        transform: translateX(-100%);
      }

      100% {
        transform: translateX(100%);
      }
    }

    .sticker-count {
      display: flex;
      align-items: center;
      gap: 6px;
      font-family: var(--font-display);
      font-weight: 600;
      font-size: var(--text-lg);
      color: var(--accent-coral);
      background: rgba(255, 255, 255, 0.6);
      padding: var(--space-2xs) var(--space-sm);
      border-radius: var(--radius-full);
      box-shadow: var(--shadow-xs);
    }

    .sticker-count span:first-child {
      font-size: 1.1rem;
      filter: drop-shadow(0 1px 1px rgba(0, 0, 0, 0.1));
    }

    /* ===== MAIN CONTENT AREA ===== */
    .main-content {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      position: relative;
      background: var(--bg-cream-warm);
    }

    /* ===== SCREENS ===== */
    .screen {
      position: absolute;
      inset: 0;
      display: flex;
      flex-direction: column;
      opacity: 0;
      visibility: hidden;
      pointer-events: none;
      transition:
        opacity var(--anim-medium) var(--ease-gentle),
        visibility 0s linear var(--anim-medium);
      /* Page-turn feel */
      transform-origin: left center;
    }

    /* Ensure all screens overlay (some screen-specific styles set `position`). */
    .main-content>.screen {
      position: absolute;
      inset: 0;
    }

    .screen.active {
      opacity: 1;
      visibility: visible;
      pointer-events: auto;
      transition:
        opacity var(--anim-medium) var(--ease-gentle),
        visibility 0s linear 0s;
    }

    /* ===== WELCOME SCREEN - TAIPEI MRT PLATFORM ===== */
    .welcome-screen {
      background: linear-gradient(180deg, #87CEEB 0%, #B0E0E6 40%, #E8D4B8 100%);
      align-items: center;
      justify-content: flex-end;
      padding: 0;
      text-align: center;
      overflow: hidden;
      position: relative;
    }

    /* Taipei Skyline Background */
    .welcome-skyline {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 55%;
      background:
        url('assets/train_scenes/taipei_101_day.jpeg') center/cover no-repeat;
      opacity: 0.4;
      filter: blur(2px) saturate(1.2);
      z-index: 1;
    }

    .welcome-skyline::after {
      content: '';
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 60%;
      background: linear-gradient(to top,
          rgba(232, 212, 184, 1) 0%,
          rgba(232, 212, 184, 0.8) 30%,
          transparent 100%);
    }

    /* Floating Food Emojis - scattered around welcome screen */
    .floating-food {
      position: absolute;
      font-size: clamp(1.5rem, 3.5vw, 2rem);
      left: var(--x);
      top: var(--y);
      animation: gentle-float 5s ease-in-out infinite;
      animation-delay: var(--delay);
      opacity: 0.65;
      filter: drop-shadow(0 4px 12px rgba(0, 0, 0, 0.12));
      z-index: 15;
      pointer-events: none;
    }

    /* Vary sizes for depth */
    .floating-food:nth-child(odd) {
      font-size: clamp(1.3rem, 3vw, 1.8rem);
      opacity: 0.55;
    }

    .floating-food:nth-child(3n) {
      font-size: clamp(1.8rem, 4vw, 2.3rem);
      opacity: 0.75;
    }

    @keyframes gentle-float {

      0%,
      100% {
        transform: translateY(0px) rotate(-3deg) scale(1);
      }

      50% {
        transform: translateY(-12px) rotate(3deg) scale(1.08);
      }
    }

    /* MRT Platform Container */
    .mrt-platform {
      position: relative;
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      z-index: 10;
    }

    /* Welcome Content - Top Section */
    .welcome-content {
      position: relative;
      z-index: 20;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: clamp(1.5rem, 4vh, 3rem) clamp(1rem, 3vw, 2rem);
      flex: 1;
      justify-content: center;
    }

    /* Station Sign */
    .station-sign {
      background: linear-gradient(180deg, #1a1a2e 0%, #16213e 100%);
      border-radius: 12px;
      padding: clamp(0.6rem, 1.5vh, 1rem) clamp(1.2rem, 3vw, 2rem);
      margin-bottom: clamp(0.8rem, 2vh, 1.5rem);
      box-shadow:
        0 8px 32px rgba(0, 0, 0, 0.3),
        inset 0 1px 0 rgba(255, 255, 255, 0.1);
      animation: sign-glow 3s ease-in-out infinite;
      position: relative;
      overflow: hidden;
    }

    .station-sign::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg,
          transparent,
          rgba(255, 255, 255, 0.1),
          transparent);
      animation: sign-shine 4s ease-in-out infinite;
    }

    @keyframes sign-shine {

      0%,
      100% {
        left: -100%;
      }

      50% {
        left: 100%;
      }
    }

    @keyframes sign-glow {

      0%,
      100% {
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.1);
      }

      50% {
        box-shadow: 0 8px 40px rgba(74, 144, 194, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.15);
      }
    }

    .station-name-zh {
      font-family: var(--font-display);
      font-size: clamp(1.1rem, 3vw, 1.5rem);
      font-weight: 700;
      color: #FFD700;
      text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
      letter-spacing: 0.1em;
      margin-bottom: 2px;
    }

    .station-name-en {
      font-family: var(--font-display);
      font-size: clamp(0.7rem, 1.8vw, 0.9rem);
      font-weight: 600;
      color: #E0E0E0;
      letter-spacing: 0.05em;
      text-transform: uppercase;
    }

    /* Welcome Title */
    .welcome-title {
      font-family: var(--font-display);
      font-size: clamp(1.6rem, 5vw, 2.5rem);
      font-weight: 800;
      margin-bottom: var(--space-xs);
      position: relative;
      z-index: 10;
      line-height: 1.2;
      animation: title-appear 0.8s ease-out 0.3s backwards;
    }

    @keyframes title-appear {
      0% {
        opacity: 0;
        transform: translateY(20px);
      }

      100% {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .title-word {
      display: block;
    }

    .title-word:first-child {
      color: var(--mrt-blue);
      font-size: 0.7em;
      font-weight: 600;
      margin-bottom: 0.1em;
    }

    .title-highlight {
      background: linear-gradient(135deg,
          var(--line-red) 0%,
          var(--line-orange) 33%,
          var(--line-blue) 66%,
          var(--line-green) 100%);
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      filter: drop-shadow(0 2px 8px rgba(74, 144, 194, 0.3));
      font-weight: 900;
      letter-spacing: -0.02em;
    }

    .welcome-subtitle {
      font-size: clamp(0.85rem, 2.2vh, 1rem);
      color: var(--text-secondary);
      margin-bottom: clamp(0.8rem, 2vh, 1.2rem);
      max-width: 380px;
      line-height: 1.5;
      position: relative;
      z-index: 10;
      animation: title-appear 0.8s ease-out 0.5s backwards;
    }

    /* ===== COHESIVE WELCOME LAYOUT ===== */

    /* Enhanced Hero Station Sign */
    .station-sign-hero {
      padding: clamp(1.2rem, 3vh, 1.9rem) clamp(2.4rem, 6vw, 3.6rem);
      margin-bottom: clamp(1.2rem, 3vh, 1.8rem);
      text-align: center;
    }

    .station-sign-hero .station-name-zh {
      font-size: clamp(1.65rem, 4.6vw, 2.25rem);
      margin-bottom: 4px;
    }

    .station-sign-hero .station-name-en {
      font-size: clamp(1.02rem, 2.8vw, 1.35rem);
      letter-spacing: 0.15em;
    }

    /* Action Bar - User + Board Button */
    .welcome-action-bar {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: clamp(1rem, 2.5vw, 1.6rem);
      animation: title-appear 0.8s ease-out 0.5s backwards;
      position: relative;
      z-index: 10;
      flex-wrap: wrap;
    }

    /* User Chip - Compact Profile Display */
    .welcome-user-chip {
      display: flex;
      align-items: center;
      gap: 10px;
      background: rgba(255, 255, 255, 0.95);
      padding: 10px 18px 10px 12px;
      border-radius: 50px;
      box-shadow:
        0 2px 8px rgba(0, 0, 0, 0.1),
        0 1px 2px rgba(0, 0, 0, 0.06);
      font-family: var(--font-display);
      cursor: pointer;
      transition: all 0.2s ease;
      border: 2px solid transparent;
    }

    .welcome-user-chip:hover {
      box-shadow:
        0 4px 12px rgba(0, 0, 0, 0.15),
        0 2px 4px rgba(0, 0, 0, 0.08);
      border-color: var(--mrt-blue-pale);
    }

    .welcome-user-chip .user-avatar {
      font-size: 1.7rem;
      line-height: 1;
    }

    .welcome-user-chip .user-name {
      font-weight: 700;
      font-size: 1.1rem;
      color: var(--text-primary);
    }

    .welcome-user-chip .user-switch-btn {
      background: none;
      border: none;
      color: var(--text-tertiary);
      font-size: 0.85rem;
      cursor: pointer;
      padding: 4px 6px;
      border-radius: 4px;
      transition: all 0.2s ease;
    }

    .welcome-user-chip .user-switch-btn:hover {
      background: var(--bg-soft-blue);
      color: var(--mrt-blue);
    }

    /* Board Button - Primary CTA */
    .board-btn {
      display: flex;
      align-items: center;
      gap: 12px;
      background: linear-gradient(135deg, var(--mrt-blue) 0%, var(--mrt-blue-deep) 100%);
      color: white;
      border: none;
      padding: clamp(14px, 2.4vh, 18px) clamp(26px, 5vw, 38px);
      border-radius: 50px;
      font-family: var(--font-display);
      font-size: clamp(1.08rem, 2.7vw, 1.28rem);
      font-weight: 700;
      cursor: pointer;
      box-shadow:
        0 4px 15px rgba(74, 144, 194, 0.4),
        0 2px 4px rgba(0, 0, 0, 0.1),
        inset 0 1px 0 rgba(255, 255, 255, 0.2);
      transition: all 0.25s ease;
      position: relative;
      overflow: hidden;
    }

    .board-btn::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg,
          transparent,
          rgba(255, 255, 255, 0.2),
          transparent);
      transition: left 0.5s ease;
    }

    .board-btn:hover {
      transform: translateY(-2px);
      box-shadow:
        0 6px 20px rgba(74, 144, 194, 0.5),
        0 4px 8px rgba(0, 0, 0, 0.15),
        inset 0 1px 0 rgba(255, 255, 255, 0.25);
    }

    .board-btn:hover::before {
      left: 100%;
    }

    .board-btn:active {
      transform: translateY(0);
    }

    .board-btn-icon {
      font-size: 1.45em;
      line-height: 1;
    }

    .board-btn-text {
      letter-spacing: 0.02em;
    }

    /* Welcome Message - Below action bar */
    .welcome-message {
      margin-top: clamp(12px, 2vh, 18px);
      padding: 8px 20px;
      background: linear-gradient(135deg, rgba(26, 26, 46, 0.85) 0%, rgba(22, 33, 62, 0.85) 100%);
      border-radius: 20px;
      font-family: var(--font-display);
      font-size: clamp(0.8rem, 2vw, 0.95rem);
      font-weight: 600;
      color: #E0E0E0;
      letter-spacing: 0.03em;
      box-shadow:
        0 4px 12px rgba(0, 0, 0, 0.2),
        inset 0 1px 0 rgba(255, 255, 255, 0.1);
      animation: title-appear 0.8s ease-out 0.7s backwards;
      position: relative;
      z-index: 10;
    }

    /* Responsive: Mobile layout for action bar */
    @media (max-width: 480px) {
      .welcome-action-bar {
        flex-direction: column;
        gap: 14px;
      }

      .station-sign-hero {
        padding: clamp(0.8rem, 2vh, 1.2rem) clamp(1.5rem, 4vw, 2rem);
        margin-bottom: 12px;
      }

      .station-sign-hero .station-name-zh {
        font-size: clamp(1.2rem, 5vw, 1.6rem);
      }

      .station-sign-hero .station-name-en {
        font-size: clamp(0.75rem, 3vw, 1rem);
      }

      .welcome-user-chip {
        order: 2;
        /* Move user chip below button on mobile */
      }

      .board-btn {
        order: 1;
        width: 100%;
        justify-content: center;
      }
    }

    /* Start Button Enhancement */
    .welcome-content .big-btn {
      animation: title-appear 0.8s ease-out 0.7s backwards;
      position: relative;
      overflow: hidden;
    }

    .welcome-content .big-btn::after {
      content: 'ðŸš‡';
      position: absolute;
      right: -30px;
      opacity: 0;
      transition: all 0.3s ease;
    }

    .welcome-content .big-btn:hover::after {
      right: 12px;
      opacity: 1;
    }

    /* ===== MRT TRAIN SCENE ===== */
    .mrt-train-scene {
      position: relative;
      width: 100%;
      height: clamp(160px, 28vh, 220px);
      overflow: hidden;
    }

    /* Full Glass Wall Barrier - Realistic MRT Platform Safety Glass */
	    .platform-glass-wall {
	      position: absolute;
	      bottom: clamp(45px, 10vh, 65px);
	      left: 0;
	      right: 0;
	      height: clamp(95px, 17vh, 140px);
	      background: linear-gradient(180deg,
	          rgba(200, 220, 235, 0.15) 0%,
	          rgba(180, 210, 230, 0.12) 30%,
	          rgba(160, 200, 225, 0.08) 70%,
	          rgba(140, 190, 220, 0.05) 100%);
	      /* Keep the glass crisp (backdrop blur makes the train/doors look blurry). */
	      backdrop-filter: none;
	      -webkit-backdrop-filter: none;
	      border-top: 3px solid rgba(200, 220, 235, 0.6);
	      z-index: 2;
	      pointer-events: none;
	      overflow: hidden;
	    }

    /* Glass reflections */
    .platform-glass-wall::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 40%;
      background: linear-gradient(180deg,
          rgba(255, 255, 255, 0.25) 0%,
          rgba(255, 255, 255, 0.08) 50%,
          transparent 100%);
      pointer-events: none;
    }

    /* Subtle vertical reflection streaks */
    .platform-glass-wall::after {
      content: '';
      position: absolute;
      top: 0;
      bottom: 0;
      left: 10%;
      width: 3px;
      background: linear-gradient(180deg,
          transparent 0%,
          rgba(255, 255, 255, 0.15) 30%,
          rgba(255, 255, 255, 0.2) 50%,
          rgba(255, 255, 255, 0.15) 70%,
          transparent 100%);
      box-shadow:
        60px 0 0 rgba(255, 255, 255, 0.1),
        150px 0 0 rgba(255, 255, 255, 0.12),
        280px 0 0 rgba(255, 255, 255, 0.08),
        400px 0 0 rgba(255, 255, 255, 0.15);
    }

    /* Glass top rail/frame */
    .glass-top-rail {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 8px;
      background: linear-gradient(180deg,
          #C0C8D0 0%,
          #E0E4E8 40%,
          #D8DCE0 60%,
          #B8C0C8 100%);
      z-index: 16;
    }

    .glass-top-rail::after {
      content: '';
      position: absolute;
      top: 2px;
      left: 0;
      right: 0;
      height: 2px;
      background: linear-gradient(90deg,
          transparent,
          rgba(255, 255, 255, 0.6) 20%,
          rgba(255, 255, 255, 0.8) 50%,
          rgba(255, 255, 255, 0.6) 80%,
          transparent);
    }

    /* Platform Safety Line */
    .platform-safety-line {
      position: absolute;
      bottom: clamp(45px, 10vh, 65px);
      left: 0;
      right: 0;
      height: 6px;
      background: repeating-linear-gradient(90deg,
          #FFD700 0px, #FFD700 20px,
          #1a1a1a 20px, #1a1a1a 40px);
      z-index: 5;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
    }

    /* Platform Floor */
    .platform-floor {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: clamp(45px, 10vh, 65px);
      background: linear-gradient(180deg,
          #D4C4A8 0%,
          #C9B896 50%,
          #BEA882 100%);
      z-index: 4;
    }

    .platform-floor::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 4px;
      background: linear-gradient(90deg,
          #8B7355 0%, #A08060 50%, #8B7355 100%);
    }

    /* Platform Tactile Strips */
    .platform-tactile {
      position: absolute;
      bottom: clamp(50px, 11vh, 72px);
      left: 5%;
      right: 5%;
      height: 8px;
      background: repeating-linear-gradient(90deg,
          #FFD54F 0px, #FFD54F 8px,
          transparent 8px, transparent 16px);
      border-radius: 2px;
      z-index: 6;
    }

    /* Platform Screen Doors */
    .platform-doors {
      position: absolute;
      bottom: clamp(45px, 10vh, 65px);
      left: 0;
      right: 0;
      height: clamp(90px, 16vh, 130px);
      display: flex;
      justify-content: center;
      gap: 0;
      z-index: 8;
    }

	    .door-frame {
	      position: relative;
	      width: clamp(70px, 15vw, 100px);
	      height: 100%;
	      /* Let the opening show the train behind (panels provide the fill). */
	      background: transparent;
	      border: 3px solid #A0A0A0;
	      border-bottom: none;
	      display: flex;
	      overflow: hidden;
	      box-shadow:
	        inset 0 0 0 1px rgba(255, 255, 255, 0.45),
	        inset 0 10px 18px rgba(255, 255, 255, 0.08),
	        inset 0 -10px 18px rgba(0, 0, 0, 0.06);
	    }

    .door-panel {
      width: 50%;
      height: 100%;
      background: linear-gradient(180deg,
          rgba(135, 206, 235, 0.4) 0%,
          rgba(176, 224, 230, 0.3) 100%);
      border: 1px solid rgba(255, 255, 255, 0.5);
      position: relative;
      transition: transform 1.5s cubic-bezier(0.25, 0.46, 0.45, 0.94);
    }

    .door-panel::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(135deg,
          rgba(255, 255, 255, 0.3) 0%,
          transparent 50%,
          rgba(0, 0, 0, 0.05) 100%);
    }

    .door-panel.left {
      border-right: 1px solid #C0C0C0;
    }

    .door-panel.right {
      border-left: 1px solid #C0C0C0;
    }

    /* Door Opening Animation */
    .platform-doors.doors-open .door-panel.left {
      transform: translateX(-95%);
    }

    .platform-doors.doors-open .door-panel.right {
      transform: translateX(95%);
    }

    .door-frame::after {
      content: '';
      position: absolute;
      top: 8px;
      left: 50%;
      transform: translateX(-50%);
      width: 8px;
      height: 8px;
      background: #00C853;
      border-radius: 50%;
      box-shadow: 0 0 8px #00C853;
      animation: door-light 2s ease-in-out infinite;
    }

    @keyframes door-light {

      0%,
      100% {
        opacity: 1;
        box-shadow: 0 0 8px #00C853;
      }

      50% {
        opacity: 0.6;
        box-shadow: 0 0 4px #00C853;
      }
    }

    /* Door Pillars */
    .door-pillar {
      width: clamp(15px, 3vw, 22px);
      height: clamp(90px, 16vh, 130px);
      background: linear-gradient(90deg,
          #B8B8B8 0%,
          #E0E0E0 30%,
          #E8E8E8 50%,
          #E0E0E0 70%,
          #B8B8B8 100%);
      position: relative;
      z-index: 9;
    }

    .door-pillar::before {
      content: '';
      position: absolute;
      top: 10%;
      left: 50%;
      transform: translateX(-50%);
      width: 60%;
      height: 80%;
      background: linear-gradient(180deg,
          rgba(0, 0, 0, 0.05) 0%,
          transparent 50%,
          rgba(0, 0, 0, 0.05) 100%);
    }

		    /* ===== REALISTIC TAIPEI MRT TRAIN (WELCOME SCENE) ===== */
		    .mrt-train-scene .mrt-train {
		      position: absolute;
		      bottom: clamp(50px, 11vh, 72px);
		      left: 50%;
		      opacity: 0;
		      /* Keep the train off-screen when restarting the animation to avoid flashes. */
		      /* `100%` is the train width; ensures fully off-screen even if the train is longer than the viewport. */
		      --welcome-train-travel: calc(100vw + 100%);
		      transform: translate3d(calc(-50% - var(--welcome-train-travel)), 0, 0);
		      display: flex;
		      align-items: flex-end;
		      z-index: 7;
		      animation: train-arrival-sequence 16s ease-in-out infinite;
      will-change: transform, opacity;
	      filter: drop-shadow(0 8px 16px rgba(0, 0, 0, 0.25));
	    }

	    /* Train arrival, stop, doors open, doors close, depart sequence */
		    @keyframes train-arrival-sequence {
		      /* Arrive from left */
		      0% {
		        opacity: 0;
		        transform: translate3d(calc(-50% - var(--welcome-train-travel)), 0, 0);
		      }
		      2% {
		        opacity: 1;
		        transform: translate3d(calc(-50% - var(--welcome-train-travel)), 0, 0);
		      }
		      /* Decelerate and stop in center (aligned with doors) */
		      18% {
		        opacity: 1;
		        transform: translate3d(-50%, 0, 0);
		      }
		      /* Stay stopped while doors operate */
		      70% {
		        opacity: 1;
		        transform: translate3d(-50%, 0, 0);
		      }
		      98% {
		        opacity: 1;
		        transform: translate3d(calc(-50% + var(--welcome-train-travel)), 0, 0);
		      }
		      /* Accelerate and depart to right */
		      100% {
		        opacity: 0;
		        transform: translate3d(calc(-50% + var(--welcome-train-travel)), 0, 0);
		      }
		    }

    /* ===== TRAIN DOORS ===== */
    .train-door-container {
      position: absolute;
      bottom: 15%;
      left: 50%;
      transform: translateX(-50%);
      width: 35%;
      height: 60%;
      overflow: hidden;
      z-index: 2;
    }

    .train-door {
      position: absolute;
      top: 0;
      width: 50%;
      height: 100%;
      background: linear-gradient(180deg,
          rgba(100, 140, 180, 0.5) 0%,
          rgba(120, 160, 200, 0.4) 50%,
          rgba(100, 140, 180, 0.5) 100%);
      border: 1px solid rgba(80, 120, 160, 0.6);
      transition: transform 1.2s cubic-bezier(0.25, 0.46, 0.45, 0.94);
    }

    .train-door::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(135deg,
          rgba(255, 255, 255, 0.4) 0%,
          transparent 50%,
          rgba(0, 0, 0, 0.1) 100%);
    }

    .train-door.left {
      left: 0;
      border-right: 1px solid rgba(60, 100, 140, 0.5);
    }

    .train-door.right {
      right: 0;
      border-left: 1px solid rgba(60, 100, 140, 0.5);
    }

    /* Train doors open state */
    .mrt-train.doors-open .train-door.left {
      transform: translateX(-100%);
    }

    .mrt-train.doors-open .train-door.right {
      transform: translateX(100%);
    }

    /* Head car doors (slightly different position) */
    .train-head .train-door-container {
      left: 65%;
      width: 28%;
    }

    /* Regular car doors */
    .car-body-mrt .train-door-container {
      position: absolute;
      bottom: 8%;
      left: 50%;
      transform: translateX(-50%);
      width: 40%;
      height: 65%;
      overflow: hidden;
      z-index: 2;
    }

    /* Train Car - Modern MRT Design */
    .train-car-mrt {
      position: relative;
      width: clamp(100px, 22vw, 150px);
      height: clamp(70px, 14vh, 100px);
    }

    /* Car Body - Silver with colored stripe */
    .car-body-mrt {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 85%;
      background: linear-gradient(180deg,
          #F5F5F5 0%,
          #E8E8E8 20%,
          #E0E0E0 80%,
          #D0D0D0 100%);
      border-radius: 4px 4px 2px 2px;
      overflow: hidden;
      box-shadow:
        inset 0 2px 4px rgba(255, 255, 255, 0.8),
        inset 0 -2px 4px rgba(0, 0, 0, 0.1),
        0 4px 12px rgba(0, 0, 0, 0.2);
    }

    /* Colored Stripe */
    .car-stripe {
      position: absolute;
      bottom: 8%;
      left: 0;
      right: 0;
      height: 18%;
      background: var(--stripe-color, var(--line-blue));
      box-shadow:
        inset 0 2px 4px rgba(255, 255, 255, 0.3),
        inset 0 -2px 4px rgba(0, 0, 0, 0.2);
    }

    /* Windows */
    .car-windows {
      position: absolute;
      top: 12%;
      left: 8%;
      right: 8%;
      height: 50%;
      display: flex;
      gap: 6%;
    }

    .car-window {
      flex: 1;
      background: linear-gradient(180deg,
          #1a3a5c 0%,
          #2d5a7b 30%,
          #4a8ab0 100%);
      border-radius: 3px;
      position: relative;
      overflow: hidden;
      box-shadow:
        inset 0 0 0 2px rgba(0, 0, 0, 0.15),
        inset 0 2px 4px rgba(0, 0, 0, 0.2);
    }

    .car-window::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 60%;
      bottom: 60%;
      background: linear-gradient(135deg,
          rgba(255, 255, 255, 0.4) 0%,
          transparent 100%);
    }

    /* Train Head Car */
    .train-head {
      position: relative;
      width: clamp(110px, 24vw, 165px);
      height: clamp(70px, 14vh, 100px);
    }

    .head-body {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 85%;
      background: linear-gradient(180deg,
          #F5F5F5 0%,
          #E8E8E8 20%,
          #E0E0E0 80%,
          #D0D0D0 100%);
      border-radius: 20px 4px 2px 2px;
      overflow: hidden;
      box-shadow:
        inset 0 2px 4px rgba(255, 255, 255, 0.8),
        inset 0 -2px 4px rgba(0, 0, 0, 0.1),
        0 4px 12px rgba(0, 0, 0, 0.2);
    }

    .head-stripe {
      position: absolute;
      bottom: 8%;
      left: 0;
      right: 0;
      height: 18%;
      background: var(--stripe-color, var(--line-blue));
      border-radius: 0 0 0 8px;
    }

    /* Windshield */
    .head-windshield {
      position: absolute;
      top: 10%;
      left: 5%;
      width: 35%;
      height: 55%;
      background: linear-gradient(135deg,
          #0a1628 0%,
          #1a3a5c 40%,
          #2d5a7b 100%);
      border-radius: 12px 4px 4px 8px;
      box-shadow:
        inset 0 0 0 2px rgba(0, 0, 0, 0.2),
        inset 2px 2px 8px rgba(0, 0, 0, 0.3);
      overflow: hidden;
    }

    .head-windshield::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 60%;
      height: 40%;
      background: linear-gradient(135deg,
          rgba(255, 255, 255, 0.3) 0%,
          transparent 100%);
    }

    /* LED Destination Display */
    .head-display {
      position: absolute;
      top: 15%;
      right: 10%;
      width: 45%;
      height: 20%;
      background: #0a0a0a;
      border-radius: 2px;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
      box-shadow: inset 0 0 4px rgba(0, 0, 0, 0.5);
    }

    .head-display-text {
      font-family: 'Courier New', monospace;
      font-size: clamp(0.5rem, 1.2vw, 0.7rem);
      font-weight: bold;
      color: #FF6B00;
      text-shadow: 0 0 4px #FF6B00;
      animation: led-blink 3s ease-in-out infinite;
      white-space: nowrap;
    }

    @keyframes led-blink {

      0%,
      90%,
      100% {
        opacity: 1;
      }

      95% {
        opacity: 0.7;
      }
    }

    /* Train Side Windows */
    .head-windows {
      position: absolute;
      top: 12%;
      right: 8%;
      width: 45%;
      height: 35%;
      display: flex;
      gap: 8%;
      padding-top: 25%;
    }

    .head-window {
      flex: 1;
      background: linear-gradient(180deg,
          #1a3a5c 0%,
          #2d5a7b 50%,
          #4a8ab0 100%);
      border-radius: 3px;
      position: relative;
      box-shadow: inset 0 0 0 2px rgba(0, 0, 0, 0.15);
    }

    /* Headlights */
    .head-lights {
      position: absolute;
      bottom: 30%;
      left: 4%;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .headlight {
      width: clamp(8px, 1.8vw, 12px);
      height: clamp(5px, 1vw, 7px);
      background: radial-gradient(ellipse, #FFFDE7 0%, #FFF9C4 50%, #FFD54F 100%);
      border-radius: 2px;
      box-shadow:
        0 0 10px #FFD54F,
        0 0 20px rgba(255, 213, 79, 0.5);
      animation: headlight-glow 2s ease-in-out infinite;
    }

    @keyframes headlight-glow {

      0%,
      100% {
        box-shadow: 0 0 10px #FFD54F, 0 0 20px rgba(255, 213, 79, 0.5);
      }

      50% {
        box-shadow: 0 0 15px #FFD54F, 0 0 30px rgba(255, 213, 79, 0.7);
      }
    }

    /* Train Wheels/Bogies */
    .train-bogies {
      position: absolute;
      bottom: -2px;
      left: 10%;
      right: 10%;
      height: 12%;
      display: flex;
      justify-content: space-between;
    }

    .bogie {
      width: 30%;
      height: 100%;
      background: linear-gradient(180deg, #2C2C2C 0%, #1a1a1a 100%);
      border-radius: 2px;
      position: relative;
    }

    .bogie::before,
    .bogie::after {
      content: '';
      position: absolute;
      width: 35%;
      height: 90%;
      background: radial-gradient(circle, #404040 0%, #2a2a2a 100%);
      border-radius: 50%;
      top: 5%;
      border: 2px solid #1a1a1a;
    }

    .bogie::before {
      left: 8%;
    }

    .bogie::after {
      right: 8%;
    }

    /* Interior Glow Effect */
    .interior-glow {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 20%;
      background: linear-gradient(180deg,
          rgba(255, 248, 225, 0.1) 0%,
          rgba(255, 248, 225, 0.05) 100%);
      pointer-events: none;
      animation: interior-pulse 4s ease-in-out infinite;
    }

    @keyframes interior-pulse {

      0%,
      100% {
        opacity: 0.8;
      }

      50% {
        opacity: 1;
      }
    }

    /* Train connector between cars */
    .train-connector {
      width: clamp(8px, 1.5vw, 12px);
      height: clamp(40px, 8vh, 55px);
      background: linear-gradient(90deg,
          #3a3a3a 0%,
          #4a4a4a 50%,
          #3a3a3a 100%);
      align-self: flex-end;
      margin-bottom: clamp(8px, 2vh, 12px);
      border-radius: 2px;
      position: relative;
    }

    .train-connector::before {
      content: '';
      position: absolute;
      top: 20%;
      left: 20%;
      right: 20%;
      bottom: 20%;
      background: repeating-linear-gradient(0deg,
          #2a2a2a 0px, #2a2a2a 3px,
          #4a4a4a 3px, #4a4a4a 6px);
      border-radius: 1px;
    }

    /* Door Opening Chime Indicator */
    .door-chime-indicator {
      position: absolute;
      top: clamp(8px, 2vh, 15px);
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 6px;
      opacity: 0;
      transition: opacity 0.3s ease;
      z-index: 20;
    }

    .platform-doors.doors-open~.door-chime-indicator,
    .doors-open .door-chime-indicator {
      opacity: 1;
    }

    .chime-dot {
      width: 8px;
      height: 8px;
      background: #00C853;
      border-radius: 50%;
      animation: chime-pulse 0.6s ease-out infinite;
    }

    .chime-dot:nth-child(2) {
      animation-delay: 0.15s;
    }

    .chime-dot:nth-child(3) {
      animation-delay: 0.3s;
    }

    @keyframes chime-pulse {

      0%,
      100% {
        transform: scale(1);
        opacity: 1;
      }

      50% {
        transform: scale(1.4);
        opacity: 0.7;
      }
    }

    /* Train Window Passengers (silhouettes) */
    .car-window-content {
      position: absolute;
      bottom: 10%;
      left: 10%;
      right: 10%;
      height: 60%;
      display: flex;
      justify-content: center;
      gap: 15%;
      opacity: 0.15;
    }

    .passenger-silhouette {
      width: 30%;
      height: 100%;
      background: linear-gradient(180deg, #1a1a1a 0%, transparent 100%);
      border-radius: 50% 50% 0 0;
    }

    /* Platform Welcome Message */
    .platform-message {
      position: absolute;
      bottom: clamp(52px, 12vh, 75px);
      left: 50%;
      transform: translateX(-50%);
      background: rgba(26, 26, 46, 0.9);
      padding: 4px 12px;
      border-radius: 4px;
      font-family: var(--font-display);
      font-size: clamp(0.6rem, 1.5vw, 0.75rem);
      color: #00C853;
      white-space: nowrap;
      z-index: 25;
      opacity: 0;
      animation: message-appear 0.5s ease-out 3s forwards;
    }

    @keyframes message-appear {
      0% {
        opacity: 0;
        transform: translateX(-50%) translateY(10px);
      }

      100% {
        opacity: 1;
        transform: translateX(-50%) translateY(0);
      }
    }

    /* Train Roof Detail */
    .train-roof {
      position: absolute;
      top: -4px;
      left: 5%;
      right: 5%;
      height: 4px;
      background: linear-gradient(90deg,
          transparent 0%,
          #C0C0C0 10%,
          #E0E0E0 50%,
          #C0C0C0 90%,
          transparent 100%);
      border-radius: 2px 2px 0 0;
    }

    /* Air Conditioning Units on roof */
    .train-ac-unit {
      position: absolute;
      top: -8px;
      width: 20%;
      height: 6px;
      background: linear-gradient(180deg, #A0A0A0 0%, #808080 100%);
      border-radius: 2px;
    }

    .train-ac-unit:first-of-type {
      left: 20%;
    }

    .train-ac-unit:last-of-type {
      right: 20%;
    }

    /* ===== WELCOME SCREEN ENHANCEMENTS ===== */

    /* Train Reflection on Platform Floor */
    .train-reflection {
      position: absolute;
      bottom: 0;
      left: 50%;
      transform: translateX(-50%) scaleY(-0.3) scaleX(0.95);
      display: flex;
      align-items: flex-start;
      z-index: 3;
      opacity: 0;
      filter: blur(2px);
      animation: reflection-appear 2s cubic-bezier(0.25, 0.46, 0.45, 0.94) 0.5s forwards;
      pointer-events: none;
    }

    @keyframes reflection-appear {
      0% {
        opacity: 0;
        transform: translateX(calc(-50% - 150%)) scaleY(-0.3) scaleX(0.95);
      }

      100% {
        opacity: 0.15;
        transform: translateX(-50%) scaleY(-0.3) scaleX(0.95);
      }
    }

    /* Ambient Floating Light Particles */
    .ambient-particles {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 40%;
      pointer-events: none;
      overflow: hidden;
      z-index: 3;
    }

    .particle {
      position: absolute;
      width: 4px;
      height: 4px;
      background: radial-gradient(circle, rgba(255, 255, 255, 0.8) 0%, transparent 70%);
      border-radius: 50%;
      animation: particle-float 8s ease-in-out infinite;
    }

    .particle:nth-child(1) {
      left: 10%;
      top: 20%;
      animation-delay: 0s;
      animation-duration: 7s;
    }

    .particle:nth-child(2) {
      left: 25%;
      top: 35%;
      animation-delay: 1s;
      animation-duration: 9s;
    }

    .particle:nth-child(3) {
      left: 40%;
      top: 15%;
      animation-delay: 2s;
      animation-duration: 6s;
    }

    .particle:nth-child(4) {
      left: 55%;
      top: 40%;
      animation-delay: 0.5s;
      animation-duration: 8s;
    }

    .particle:nth-child(5) {
      left: 70%;
      top: 25%;
      animation-delay: 1.5s;
      animation-duration: 7.5s;
    }

    .particle:nth-child(6) {
      left: 85%;
      top: 30%;
      animation-delay: 2.5s;
      animation-duration: 9.5s;
    }

    .particle:nth-child(7) {
      left: 15%;
      top: 45%;
      animation-delay: 3s;
      animation-duration: 6.5s;
    }

    .particle:nth-child(8) {
      left: 60%;
      top: 10%;
      animation-delay: 0.8s;
      animation-duration: 8.5s;
    }

    @keyframes particle-float {

      0%,
      100% {
        transform: translateY(0) translateX(0) scale(1);
        opacity: 0.3;
      }

      25% {
        transform: translateY(-15px) translateX(8px) scale(1.2);
        opacity: 0.6;
      }

      50% {
        transform: translateY(-5px) translateX(-5px) scale(0.8);
        opacity: 0.4;
      }

      75% {
        transform: translateY(-20px) translateX(3px) scale(1.1);
        opacity: 0.5;
      }
    }

    /* Platform Edge Warning Lights */
    .platform-warning-lights {
      position: absolute;
      bottom: clamp(45px, 10vh, 65px);
      left: 0;
      right: 0;
      height: 3px;
      display: flex;
      justify-content: space-evenly;
      z-index: 6;
      opacity: 0;
      animation: warning-activate 0.3s ease-out 2s forwards;
    }

    @keyframes warning-activate {
      to {
        opacity: 1;
      }
    }

    .warning-light {
      width: 12px;
      height: 3px;
      background: #FF5722;
      border-radius: 1px;
      animation: warning-blink 0.8s ease-in-out infinite;
      box-shadow: 0 0 8px #FF5722, 0 0 4px #FF5722;
    }

    .warning-light:nth-child(even) {
      animation-delay: 0.4s;
    }

    .platform-doors.doors-open~.platform-warning-lights {
      animation: warning-deactivate 0.5s ease-out forwards;
    }

    @keyframes warning-deactivate {
      to {
        opacity: 0;
      }
    }

    @keyframes warning-blink {

      0%,
      100% {
        opacity: 1;
      }

      50% {
        opacity: 0.3;
      }
    }

    /* Station Ceiling / Canopy */
    .station-ceiling {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: clamp(30px, 6vh, 50px);
      background: linear-gradient(180deg,
          rgba(40, 40, 50, 0.95) 0%,
          rgba(50, 50, 60, 0.9) 60%,
          rgba(60, 60, 70, 0.4) 90%,
          transparent 100%);
      z-index: 12;
      display: flex;
      justify-content: space-evenly;
      align-items: flex-start;
      padding-top: 8px;
    }

    .ceiling-light {
      width: clamp(40px, 8vw, 60px);
      height: clamp(8px, 1.5vh, 12px);
      background: linear-gradient(180deg,
          rgba(255, 248, 220, 0.9) 0%,
          rgba(255, 245, 200, 0.7) 50%,
          rgba(255, 240, 180, 0.3) 100%);
      border-radius: 2px;
      box-shadow:
        0 0 20px rgba(255, 248, 220, 0.5),
        0 10px 30px rgba(255, 248, 220, 0.2);
      animation: ceiling-light-flicker 4s ease-in-out infinite;
    }

    .ceiling-light:nth-child(2) {
      animation-delay: 1s;
    }

    .ceiling-light:nth-child(3) {
      animation-delay: 2s;
    }

    @keyframes ceiling-light-flicker {

      0%,
      100% {
        opacity: 0.9;
      }

      50% {
        opacity: 1;
      }

      52% {
        opacity: 0.85;
      }

      54% {
        opacity: 1;
      }
    }

    /* Subtle Light Beams from Ceiling */
    .light-beam {
      position: absolute;
      top: clamp(30px, 6vh, 50px);
      width: clamp(60px, 12vw, 100px);
      height: 100%;
      background: linear-gradient(180deg,
          rgba(255, 248, 220, 0.08) 0%,
          rgba(255, 248, 220, 0.02) 50%,
          transparent 100%);
      z-index: 2;
      pointer-events: none;
    }

    .light-beam:nth-child(1) {
      left: 15%;
    }

    .light-beam:nth-child(2) {
      left: 45%;
    }

    .light-beam:nth-child(3) {
      right: 15%;
    }

    /* Train Arrival Screen Shake */
    .mrt-train-scene.train-arriving {
      animation: subtle-shake 0.5s ease-out;
    }

    @keyframes subtle-shake {

      0%,
      100% {
        transform: translateX(0);
      }

      20% {
        transform: translateX(-2px);
      }

      40% {
        transform: translateX(2px);
      }

      60% {
        transform: translateX(-1px);
      }

      80% {
        transform: translateX(1px);
      }
    }

    /* Enhanced Window Silhouettes */
    .window-silhouette {
      position: absolute;
      bottom: 15%;
      width: 35%;
      height: 55%;
      background: linear-gradient(180deg,
          rgba(20, 30, 50, 0.4) 0%,
          rgba(20, 30, 50, 0.2) 60%,
          transparent 100%);
      border-radius: 40% 40% 0 0;
    }

    .window-silhouette.left {
      left: 15%;
    }

    .window-silhouette.right {
      right: 15%;
    }

    /* Food items visible through windows */
    .window-food-item {
      position: absolute;
      font-size: clamp(0.6rem, 1.2vw, 0.8rem);
      bottom: 25%;
      animation: window-food-bob 3s ease-in-out infinite;
      filter: drop-shadow(0 1px 2px rgba(0, 0, 0, 0.3));
    }

    .window-food-item:nth-child(1) {
      left: 30%;
      animation-delay: 0s;
    }

    .window-food-item:nth-child(2) {
      left: 50%;
      animation-delay: 0.5s;
    }

    .window-food-item:nth-child(3) {
      left: 70%;
      animation-delay: 1s;
    }

    @keyframes window-food-bob {

      0%,
      100% {
        transform: translateY(0);
      }

      50% {
        transform: translateY(-3px);
      }
    }

    /* Vignette Effect for Focus */
    .welcome-vignette {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: radial-gradient(ellipse at center,
          transparent 50%,
          rgba(0, 0, 0, 0.15) 100%);
      pointer-events: none;
      z-index: 11;
    }

    /* Platform Line Route Indicator */
    .route-indicator {
      position: absolute;
      top: clamp(35px, 7vh, 55px);
      right: clamp(10px, 2vw, 20px);
      display: flex;
      flex-direction: column;
      gap: 4px;
      z-index: 15;
      animation: title-appear 0.8s ease-out 1s backwards;
    }

    .route-line {
      display: flex;
      align-items: center;
      gap: 6px;
      font-family: var(--font-display);
      font-size: clamp(0.55rem, 1.2vw, 0.7rem);
      color: white;
      text-shadow: 0 1px 3px rgba(0, 0, 0, 0.5);
    }

    .route-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      box-shadow: 0 0 4px currentColor;
    }

    .route-dot.blue {
      background: var(--line-blue);
      color: var(--line-blue);
    }

    .route-dot.red {
      background: var(--line-red);
      color: var(--line-red);
    }

    .route-dot.green {
      background: var(--line-green);
      color: var(--line-green);
    }

    .route-dot.orange {
      background: var(--line-orange);
      color: var(--line-orange);
    }

    /* Door Opening Air Whoosh Effect */
    .door-whoosh {
      position: absolute;
      bottom: clamp(45px, 10vh, 65px);
      left: 50%;
      transform: translateX(-50%);
      width: 0;
      height: clamp(90px, 16vh, 130px);
      background: radial-gradient(ellipse at center,
          rgba(255, 255, 255, 0.3) 0%,
          transparent 70%);
      opacity: 0;
      z-index: 10;
      pointer-events: none;
    }

    .platform-doors.doors-open~.door-whoosh {
      animation: whoosh-effect 0.8s ease-out forwards;
    }

    @keyframes whoosh-effect {
      0% {
        width: 0;
        opacity: 0.8;
      }

      100% {
        width: 200px;
        opacity: 0;
      }
    }

    /* ===== BIG BUTTON ===== */
    /* Signature tactile button - feels like pressing a soft pillow */
    .big-btn {
      min-width: var(--touch-lg);
      min-height: clamp(60px, 10vh, 80px);
      padding: clamp(0.5rem, 1.5vh, 1rem) clamp(1.5rem, 3vh, 3rem);
      font-family: var(--font-display);
      font-size: clamp(1rem, 2.5vh, 1.25rem);
      font-weight: 600;
      letter-spacing: 0.02em;
      border: none;
      border-radius: var(--radius-xl);
      cursor: pointer;
      transition: all var(--anim-fast) var(--ease-out-soft);
      display: flex;
      align-items: center;
      justify-content: center;
      gap: var(--space-sm);
      position: relative;
      z-index: 1;
      /* Multi-layer shadow for depth */
      box-shadow:
        0 6px 0 rgba(0, 0, 0, 0.1),
        0 8px 20px rgba(0, 0, 0, 0.08),
        inset 0 -2px 0 rgba(0, 0, 0, 0.08),
        inset 0 1px 0 rgba(255, 255, 255, 0.3);
    }

    .big-btn::before {
      content: '';
      position: absolute;
      inset: 0;
      border-radius: inherit;
      background: linear-gradient(180deg, rgba(255, 255, 255, 0.2) 0%, transparent 50%);
      pointer-events: none;
    }

    .big-btn:hover {
      transform: translateY(-2px);
      box-shadow:
        0 8px 0 rgba(0, 0, 0, 0.08),
        0 12px 28px rgba(0, 0, 0, 0.12),
        inset 0 -2px 0 rgba(0, 0, 0, 0.08),
        inset 0 1px 0 rgba(255, 255, 255, 0.3);
    }

    .big-btn:active,
    .big-btn:focus {
      transform: translateY(3px);
      box-shadow:
        0 2px 0 rgba(0, 0, 0, 0.12),
        0 4px 12px rgba(0, 0, 0, 0.08),
        inset 0 2px 4px rgba(0, 0, 0, 0.1);
      outline: none;
    }

    /* Better touch feedback for iPad */
    @media (hover: none) {
      .big-btn:active {
        transform: translateY(4px) scale(0.98);
      }
    }

    .big-btn.primary {
      background:
        linear-gradient(135deg, var(--accent-coral) 0%, var(--accent-coral-soft) 100%);
      color: var(--text-inverse);
      box-shadow:
        0 6px 0 rgba(200, 100, 90, 0.35),
        0 8px 20px rgba(242, 139, 130, 0.25),
        inset 0 -2px 0 rgba(0, 0, 0, 0.1),
        inset 0 1px 0 rgba(255, 255, 255, 0.3);
    }

    .big-btn.primary:hover {
      background:
        linear-gradient(135deg, #F59B94 0%, #FABDB7 100%);
      box-shadow:
        0 8px 0 rgba(200, 100, 90, 0.3),
        var(--shadow-coral),
        inset 0 -2px 0 rgba(0, 0, 0, 0.08),
        inset 0 1px 0 rgba(255, 255, 255, 0.35);
    }

    .big-btn.secondary {
      background:
        linear-gradient(135deg, var(--mrt-blue) 0%, var(--mrt-blue-soft) 100%);
      color: var(--text-inverse);
      box-shadow:
        0 6px 0 rgba(50, 100, 140, 0.35),
        var(--shadow-blue),
        inset 0 -2px 0 rgba(0, 0, 0, 0.1),
        inset 0 1px 0 rgba(255, 255, 255, 0.25);
    }

    .big-btn.secondary:hover {
      background:
        linear-gradient(135deg, var(--mrt-blue-soft) 0%, #7BBDE5 100%);
    }

    /* Make Next button more prominent */
    #continueBtn {
      width: 100%;
      max-width: 260px;
      animation: gentlePulse 2.5s ease-in-out infinite;
      font-size: var(--text-xl);
      font-weight: 600;
      min-height: 56px;
      margin: 0 auto;
    }

    #continueBtn:disabled {
      cursor: not-allowed;
      opacity: 0.6;
      transform: none;
      animation: none;
      box-shadow:
        0 3px 0 rgba(50, 100, 140, 0.25),
        var(--shadow-sm);
    }

    @keyframes gentlePulse {

      0%,
      100% {
        transform: scale(1);
        box-shadow:
          0 6px 0 rgba(50, 100, 140, 0.35),
          var(--shadow-blue),
          inset 0 -2px 0 rgba(0, 0, 0, 0.1),
          inset 0 1px 0 rgba(255, 255, 255, 0.25);
      }

      50% {
        transform: scale(1.03);
        box-shadow:
          0 8px 0 rgba(50, 100, 140, 0.3),
          0 4px 20px rgba(74, 144, 194, 0.35),
          var(--shadow-glow),
          inset 0 -2px 0 rgba(0, 0, 0, 0.08),
          inset 0 1px 0 rgba(255, 255, 255, 0.3);
      }
    }

    #continueBtn:active {
      animation: none;
    }

    /* ===== TAIPEI MRT COLORS ===== */
    :root {
      --taipei-red: #E3002C;
      /* Red Line (Tamsui-Xinyi) */
      --taipei-blue: #0070BD;
      /* Blue Line (Bannan) */
      --taipei-green: #008659;
      /* Green Line (Songshan-Xindian) */
      --taipei-orange: #F8B61C;
      /* Orange Line (Zhonghe-Xinlu) */
      --taipei-brown: #C48C31;
      /* Brown Line (Wenhu) */
      --taipei-yellow: #FFDB00;
      /* Yellow Line (Circular) */
      --taipei-purple: #7B5AA6;
      /* Purple Line (Taoyuan Airport) */
    }

    /* ===== MRT MAP SCREEN ===== */
    .mrt-screen {
      background:
        radial-gradient(ellipse at 50% 100%, rgba(0, 112, 189, 0.05) 0%, transparent 50%),
        linear-gradient(180deg, #F8F9FA 0%, #E8EAF0 100%);
      padding: var(--space-lg);
    }

    .mrt-title {
      font-family: var(--font-display);
      font-size: var(--text-2xl);
      font-weight: 700;
      color: #2C3E50;
      text-align: center;
      margin-bottom: var(--space-md);
      display: flex;
      align-items: center;
      justify-content: center;
      gap: var(--space-sm);
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    /* ===== AUTHENTIC TAIPEI MRT NETWORK MAP ===== */
    /* SVG-based schematic transit map design */

    .mrt-map {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      position: relative;
      overflow: hidden;
      padding: clamp(0.5rem, 2vh, 1rem);
      -webkit-overflow-scrolling: touch;
      margin: 0 auto;
      width: 100%;
      /* Authentic transit map background - subtle grid pattern */
      background:
        linear-gradient(rgba(240, 245, 250, 0.5) 1px, transparent 1px),
        linear-gradient(90deg, rgba(240, 245, 250, 0.5) 1px, transparent 1px),
        radial-gradient(ellipse at 30% 40%, rgba(227, 0, 44, 0.03) 0%, transparent 40%),
        radial-gradient(ellipse at 70% 60%, rgba(0, 112, 189, 0.03) 0%, transparent 40%),
        #FAFCFE;
      background-size: 20px 20px, 20px 20px, 100% 100%, 100% 100%;
    }

    /* SVG Network Map Container */
    .mrt-network-svg {
      display: block;
      width: 100%;
      max-width: 540px;
      /* Sized to fit viewport while showing all stations */
      height: auto;
      aspect-ratio: 560 / 720;
      /* Match viewBox aspect ratio */
      filter: drop-shadow(0 4px 20px rgba(0, 0, 0, 0.08));
      overflow: visible;
      /* Prevent edge station labels from being clipped */
    }

    /* Scroll container - allows map panning on mobile */
    .mrt-map-scroll-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      width: 100%;
    }

    /* Transit Line Paths */
    .mrt-line-path {
      fill: none;
      stroke-width: 10;
      stroke-linecap: round;
      stroke-linejoin: round;
      transition: stroke-width 0.3s ease, filter 0.3s ease;
    }

    .mrt-line-path.line-red {
      stroke: var(--taipei-red);
    }

    .mrt-line-path.line-blue {
      stroke: var(--taipei-blue);
    }

    .mrt-line-path.line-green {
      stroke: var(--taipei-green);
    }

    .mrt-line-path.line-orange {
      stroke: var(--taipei-orange);
    }

    /* Station Markers */
    .mrt-station {
      cursor: pointer;
      pointer-events: auto;
      /* Ensure clicks work on stations */
      /* NO transform here - stations use transform: translate() for positioning */
    }

    /* Station Circle - Authentic MRT style */
    /* Hover effects applied HERE, not on parent group */
    .mrt-station-circle {
      fill: white;
      stroke-width: 4;
      transition: transform 0.25s cubic-bezier(0.34, 1.56, 0.64, 1), fill 0.2s ease, stroke 0.2s ease, stroke-width 0.2s ease, filter 0.2s ease;
      filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.15));
      transform-origin: center;
      transform-box: fill-box;
      pointer-events: auto;
      cursor: pointer;
    }

    /* Hover: scale the circle, not the group (preserves translate positioning) */
    .mrt-station:hover:not(.locked) .mrt-station-circle {
      transform: scale(1.25);
      filter: drop-shadow(0 4px 12px rgba(0, 0, 0, 0.25));
    }

    .mrt-station:active:not(.locked) .mrt-station-circle {
      transform: scale(1.1);
    }

    .mrt-station.line-red .mrt-station-circle {
      stroke: var(--taipei-red);
    }

    .mrt-station.line-blue .mrt-station-circle {
      stroke: var(--taipei-blue);
    }

    .mrt-station.line-green .mrt-station-circle {
      stroke: var(--taipei-green);
    }

    .mrt-station.line-orange .mrt-station-circle {
      stroke: var(--taipei-orange);
    }

    /* Station inner dot */
    .mrt-station-inner {
      fill: white;
      transition: all 0.3s ease;
    }

    .mrt-station.completed .mrt-station-circle {
      fill: currentColor;
    }

    .mrt-station.completed .mrt-station-inner {
      fill: white;
    }

    .mrt-station.completed.line-red .mrt-station-circle {
      fill: var(--taipei-red);
    }

    .mrt-station.completed.line-blue .mrt-station-circle {
      fill: var(--taipei-blue);
    }

    .mrt-station.completed.line-green .mrt-station-circle {
      fill: var(--taipei-green);
    }

    .mrt-station.completed.line-orange .mrt-station-circle {
      fill: var(--taipei-orange);
    }

    /* Locked stations */
    .mrt-station.locked {
      cursor: not-allowed;
      opacity: 0.45;
      filter: grayscale(60%);
    }

    .mrt-station.locked .mrt-station-circle {
      stroke: #B0BEC5;
      fill: #ECEFF1;
    }

    /* Central Hub - Transfer Station */
    .mrt-central-hub {
      cursor: default;
    }

    .mrt-hub-outer {
      fill: white;
      stroke: #37474F;
      stroke-width: 3;
      filter: drop-shadow(0 3px 8px rgba(0, 0, 0, 0.2));
    }

    .mrt-hub-ring {
      fill: none;
      stroke-width: 4;
      opacity: 0.9;
    }

    .mrt-hub-inner {
      fill: #37474F;
    }

    /* Station Labels */
    .mrt-station-label {
      font-family: var(--transit-font), 'Outfit', sans-serif;
      font-size: 11px;
      font-weight: 700;
      fill: #37474F;
      letter-spacing: 0.02em;
      pointer-events: auto;
      cursor: inherit;
      user-select: none;
      text-shadow:
        1px 1px 0 white,
        -1px -1px 0 white,
        1px -1px 0 white,
        -1px 1px 0 white,
        0 1px 0 white,
        0 -1px 0 white,
        1px 0 0 white,
        -1px 0 0 white;
      transition: font-size 0.3s ease;
    }

    .mrt-station:hover:not(.locked) .mrt-station-label {
      font-size: 12px;
      fill: #1A237E;
    }

    .mrt-station.locked .mrt-station-label {
      fill: #90A4AE;
    }

    .mrt-hub-label {
      font-family: var(--transit-font), 'Outfit', sans-serif;
      font-size: 9px;
      font-weight: 800;
      fill: #546E7A;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      text-shadow:
        1px 1px 0 white,
        -1px -1px 0 white,
        1px -1px 0 white,
        -1px 1px 0 white;
    }

    /* Food Emoji Badges - Cohesive circular design */
    .mrt-station-emoji {
      font-size: 18px;
      pointer-events: auto;
      cursor: inherit;
      user-select: none;
      filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.25));
      transition: transform 0.2s ease, filter 0.2s ease;
      transform-origin: center center;
      transform-box: fill-box;
      /* For SVG elements - scale from element center */
    }

    /* Subtle hover effect on emoji when hovering station - stays in place, just grows slightly */
    .mrt-station:hover:not(.locked) .mrt-station-emoji {
      transform: scale(1.12);
      filter: drop-shadow(0 3px 8px rgba(0, 0, 0, 0.35));
    }

    /* Line-specific emoji glow effects */
    .mrt-station.line-red:hover:not(.locked) .mrt-station-emoji {
      filter: drop-shadow(0 0 8px rgba(227, 0, 44, 0.5)) drop-shadow(0 2px 4px rgba(0, 0, 0, 0.2));
    }

    .mrt-station.line-blue:hover:not(.locked) .mrt-station-emoji {
      filter: drop-shadow(0 0 8px rgba(0, 112, 189, 0.5)) drop-shadow(0 2px 4px rgba(0, 0, 0, 0.2));
    }

    .mrt-station.line-green:hover:not(.locked) .mrt-station-emoji {
      filter: drop-shadow(0 0 8px rgba(0, 134, 89, 0.5)) drop-shadow(0 2px 4px rgba(0, 0, 0, 0.2));
    }

    .mrt-station.line-orange:hover:not(.locked) .mrt-station-emoji {
      filter: drop-shadow(0 0 8px rgba(248, 182, 28, 0.5)) drop-shadow(0 2px 4px rgba(0, 0, 0, 0.2));
    }

    /* Recommended station emoji has gentle pulse */
    .mrt-station.recommended .mrt-station-emoji {
      animation: emoji-pulse 2s ease-in-out infinite;
    }

    @keyframes emoji-pulse {

      0%,
      100% {
        transform: scale(1);
      }

      50% {
        transform: scale(1.1);
      }
    }

    /* Circular badge behind emoji icons */
    .mrt-emoji-badge {
      fill: white;
      stroke: none;
      filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.15));
      opacity: 0.95;
      transition: all 0.3s ease;
    }

    /* Line-specific badge colors on hover */
    .mrt-station:hover:not(.locked) .mrt-emoji-badge {
      transform-origin: center;
      filter: drop-shadow(0 3px 6px rgba(0, 0, 0, 0.2));
    }

    .mrt-station.line-red .mrt-emoji-badge {
      stroke: var(--taipei-red);
      stroke-width: 2;
    }

    .mrt-station.line-blue .mrt-emoji-badge {
      stroke: var(--taipei-blue);
      stroke-width: 2;
    }

    .mrt-station.line-green .mrt-emoji-badge {
      stroke: var(--taipei-green);
      stroke-width: 2;
    }

    .mrt-station.line-orange .mrt-emoji-badge {
      stroke: var(--taipei-orange);
      stroke-width: 2;
    }

    /* Completed stations have filled badges */
    .mrt-station.completed.line-red .mrt-emoji-badge {
      fill: rgba(227, 0, 44, 0.1);
    }

    .mrt-station.completed.line-blue .mrt-emoji-badge {
      fill: rgba(0, 112, 189, 0.1);
    }

    .mrt-station.completed.line-green .mrt-emoji-badge {
      fill: rgba(0, 134, 89, 0.1);
    }

    .mrt-station.completed.line-orange .mrt-emoji-badge {
      fill: rgba(248, 182, 28, 0.15);
    }

    /* Pulse animation for current/recommended station */
    .mrt-station.recommended .mrt-station-circle {
      animation: station-pulse 2s ease-in-out infinite;
    }

    @keyframes station-pulse {

      0%,
      100% {
        filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.15));
        stroke-width: 4;
      }

      50% {
        filter: drop-shadow(0 0 12px currentColor) drop-shadow(0 2px 8px rgba(0, 0, 0, 0.2));
        stroke-width: 5;
      }
    }

    /* ===== MAP TRAIN - Shows user's current position ===== */
    /* The train is positioned via SVG `transform` (translate) on the outer group.
       Animations must NOT touch the outer group's transform, or it will snap to (0,0). */
    .mrt-map-train {
      pointer-events: none;
      filter: drop-shadow(0 4px 12px rgba(0, 0, 0, 0.26));
      transition: transform 0.1s ease-out;
    }

    .mrt-map-train-inner {
      transform-origin: center;
      transform-box: fill-box;
    }

    .mrt-map-train-body {
      fill: #F7FAFC;
      stroke: rgba(0, 0, 0, 0.18);
      stroke-width: 0.9;
    }

    .mrt-map-train-roof {
      fill: #E2E8F0;
      stroke: none;
    }

    .mrt-map-train-stripe {
      fill: #CBD5E0;
      stroke: none;
    }

    .mrt-map-train-side {
      fill: rgba(0, 0, 0, 0.08);
      stroke: none;
    }

    .mrt-map-train-door-line {
      stroke: rgba(0, 0, 0, 0.18);
      stroke-width: 0.8;
      stroke-linecap: round;
      opacity: 0.65;
    }

    .mrt-map-train-hvac {
      fill: rgba(255, 255, 255, 0.55);
      stroke: rgba(0, 0, 0, 0.12);
      stroke-width: 0.6;
    }

    .mrt-map-train-front-window {
      fill: #90CDF4;
      stroke: rgba(0, 0, 0, 0.14);
      stroke-width: 0.45;
    }

    .mrt-map-train-bumper {
      stroke: rgba(0, 0, 0, 0.22);
      stroke-width: 1.1;
      stroke-linecap: round;
      opacity: 0.6;
    }

    .mrt-map-train-door {
      fill: rgba(255, 255, 255, 0.22);
      stroke: rgba(0, 0, 0, 0.12);
      stroke-width: 0.5;
    }

    .mrt-map-train-window {
      fill: #90CDF4;
      stroke: rgba(0, 0, 0, 0.14);
      stroke-width: 0.45;
    }

    .mrt-map-train-front {
      fill: #63B3ED;
      stroke: rgba(0, 0, 0, 0.14);
      stroke-width: 0.45;
    }

    .mrt-map-train-headlight {
      fill: #FFE082;
      filter: drop-shadow(0 0 4px rgba(255, 224, 130, 0.9));
    }

    .mrt-map-train-taillight {
      fill: #EF4444;
      filter: drop-shadow(0 0 3px rgba(239, 68, 68, 0.75));
    }

    .mrt-map-train-undercarriage {
      fill: rgba(0, 0, 0, 0.18);
      stroke: none;
    }

    .mrt-map-train-nose-highlight {
      fill: rgba(255, 255, 255, 0.16);
      stroke: none;
    }

    .mrt-map-train-coupler {
      fill: rgba(0, 0, 0, 0.22);
      stroke: none;
    }

    .mrt-map-train-wheel {
      fill: #263238;
      stroke: rgba(255, 255, 255, 0.14);
      stroke-width: 0.6;
    }

    .mrt-map-train-wheel-hub {
      fill: rgba(255, 255, 255, 0.22);
      stroke: none;
    }

    /* Train idle bounce animation (inner only; keep translate position intact) */
    .mrt-map-train.idle .mrt-map-train-inner {
      animation: train-idle-bounce 2s ease-in-out infinite;
    }

    @keyframes train-idle-bounce {

      0%,
      100% {
        transform: translateY(0);
      }

      50% {
        transform: translateY(-2px);
      }
    }

    /* Train hub arrival 360 spin animation */
    .mrt-map-train.hub-spin .mrt-map-train-inner {
      transform-origin: 0 0;
      animation: train-hub-spin 1.5s cubic-bezier(0.34, 1.56, 0.64, 1) forwards !important;
    }

    @keyframes train-hub-spin {
      0% {
        transform: rotate(0deg) scale(1);
        filter: drop-shadow(0 0 8px gold);
      }
      25% {
        transform: rotate(90deg) scale(1.2);
        filter: drop-shadow(0 0 15px gold);
      }
      50% {
        transform: rotate(180deg) scale(1.25);
        filter: drop-shadow(0 0 20px gold);
      }
      75% {
        transform: rotate(270deg) scale(1.2);
        filter: drop-shadow(0 0 15px gold);
      }
      100% {
        transform: rotate(360deg) scale(1);
        filter: drop-shadow(0 0 0px transparent);
      }
    }

    /* Train moving animation: subtle squash/stretch with speed effect */
    .mrt-map-train.moving .mrt-map-train-inner {
      animation: train-speed-squash 0.6s cubic-bezier(0.4, 0, 0.2, 1) infinite;
    }

    @keyframes train-speed-squash {

      0%,
      100% {
        transform: scaleX(1) scaleY(1);
        filter: brightness(1);
      }

      50% {
        transform: scaleX(1.08) scaleY(0.96);
        filter: brightness(1.1);
      }
    }

    /* Motion blur trail effect while moving */
    .mrt-map-train.moving {
      filter: drop-shadow(0 3px 8px rgba(0, 0, 0, 0.4)) drop-shadow(-4px 0 6px currentColor) drop-shadow(-8px 0 4px currentColor);
    }

    /* Anticipation animation before departure */
    .mrt-map-train.anticipating .mrt-map-train-inner {
      animation: train-anticipate 0.35s cubic-bezier(0.6, -0.28, 0.74, 0.05) forwards;
    }

    @keyframes train-anticipate {
      0% {
        transform: translateX(0) scaleX(1);
      }

      100% {
        transform: translateX(-4px) scaleX(0.92);
      }
    }

    /* Train arrival bounce with satisfying settle (inner only; keep translate position intact) */
    .mrt-map-train.arriving .mrt-map-train-inner {
      animation: train-arrive-bounce 0.8s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
    }

    @keyframes train-arrive-bounce {
      0% {
        transform: scale(1) translateY(0);
      }

      30% {
        transform: scale(1.2) translateY(-4px);
      }

      50% {
        transform: scale(0.95) translateY(1px);
      }

      70% {
        transform: scale(1.05) translateY(-1px);
      }

      100% {
        transform: scale(1) translateY(0);
      }
    }

    /* Sparkle particles during movement - created via pseudo-element */
    .mrt-map-train.moving::before {
      content: '';
      position: absolute;
      width: 3px;
      height: 3px;
      background: currentColor;
      border-radius: 50%;
      left: -15px;
      top: 50%;
      box-shadow:
        -8px -3px 2px currentColor,
        -12px 2px 2px currentColor,
        -6px 4px 1px currentColor,
        -18px -1px 2px currentColor;
      opacity: 0;
      animation: sparkle-trail 0.5s ease-out infinite;
      pointer-events: none;
    }

    @keyframes sparkle-trail {
      0% {
        opacity: 0.8;
        transform: translateX(0) scale(1);
      }

      100% {
        opacity: 0;
        transform: translateX(-20px) scale(0.3);
      }
    }

    /* Ghost trail effect - subtle afterimage */
    .mrt-map-train.moving::after {
      content: '';
      position: absolute;
      width: 24px;
      height: 12px;
      border-radius: 4px;
      background: currentColor;
      opacity: 0;
      left: -12px;
      top: -6px;
      animation: ghost-trail 0.4s ease-out infinite;
      pointer-events: none;
    }

    @keyframes ghost-trail {
      0% {
        opacity: 0.3;
        transform: translateX(0) scaleX(1);
      }

      100% {
        opacity: 0;
        transform: translateX(-12px) scaleX(0.7);
      }
    }

    /* Line-specific train colors (stripe only; body stays neutral for a top-down look) */
    .mrt-map-train.line-red .mrt-map-train-stripe {
      fill: var(--taipei-red);
    }

    .mrt-map-train.line-blue .mrt-map-train-stripe {
      fill: var(--taipei-blue);
    }

    .mrt-map-train.line-green .mrt-map-train-stripe {
      fill: var(--taipei-green);
    }

    .mrt-map-train.line-orange .mrt-map-train-stripe {
      fill: var(--taipei-orange);
    }

    /* Map Legend */
    .mrt-map-legend {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 8px 16px;
      padding: 12px 16px;
      background: rgba(255, 255, 255, 0.95);
      border-radius: var(--radius-lg);
      box-shadow: 0 2px 12px rgba(0, 0, 0, 0.08);
      margin-top: 12px;
      max-width: 450px;
      backdrop-filter: blur(8px);
      border: 1px solid rgba(255, 255, 255, 0.8);
    }

    .mrt-legend-item {
      display: flex;
      align-items: center;
      gap: 6px;
      font-family: var(--transit-font), 'Outfit', sans-serif;
      font-size: 11px;
      font-weight: 700;
      color: #455A64;
      letter-spacing: 0.02em;
    }

    .mrt-legend-line {
      width: 24px;
      height: 6px;
      border-radius: 3px;
    }

    .mrt-legend-line.line-red {
      background: var(--taipei-red);
    }

    .mrt-legend-line.line-blue {
      background: var(--taipei-blue);
    }

    .mrt-legend-line.line-green {
      background: var(--taipei-green);
    }

    .mrt-legend-line.line-orange {
      background: var(--taipei-orange);
    }

    .mrt-legend-level {
      font-size: 9px;
      padding: 2px 6px;
      border-radius: 4px;
      color: white;
      font-weight: 800;
    }

    .mrt-legend-level.level-1 {
      background: var(--taipei-red);
    }

    .mrt-legend-level.level-2 {
      background: var(--taipei-blue);
    }

    .mrt-legend-level.level-3 {
      background: var(--taipei-green);
    }

    .mrt-legend-level.level-4 {
      background: var(--taipei-orange);
    }

    /* Station info tooltip on hover */
    .mrt-station-tooltip {
      position: absolute;
      background: white;
      padding: 10px 14px;
      border-radius: 10px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
      pointer-events: none;
      opacity: 0;
      transform: translateY(5px);
      transition: all 0.2s ease;
      z-index: 100;
      font-family: var(--font-display);
      min-width: 120px;
      text-align: center;
    }

    .mrt-station-tooltip.visible {
      opacity: 1;
      transform: translateY(0);
    }

    .mrt-station-tooltip-name {
      font-size: 14px;
      font-weight: 700;
      color: #1A237E;
      margin-bottom: 4px;
    }

    .mrt-station-tooltip-status {
      font-size: 11px;
      font-weight: 600;
      padding: 3px 8px;
      border-radius: 4px;
      display: inline-block;
    }

    .mrt-station-tooltip-status.go {
      background: #E8F5E9;
      color: #2E7D32;
    }

    .mrt-station-tooltip-status.locked {
      background: #ECEFF1;
      color: #78909C;
    }

    .mrt-station-tooltip-status.done {
      background: #E3F2FD;
      color: #1565C0;
    }

    /* Hide old MRT line div */
    .mrt-line {
      display: none;
    }

    /* Touch feedback for SVG stations - scale the circle only */
    @media (hover: none) {
      .mrt-station:active:not(.locked) .mrt-station-circle {
        transform: scale(1.3);
        filter: drop-shadow(0 0 10px currentColor) drop-shadow(0 2px 8px rgba(0, 0, 0, 0.3));
      }
    }

    /* Label background stroke for readability */
    .mrt-station-label {
      paint-order: stroke fill;
      stroke: white;
      stroke-width: 3px;
      stroke-linejoin: round;
    }

    /* Recommended station glow - pulsing ring effect using box-shadow on a wrapper */
    .mrt-station.recommended .mrt-station-circle {
      animation: station-pulse-glow 2s ease-in-out infinite;
    }

    @keyframes station-pulse-glow {

      0%,
      100% {
        filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.15));
        stroke-width: 4;
      }

      50% {
        filter: drop-shadow(0 0 16px currentColor) drop-shadow(0 2px 8px rgba(0, 0, 0, 0.2));
        stroke-width: 5;
      }
    }

    /* Override hover when pulsing to pause animation */
    .mrt-station.recommended:hover:not(.locked) .mrt-station-circle {
      animation: none;
    }

    /* Central hub entrance animation - uses opacity for fade-in */
    .mrt-central-hub {
      opacity: 0;
      animation: hub-appear 0.6s ease-out 0.2s forwards;
    }

    .mrt-hub-outer {
      transform-origin: center;
      transform: scale(0);
      animation: hub-scale 0.5s cubic-bezier(0.34, 1.56, 0.64, 1) 0.3s forwards;
    }

    @keyframes hub-appear {
      0% {
        opacity: 0;
      }

      100% {
        opacity: 1;
      }
    }

    @keyframes hub-scale {
      0% {
        transform: scale(0);
      }

      70% {
        transform: scale(1.1);
      }

      100% {
        transform: scale(1);
      }
    }

    /* Line path drawing animation */
    .mrt-line-path {
      stroke-dasharray: 1000;
      stroke-dashoffset: 1000;
      animation: draw-line 1.5s ease-out forwards;
    }

    .mrt-line-path.line-red {
      animation-delay: 0s;
    }

    .mrt-line-path.line-blue {
      animation-delay: 0.2s;
    }

    .mrt-line-path.line-green {
      animation-delay: 0.4s;
    }

    .mrt-line-path.line-orange {
      animation-delay: 0.6s;
    }

    @keyframes draw-line {
      to {
        stroke-dashoffset: 0;
      }
    }

    /* Station appear animation - uses opacity and inner circle scale */
    .mrt-stations-layer .mrt-station {
      opacity: 0;
      animation: station-fade-in 0.5s ease-out forwards;
    }

    .mrt-stations-layer .mrt-station:nth-child(1) {
      animation-delay: 0.4s;
    }

    .mrt-stations-layer .mrt-station:nth-child(2) {
      animation-delay: 0.5s;
    }

    .mrt-stations-layer .mrt-station:nth-child(3) {
      animation-delay: 0.6s;
    }

    .mrt-stations-layer .mrt-station:nth-child(4) {
      animation-delay: 0.7s;
    }

    .mrt-stations-layer .mrt-station:nth-child(5) {
      animation-delay: 0.8s;
    }

    .mrt-stations-layer .mrt-station:nth-child(6) {
      animation-delay: 0.9s;
    }

    .mrt-stations-layer .mrt-station:nth-child(7) {
      animation-delay: 1.0s;
    }

    .mrt-stations-layer .mrt-station:nth-child(8) {
      animation-delay: 1.1s;
    }

    @keyframes station-fade-in {
      0% {
        opacity: 0;
      }

      100% {
        opacity: 1;
      }
    }

    /* Station circle pop-in effect - uses opacity only to avoid hover conflicts */
    .mrt-stations-layer .mrt-station .mrt-station-circle {
      opacity: 0;
      animation: circle-fade-pop 0.5s ease-out forwards;
    }

    .mrt-stations-layer .mrt-station:nth-child(1) .mrt-station-circle {
      animation-delay: 0.4s;
    }

    .mrt-stations-layer .mrt-station:nth-child(2) .mrt-station-circle {
      animation-delay: 0.5s;
    }

    .mrt-stations-layer .mrt-station:nth-child(3) .mrt-station-circle {
      animation-delay: 0.6s;
    }

    .mrt-stations-layer .mrt-station:nth-child(4) .mrt-station-circle {
      animation-delay: 0.7s;
    }

    .mrt-stations-layer .mrt-station:nth-child(5) .mrt-station-circle {
      animation-delay: 0.8s;
    }

    .mrt-stations-layer .mrt-station:nth-child(6) .mrt-station-circle {
      animation-delay: 0.9s;
    }

    .mrt-stations-layer .mrt-station:nth-child(7) .mrt-station-circle {
      animation-delay: 1.0s;
    }

    .mrt-stations-layer .mrt-station:nth-child(8) .mrt-station-circle {
      animation-delay: 1.1s;
    }

    @keyframes circle-fade-pop {
      0% {
        opacity: 0;
      }

      100% {
        opacity: 1;
      }
    }

    /* Legend fade in */
    .mrt-map-legend {
      opacity: 0;
      animation: legend-appear 0.5s ease-out 1.3s forwards;
    }

    @keyframes legend-appear {
      0% {
        opacity: 0;
        transform: translateY(10px);
      }

      100% {
        opacity: 1;
        transform: translateY(0);
      }
    }

    /* Reduced motion - respect user preference */
    @media (prefers-reduced-motion: reduce) {

      .mrt-line-path,
      .mrt-central-hub,
      .mrt-hub-outer,
      .mrt-stations-layer .mrt-station,
      .mrt-station-circle,
      .mrt-map-legend {
        animation: none !important;
        opacity: 1 !important;
        transform: none !important;
        stroke-dasharray: none !important;
        stroke-dashoffset: 0 !important;
      }

      .mrt-station.recommended .mrt-station-circle {
        animation: none !important;
        filter: drop-shadow(0 0 8px currentColor) drop-shadow(0 2px 4px rgba(0, 0, 0, 0.15)) !important;
      }
    }

    /* Calm mode - simplified animations */
    body.calm-mode .mrt-station.recommended .mrt-station-circle {
      animation: none !important;
    }

    body.calm-mode .mrt-line-path,
    body.calm-mode .mrt-hub-outer,
    body.calm-mode .mrt-station-circle {
      animation-duration: 0.01ms !important;
    }

    /* ===== STATION SELECTION & TRANSITION LOCKOUT ===== */
    /* When a station is being selected, prevent clicking others */

    /* Map in "boarding" state - transitioning to a station */
    .mrt-map.boarding .mrt-station:not(.selected) {
      opacity: 0.4;
      pointer-events: none;
      cursor: not-allowed;
      filter: grayscale(30%);
      transition: opacity 0.4s ease, filter 0.4s ease;
    }

    .mrt-map.boarding .mrt-station:not(.selected) .mrt-station-circle {
      animation: none !important;
    }

    /* Selected station gets a glowing highlight */
    .mrt-station.selected .mrt-station-circle {
      animation: station-selected-glow 0.6s ease-out forwards !important;
      stroke-width: 5 !important;
    }

    @keyframes station-selected-glow {
      0% {
        transform: scale(1);
        filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.15));
      }

      30% {
        transform: scale(1.35);
        filter: drop-shadow(0 0 20px currentColor) drop-shadow(0 0 40px currentColor);
      }

      100% {
        transform: scale(1.2);
        filter: drop-shadow(0 0 16px currentColor) drop-shadow(0 4px 8px rgba(0, 0, 0, 0.2));
      }
    }

    /* Ripple effect ring that expands from selected station */
    .mrt-selection-ripple {
      fill: none;
      stroke: currentColor;
      stroke-width: 3;
      opacity: 0;
      transform-origin: center;
      pointer-events: none;
    }

    .mrt-station.selected .mrt-selection-ripple {
      animation: ripple-expand 0.8s ease-out forwards;
    }

    @keyframes ripple-expand {
      0% {
        r: 18;
        opacity: 0.8;
        stroke-width: 4;
      }

      100% {
        r: 50;
        opacity: 0;
        stroke-width: 1;
      }
    }

    /* Second ripple with delay for layered effect */
    .mrt-station.selected .mrt-selection-ripple:nth-of-type(2) {
      animation: ripple-expand 0.8s ease-out 0.15s forwards;
    }

    /* "Next Stop" badge that appears above selected station */
    .mrt-next-stop-badge {
      position: absolute;
      top: -45px;
      left: 50%;
      transform: translateX(-50%) scale(0);
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      color: white;
      padding: 6px 14px;
      border-radius: 20px;
      font-family: var(--font-display);
      font-size: 11px;
      font-weight: 700;
      white-space: nowrap;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      z-index: 100;
      opacity: 0;
      pointer-events: none;
    }

    .mrt-station.selected .mrt-next-stop-badge {
      animation: badge-appear 0.5s cubic-bezier(0.34, 1.56, 0.64, 1) 0.2s forwards;
    }

    @keyframes badge-appear {
      0% {
        transform: translateX(-50%) scale(0) translateY(10px);
        opacity: 0;
      }

      100% {
        transform: translateX(-50%) scale(1) translateY(0);
        opacity: 1;
      }
    }

    /* Train departing animation - add motion blur effect */
    .mrt-map-train.departing .train-body {
      animation: train-depart-shake 0.3s ease-in-out;
    }

    @keyframes train-depart-shake {

      0%,
      100% {
        transform: translateX(0);
      }

      25% {
        transform: translateX(-2px);
      }

      75% {
        transform: translateX(2px);
      }
    }

    /* Speed lines behind departing train */
    .mrt-map-train.departing::after {
      content: '';
      position: absolute;
      left: -20px;
      top: 50%;
      transform: translateY(-50%);
      width: 15px;
      height: 2px;
      background: linear-gradient(90deg, transparent, currentColor);
      opacity: 0.6;
      animation: speed-lines 0.2s ease-out infinite;
    }

    @keyframes speed-lines {
      0% {
        opacity: 0.6;
        width: 15px;
      }

      100% {
        opacity: 0;
        width: 25px;
        left: -30px;
      }
    }

    /* Emoji bounce when station is selected */
    .mrt-station.selected .mrt-station-emoji {
      animation: emoji-celebrate 0.6s cubic-bezier(0.34, 1.56, 0.64, 1) forwards !important;
    }

    @keyframes emoji-celebrate {
      0% {
        transform: scale(1);
      }

      30% {
        transform: scale(1.4) rotate(-5deg);
      }

      60% {
        transform: scale(1.2) rotate(5deg);
      }

      100% {
        transform: scale(1.25) rotate(0deg);
      }
    }

    /* ===== METRO STATION BUTTONS ===== */
    .station-btn {
      position: relative;
      z-index: 2;
      min-height: 80px;
      padding: 18px 20px 18px 90px;
      background: white;
      border: none;
      border-radius: 20px;
      cursor: pointer;
      transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
      display: flex;
      flex-direction: row;
      align-items: center;
      justify-content: flex-start;
      gap: 14px;
      text-align: left;
      box-shadow:
        0 4px 12px rgba(0, 0, 0, 0.08),
        0 2px 4px rgba(0, 0, 0, 0.04);
      margin: 0 0 24px 0;
      width: 100%;
      max-width: 100%;
    }

    /* Station circle indicator on the line */
    .station-btn::before {
      content: '';
      position: absolute;
      left: 28px;
      top: 50%;
      transform: translateY(-50%);
      width: 28px;
      height: 28px;
      background: white;
      border: 6px solid var(--taipei-blue);
      border-radius: 50%;
      z-index: 4;
      box-shadow:
        0 0 0 4px white,
        0 3px 8px rgba(0, 0, 0, 0.12);
      transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
    }

    /* Line connectors - vertical connection line */
    .station-btn::after {
      content: '';
      position: absolute;
      left: 38px;
      top: 100%;
      width: 8px;
      height: 24px;
      background: var(--taipei-blue);
      z-index: 1;
      border-radius: 4px;
    }

    /* Hide line after last station */
    .station-btn:last-of-type::after {
      display: none;
    }

    .station-btn:hover:not(:disabled) {
      transform: translateX(8px);
      box-shadow:
        0 8px 24px rgba(0, 0, 0, 0.12),
        0 4px 8px rgba(0, 0, 0, 0.08);
    }

    .station-btn:hover:not(:disabled)::before {
      transform: translateY(-50%) scale(1.2);
      box-shadow:
        0 0 0 6px white,
        0 4px 12px rgba(0, 0, 0, 0.18);
    }

    /* Line-specific hover effects - colorful borders */
    #station-fruit:hover:not(:disabled),
    #station-bakery:hover:not(:disabled) {
      border-left: 5px solid var(--taipei-red);
    }

    #station-drink:hover:not(:disabled) {
      border-left: 5px solid var(--taipei-red);
      background: linear-gradient(135deg, rgba(227, 0, 44, 0.03) 0%, white 100%);
    }

    #station-pizza:hover:not(:disabled) {
      border-left: 5px solid var(--taipei-blue);
    }

    #station-icecream:hover:not(:disabled) {
      border-left: 5px solid var(--taipei-blue);
      background: linear-gradient(135deg, rgba(0, 112, 189, 0.03) 0%, white 100%);
    }

    #station-fishshop:hover:not(:disabled) {
      border-left: 5px solid var(--taipei-green);
      background: linear-gradient(135deg, rgba(0, 134, 89, 0.03) 0%, white 100%);
    }

    #station-cheese:hover:not(:disabled),
    #station-noodle:hover:not(:disabled) {
      border-left: 5px solid var(--taipei-orange);
    }

    .station-btn:active:not(:disabled),
    .station-btn:focus:not(:disabled) {
      transform: scale(0.98) translateX(4px);
      outline: none;
    }

    /* Touch feedback for iPad */
    @media (hover: none) {
      .station-btn:active:not(:disabled) {
        transform: scale(0.98) translateX(4px);
      }
    }

    .station-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      filter: grayscale(70%);
      transform: none !important;
    }

    .station-btn:disabled::before {
      border-color: #CFD8DC;
      background: #ECEFF1;
    }

    .station-btn.completed {
      background: linear-gradient(135deg, #F1F8E9 0%, #DCEDC8 100%);
      border-left: 4px solid #7CB342;
    }

    .station-btn.completed::before {
      background: #66BB6A;
      border-color: #7CB342;
      box-shadow:
        0 0 0 4px white,
        0 3px 8px rgba(76, 175, 80, 0.3);
    }

    /* ===== STATION POSITIONING & LINE COLORS ===== */
    /* Mobile-first vertical list - all stations flow in order */

    /* RED LINE (Level 1) */
    #station-fruit::before,
    #station-fruit::after {
      border-color: var(--taipei-red);
      background: var(--taipei-red);
    }

    #station-drink::before,
    #station-drink::after {
      border-color: var(--taipei-red);
      background: var(--taipei-red);
    }

    #station-bakery::before,
    #station-bakery::after {
      border-color: var(--taipei-red);
      background: var(--taipei-red);
    }

    /* BLUE LINE (Level 2) */
    #station-pizza::before,
    #station-pizza::after {
      border-color: var(--taipei-blue);
      background: var(--taipei-blue);
    }

    #station-icecream::before,
    #station-icecream::after {
      border-color: var(--taipei-blue);
      background: var(--taipei-blue);
    }

    /* GREEN LINE (Level 3) */
    #station-fishshop::before,
    #station-fishshop::after {
      border-color: var(--taipei-green);
      background: var(--taipei-green);
    }

    /* ORANGE LINE (Level 4) */
    #station-cheese::before,
    #station-cheese::after {
      border-color: var(--taipei-orange);
      background: var(--taipei-orange);
    }

    #station-noodle::before,
    #station-noodle::after {
      border-color: var(--taipei-orange);
      background: var(--taipei-orange);
    }

    /* Transfer stations - double ring effect */
    #station-drink::before {
      box-shadow:
        0 0 0 4px white,
        0 0 0 8px var(--taipei-blue),
        0 3px 12px rgba(0, 0, 0, 0.15);
    }

    #station-icecream::before {
      box-shadow:
        0 0 0 4px white,
        0 0 0 8px var(--taipei-green),
        0 3px 12px rgba(0, 0, 0, 0.15);
    }

    #station-fishshop::before {
      box-shadow:
        0 0 0 4px white,
        0 0 0 8px var(--taipei-orange),
        0 3px 12px rgba(0, 0, 0, 0.15);
    }

    .station-icon {
      position: absolute;
      left: 90px;
      top: 50%;
      transform: translateY(-50%);
      font-size: 2.5rem;
      width: 56px;
      height: 56px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: linear-gradient(135deg, #FAFBFC 0%, #F5F7FA 100%);
      border-radius: 50%;
      box-shadow: 0 3px 10px rgba(0, 0, 0, 0.08);
      flex-shrink: 0;
      z-index: 3;
    }

    /* SVG icon for station buttons */
    .station-icon-img {
      position: absolute;
      left: 90px;
      top: 50%;
      transform: translateY(-50%);
      width: 56px;
      height: 56px;
      object-fit: contain;
      background: linear-gradient(135deg, #FAFBFC 0%, #F5F7FA 100%);
      border-radius: 50%;
      box-shadow: 0 3px 10px rgba(0, 0, 0, 0.08);
      flex-shrink: 0;
      padding: 8px;
      z-index: 3;
    }

    .station-info {
      flex: 1;
      text-align: left;
      min-width: 0;
      margin-right: 12px;
    }

    .station-name {
      font-family: var(--font-display);
      font-size: 1.1rem;
      font-weight: 700;
      color: #1A237E;
      margin-bottom: 6px;
      line-height: 1.3;
    }

    .station-desc {
      font-size: 0.85rem;
      color: #546E7A;
      display: flex;
      align-items: center;
      gap: 6px;
      flex-wrap: wrap;
      line-height: 1.4;
    }

    .station-status {
      font-size: 0.85rem;
      font-weight: 700;
      padding: 8px 16px;
      border-radius: 999px;
      background: #1A237E;
      color: white;
      box-shadow: 0 2px 8px rgba(26, 35, 126, 0.25);
      flex-shrink: 0;
      letter-spacing: 0.02em;
    }

    .station-level {
      font-size: 0.7rem;
      padding: 4px 10px;
      border-radius: 999px;
      font-weight: 800;
      letter-spacing: 0.04em;
      text-transform: uppercase;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    .station-level.level-1 {
      background: var(--taipei-red);
      color: white;
    }

    .station-level.level-2 {
      background: var(--taipei-blue);
      color: white;
    }

    .station-level.level-3 {
      background: var(--taipei-green);
      color: white;
    }

    .station-level.level-4 {
      background: var(--taipei-orange);
      color: white;
    }

    .level-indicator {
      display: flex;
      justify-content: center;
      gap: var(--space-sm);
      padding: var(--space-md) var(--space-sm);
      flex-wrap: wrap;
      background: rgba(255, 255, 255, 0.7);
      border-radius: var(--radius-lg);
      margin-top: auto;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
    }

    .level-badge {
      font-size: var(--text-xs);
      padding: 6px 12px;
      border-radius: var(--radius-full);
      font-weight: 700;
      letter-spacing: 0.03em;
      color: white;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.15);
    }

    .level-badge.level-1 {
      background: var(--taipei-red);
      box-shadow: 0 2px 8px rgba(227, 0, 44, 0.35);
    }

    .level-badge.level-2 {
      background: var(--taipei-blue);
      box-shadow: 0 2px 8px rgba(0, 112, 189, 0.35);
    }

    .level-badge.level-3 {
      background: var(--taipei-green);
      box-shadow: 0 2px 8px rgba(0, 134, 89, 0.35);
    }

    .level-badge.level-4 {
      background: var(--taipei-orange);
      box-shadow: 0 2px 8px rgba(248, 182, 28, 0.35);
    }

    /* ===== MRT MINI LINE PROGRESS BAR ===== */
    /* Shows current position with animated train on MRT line */
    .mrt-progress-bar {
      position: relative;
      background: linear-gradient(180deg, rgba(255, 255, 255, 0.98) 0%, rgba(248, 250, 252, 0.95) 100%);
      padding: clamp(10px, 1.5vh, 14px) clamp(14px, 2vw, 20px);
      border-radius: 16px;
      box-shadow:
        0 2px 8px rgba(0, 0, 0, 0.06),
        0 1px 2px rgba(0, 0, 0, 0.04),
        inset 0 1px 0 rgba(255, 255, 255, 0.9);
      margin: var(--space-sm) auto var(--space-md);
      max-width: 92%;
      backdrop-filter: blur(12px);
      border: 1px solid rgba(255, 255, 255, 0.8);
    }

    /* Line color classes */
    .mrt-progress-bar.line-red {
      --line-color: var(--taipei-red);
      --line-glow: rgba(227, 0, 44, 0.3);
    }

    .mrt-progress-bar.line-blue {
      --line-color: var(--taipei-blue);
      --line-glow: rgba(0, 112, 189, 0.3);
    }

    .mrt-progress-bar.line-green {
      --line-color: var(--taipei-green);
      --line-glow: rgba(0, 134, 89, 0.3);
    }

    .mrt-progress-bar.line-orange {
      --line-color: var(--taipei-orange);
      --line-glow: rgba(248, 182, 28, 0.3);
    }

    .mrt-progress-bar.line-brown {
      --line-color: var(--taipei-brown);
      --line-glow: rgba(166, 124, 82, 0.3);
    }

    .mrt-progress-bar.line-yellow {
      --line-color: var(--taipei-yellow);
      --line-glow: rgba(255, 212, 0, 0.3);
    }

    /* Track container */
    .mrt-progress-track {
      display: flex;
      align-items: center;
      justify-content: space-between;
      position: relative;
      padding: 12px 6px 8px;
      min-height: 36px;
    }

    /* Base track line (unfilled portion) */
    .mrt-progress-track::before {
      content: '';
      position: absolute;
      left: 12px;
      right: 12px;
      top: 50%;
      height: 6px;
      background: linear-gradient(180deg, #E0E0E0 0%, #EEEEEE 100%);
      transform: translateY(-50%);
      z-index: 0;
      border-radius: 3px;
      box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.08);
    }

    /* Filled portion of track */
    .mrt-progress-fill {
      position: absolute;
      left: 12px;
      top: 50%;
      height: 6px;
      background: linear-gradient(90deg, var(--line-color) 0%, var(--line-color) 100%);
      transform: translateY(-50%);
      transition: width 0.6s cubic-bezier(0.34, 1.56, 0.64, 1);
      z-index: 1;
      border-radius: 3px;
      box-shadow:
        0 2px 6px var(--line-glow),
        0 0 12px var(--line-glow);
    }

    /* Station markers */
    .mrt-progress-stop {
      position: relative;
      z-index: 3;
      width: 14px;
      height: 14px;
      border-radius: 50%;
      background: white;
      border: 3px solid #D0D0D0;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0;
      transition: all 0.35s cubic-bezier(0.34, 1.56, 0.64, 1);
      flex-shrink: 0;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    }

    .mrt-progress-stop.completed {
      border-color: var(--line-color);
      background: var(--line-color);
      box-shadow:
        0 2px 6px var(--line-glow),
        inset 0 1px 0 rgba(255, 255, 255, 0.3);
    }

    /* Checkmark for completed stations */
    .mrt-progress-stop.completed::before {
      content: 'âœ“';
      font-size: 8px;
      color: white;
      font-weight: 700;
    }

    .mrt-progress-stop.current {
      border-color: var(--line-color);
      background: white;
      width: 18px;
      height: 18px;
      border-width: 3px;
      box-shadow:
        0 0 0 3px rgba(255, 255, 255, 0.95),
        0 0 12px var(--line-glow),
        0 2px 6px rgba(0, 0, 0, 0.12);
    }

    /* Animated train icon above current station */
    .mrt-progress-train {
      position: absolute;
      top: -26px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 10;
      animation: train-bounce 1.2s ease-in-out infinite;
      filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.2));
    }

    .mrt-progress-train svg {
      width: 28px;
      height: 28px;
      display: block;
    }

    @keyframes train-bounce {

      0%,
      100% {
        transform: translateX(-50%) translateY(0);
      }

      50% {
        transform: translateX(-50%) translateY(-3px);
      }
    }

    /* Train arrival animation when moving to new stop */
    @keyframes train-arrive {
      0% {
        transform: translateX(-50%) translateX(-20px) scale(0.8);
        opacity: 0.5;
      }

      60% {
        transform: translateX(-50%) translateX(3px) scale(1.05);
        opacity: 1;
      }

      80% {
        transform: translateX(-50%) translateX(-2px) scale(1);
      }

      100% {
        transform: translateX(-50%) translateX(0) scale(1);
      }
    }

    .mrt-progress-train.arriving {
      animation: train-arrive 0.6s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
    }

    /* Station labels (shown on hover/current) */
    .mrt-progress-stop::after {
      content: attr(data-label);
      position: absolute;
      top: calc(100% + 4px);
      left: 50%;
      transform: translateX(-50%);
      font-size: 0.55rem;
      font-weight: 600;
      color: #78909C;
      white-space: nowrap;
      opacity: 0;
      transition: opacity 0.2s ease;
      font-family: var(--transit-font);
      letter-spacing: 0.02em;
    }

    .mrt-progress-stop.current::after {
      opacity: 1;
      color: var(--line-color);
      font-weight: 700;
    }

    /* Line info bar */
    .mrt-progress-info {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      margin-top: 6px;
      padding-top: 8px;
      border-top: 1px solid rgba(0, 0, 0, 0.05);
      font-family: var(--transit-font);
      font-size: clamp(0.65rem, 1.5vh, 0.75rem);
      font-weight: 600;
      color: #607D8B;
      letter-spacing: 0.03em;
    }

    .mrt-progress-line-badge {
      display: inline-flex;
      align-items: center;
      gap: 5px;
      background: var(--line-color);
      color: white;
      padding: 3px 8px;
      border-radius: 10px;
      font-size: 0.6rem;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .mrt-progress-line-badge::before {
      content: '';
      width: 6px;
      height: 6px;
      background: white;
      border-radius: 50%;
      opacity: 0.9;
    }

    .mrt-progress-station-name {
      font-size: clamp(0.7rem, 1.6vh, 0.85rem);
      font-weight: 700;
      color: #37474F;
    }

    /* ===== MOBILE VIEW: Mini MRT Line ===== */
    .mrt-progress-mobile {
      display: flex;
      flex-direction: column;
      gap: 8px;
      align-items: center;
    }

    /* Mobile mini track */
    .mrt-progress-mini-track {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0;
      position: relative;
      width: 100%;
      padding: 16px 8px 12px;
    }

    /* Mobile track line */
    .mrt-progress-mini-line {
      display: flex;
      align-items: center;
      gap: 0;
      position: relative;
    }

    .mrt-progress-mini-segment {
      width: clamp(16px, 6vw, 28px);
      height: 5px;
      background: #E0E0E0;
      transition: background 0.4s ease;
    }

    .mrt-progress-mini-segment.filled {
      background: var(--line-color);
      box-shadow: 0 2px 6px var(--line-glow);
    }

    .mrt-progress-mini-stop {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: white;
      border: 2px solid #D0D0D0;
      flex-shrink: 0;
      transition: all 0.35s cubic-bezier(0.34, 1.56, 0.64, 1);
      position: relative;
    }

    .mrt-progress-mini-stop.completed {
      border-color: var(--line-color);
      background: var(--line-color);
    }

    .mrt-progress-mini-stop.current {
      width: 14px;
      height: 14px;
      border-color: var(--line-color);
      background: white;
      box-shadow:
        0 0 0 2px rgba(255, 255, 255, 0.95),
        0 0 10px var(--line-glow);
    }

    /* Mobile train */
    .mrt-progress-mini-train {
      position: absolute;
      top: -2px;
      left: 50%;
      transform: translateX(-50%);
      animation: train-bounce 1.2s ease-in-out infinite;
      z-index: 10;
      filter: drop-shadow(0 2px 3px rgba(0, 0, 0, 0.15));
    }

    .mrt-progress-mini-train svg {
      width: 22px;
      height: 22px;
    }

    /* Mobile info */
    .mrt-progress-mobile-info {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      font-family: var(--transit-font);
      font-size: 0.7rem;
      color: #607D8B;
    }

    .mrt-progress-mobile-badge {
      background: var(--line-color);
      color: white;
      padding: 2px 6px;
      border-radius: 8px;
      font-size: 0.6rem;
      font-weight: 700;
    }

    .mrt-progress-mobile-station {
      font-weight: 600;
      color: #37474F;
    }

    .mrt-progress-mobile-count {
      color: #90A4AE;
      font-size: 0.65rem;
    }

    /* Desktop: Full Stop View (hidden on mobile) */
    .mrt-progress-desktop {
      display: none;
    }

    /* Tablet and Desktop: Show full view */
    @media (min-width: 640px) {
      .mrt-progress-mobile {
        display: none;
      }

      .mrt-progress-desktop {
        display: block;
      }
    }

    /* ===== METRO MAP RESPONSIVE DESIGN ===== */
    /* Mobile-first design - already optimized for mobile! */

    @media (max-width: 480px) {
      .mrt-map {
        padding: 1.25rem 0.875rem;
      }

      .station-btn {
        min-height: 70px;
        padding: 14px 16px 14px 80px;
        margin-bottom: 20px;
        border-radius: 16px;
      }

      .station-btn::before {
        left: 24px;
        width: 24px;
        height: 24px;
        border-width: 5px;
      }

      .station-btn::after {
        left: 33px;
        width: 6px;
        height: 20px;
      }

      .station-icon,
      .station-icon-img {
        left: 74px;
        width: 48px;
        height: 48px;
        font-size: 2rem;
      }

      .station-name {
        font-size: 1rem;
        margin-bottom: 4px;
      }

      .station-desc {
        font-size: 0.8rem;
        gap: 5px;
      }

      .station-status {
        font-size: 0.8rem;
        padding: 6px 14px;
      }

      .station-level {
        font-size: 0.65rem;
        padding: 3px 8px;
      }

      /* Transfer station double rings for smaller screens */
      #station-drink::before {
        box-shadow:
          0 0 0 3px white,
          0 0 0 6px var(--taipei-blue),
          0 2px 8px rgba(0, 0, 0, 0.12);
      }

      #station-icecream::before {
        box-shadow:
          0 0 0 3px white,
          0 0 0 6px var(--taipei-green),
          0 2px 8px rgba(0, 0, 0, 0.12);
      }

      #station-fishshop::before {
        box-shadow:
          0 0 0 3px white,
          0 0 0 6px var(--taipei-orange),
          0 2px 8px rgba(0, 0, 0, 0.12);
      }

      /* Welcome Screen Mobile Adjustments */
      .mrt-train-scene {
        height: clamp(140px, 25vh, 180px);
      }

	      .station-sign {
	        padding: clamp(0.4rem, 1.2vh, 0.7rem) clamp(0.8rem, 2vw, 1.2rem);
	      }

	      .mrt-train-scene .mrt-train {
	        /* Slightly longer travel on small screens to guarantee no edge flashes. */
	        --welcome-train-travel: calc(110vw + 100%);
	      }

      .train-head {
        width: clamp(80px, 20vw, 110px);
        height: clamp(55px, 12vh, 75px);
      }

      .train-car-mrt {
        width: clamp(70px, 18vw, 100px);
        height: clamp(55px, 12vh, 75px);
      }

      .door-frame {
        width: clamp(50px, 12vw, 70px);
      }

      .platform-doors {
        height: clamp(70px, 13vh, 95px);
      }

      .door-pillar {
        width: clamp(10px, 2.5vw, 15px);
        height: clamp(70px, 13vh, 95px);
      }
    }

    /* Larger screens - more spacious layout */
    @media (min-width: 768px) {
      .mrt-map {
        padding: 2.5rem 2rem;
        overflow: hidden;
      }

      /* Desktop: scroll container doesn't need special sizing */
      .mrt-map-scroll-container {
        min-width: unset;
        min-height: unset;
        padding: 0;
      }

      /* Desktop/iPad: slightly larger map */
      .mrt-network-svg {
        max-width: 600px;
      }

      /* Desktop: hide pan hint */
      .mrt-pan-hint {
        display: none;
      }

      .station-btn {
        min-height: 90px;
        padding: 22px 24px 22px 100px;
        margin-bottom: 28px;
        max-width: 600px;
      }

      .station-btn::before {
        left: 30px;
        width: 32px;
        height: 32px;
        border-width: 7px;
      }

      .station-btn::after {
        left: 41px;
        width: 10px;
        height: 28px;
      }

      .station-icon,
      .station-icon-img {
        left: 94px;
        width: 64px;
        height: 64px;
        font-size: 3rem;
      }

      .station-name {
        font-size: 1.25rem;
        margin-bottom: 8px;
      }

      .station-desc {
        font-size: 0.9rem;
        gap: 8px;
      }

      .station-status {
        font-size: 0.9rem;
        padding: 10px 18px;
      }

      .station-level {
        font-size: 0.75rem;
        padding: 5px 12px;
      }
    }

    /* Scrollable MRT map - scrolling already handled above */

    /* ===== MAGICAL TRAIN WINDOW EXPERIENCE ===== */
    @import url('https://fonts.googleapis.com/css2?family=VT323&display=swap');

    .mrt-ride-screen {
      background: #1a1a2e;
      overflow: hidden;
      position: absolute;
      inset: 0;
      display: block;
    }

    /* === TRAIN WINDOW FRAME === */
    .train-window-frame {
      position: absolute;
      inset: 0;
      pointer-events: none;
      z-index: 100;
    }

    /* Rounded window corners with thick wooden frame */
    .train-window-frame::before {
      content: '';
      position: absolute;
      inset: 0;
      border: clamp(16px, 4vw, 28px) solid;
      border-image: linear-gradient(180deg,
          #8B7355 0%,
          #6B5344 20%,
          #4A3728 50%,
          #6B5344 80%,
          #8B7355 100%) 1;
      border-radius: 24px;
      box-shadow:
        inset 0 0 30px rgba(0, 0, 0, 0.5),
        inset 0 0 60px rgba(0, 0, 0, 0.3),
        0 0 20px rgba(0, 0, 0, 0.8);
    }

    /* Glass reflection effect */
    .train-window-frame::after {
      content: none;
    }

    /* Corner rivets on the window frame */
    .window-rivet {
      position: absolute;
      width: 12px;
      height: 12px;
      background: radial-gradient(circle at 30% 30%, #C0C0C0, #606060);
      border-radius: 50%;
      box-shadow: inset 0 -2px 4px rgba(0, 0, 0, 0.5);
    }

    .window-rivet.top-left {
      top: 6px;
      left: 6px;
    }

    .window-rivet.top-right {
      top: 6px;
      right: 6px;
    }

    .window-rivet.bottom-left {
      bottom: 6px;
      left: 6px;
    }

    .window-rivet.bottom-right {
      bottom: 6px;
      right: 6px;
    }

    /* === SCENERY CONTAINER === */
    .scenery-container {
      position: absolute;
      inset: clamp(16px, 4vw, 28px);
      overflow: hidden;
      border-radius: 12px;
      background: linear-gradient(180deg, #87CEEB 0%, #E0F6FF 100%);
      background-size: cover;
      background-position: center;
      background-repeat: repeat-x;
    }

    /* === TAIPEI SCENERY BACKGROUNDS === */
    /* Each station shows a different iconic Taipei scene - AI generated cityscapes */

    /* Fruit Stand - Taipei 101 Skyline at Golden Hour */
    .theme-fruit .scenery-container {
      background-image: url('assets/train_scenes/taipei_101_day.jpeg');
    }

    /* Drink Bar - Riverside Park */
    .theme-drink .scenery-container {
      background-image: url('assets/train_scenes/taipei_riverside.png');
    }

    /* Bakery - Traditional Temple */
    .theme-bakery .scenery-container {
      background-image: url('assets/train_scenes/taipei_temple.jpeg');
    }

    /* Pizza - Night Market Scene */
    .theme-pizza .scenery-container {
      background-image: url('assets/train_scenes/taipei_night_market.png');
    }

    /* Ice Cream - Mountain Backdrop (Yangmingshan) */
    .theme-icecream .scenery-container {
      background-image: url('assets/train_scenes/taipei_mountain.jpeg');
    }

    /* Fish Shop - Modern MRT Elevated Tracks */
    .theme-fishshop .scenery-container {
      background-image: url('assets/train_scenes/taipei_mrt_elevated.png');
    }

    /* Cheese Shop - Tamsui Harbor */
    .theme-cheese .scenery-container {
      background-image: url('assets/train_scenes/taipei_harbor.png');
    }

    /* Noodle House - Urban Park */
    .theme-noodle .scenery-container {
      background-image: url('assets/train_scenes/taipei_park.png');
    }

    /* === NEW STATIONS (7 additional) === */

    /* Red Bean Bread - Traditional Bakery District */
    .theme-redbean .scenery-container {
      background-image: url('assets/train_scenes/taipei_redbean_bakery.jpeg');
    }

    /* Bubble Tea - Modern Boba Street */
    .theme-bubbletea .scenery-container {
      background-image: url('assets/train_scenes/taipei_bubble_tea.jpeg');
    }

    /* Burger Joint - Urban Street Food */
    .theme-burger .scenery-container {
      background-image: url('assets/train_scenes/taipei_burger.jpeg');
    }

    /* Sushi Bar - Japanese-influenced District */
    .theme-sushi .scenery-container {
      background-image: url('assets/train_scenes/taipei_sushi.jpeg');
    }

    /* Chicken Hut - Night Market Food Stall */
    .theme-chicken .scenery-container {
      background-image: url('assets/train_scenes/taipei_chicken.png');
    }

    /* Smoothie Stand - Tropical Fruit Market */
    .theme-smoothie .scenery-container {
      background-image: url('assets/train_scenes/taipei_smoothie.jpeg');
    }

    /* Tea House - Traditional Mountain Tea House */
    .theme-teahouse .scenery-container {
      background-image: url('assets/train_scenes/taipei_teahouse.png');
    }

    /* Hide ALL old parallax layers when using Taipei background images (all 15 themes) */
    .theme-fruit .sky-layer,
    .theme-drink .sky-layer,
    .theme-bakery .sky-layer,
    .theme-redbean .sky-layer,
    .theme-pizza .sky-layer,
    .theme-bubbletea .sky-layer,
    .theme-burger .sky-layer,
    .theme-icecream .sky-layer,
    .theme-fishshop .sky-layer,
    .theme-sushi .sky-layer,
    .theme-cheese .sky-layer,
    .theme-chicken .sky-layer,
    .theme-noodle .sky-layer,
    .theme-smoothie .sky-layer,
    .theme-teahouse .sky-layer,
    .theme-fruit .mountains-layer,
    .theme-drink .mountains-layer,
    .theme-bakery .mountains-layer,
    .theme-redbean .mountains-layer,
    .theme-pizza .mountains-layer,
    .theme-bubbletea .mountains-layer,
    .theme-burger .mountains-layer,
    .theme-icecream .mountains-layer,
    .theme-fishshop .mountains-layer,
    .theme-sushi .mountains-layer,
    .theme-cheese .mountains-layer,
    .theme-chicken .mountains-layer,
    .theme-noodle .mountains-layer,
    .theme-smoothie .mountains-layer,
    .theme-teahouse .mountains-layer,
    .theme-fruit .hills-layer,
    .theme-drink .hills-layer,
    .theme-bakery .hills-layer,
    .theme-redbean .hills-layer,
    .theme-pizza .hills-layer,
    .theme-bubbletea .hills-layer,
    .theme-burger .hills-layer,
    .theme-icecream .hills-layer,
    .theme-fishshop .hills-layer,
    .theme-sushi .hills-layer,
    .theme-cheese .hills-layer,
    .theme-chicken .hills-layer,
    .theme-noodle .hills-layer,
    .theme-smoothie .hills-layer,
    .theme-teahouse .hills-layer,
    .theme-fruit .trees-layer,
    .theme-drink .trees-layer,
    .theme-bakery .trees-layer,
    .theme-redbean .trees-layer,
    .theme-pizza .trees-layer,
    .theme-bubbletea .trees-layer,
    .theme-burger .trees-layer,
    .theme-icecream .trees-layer,
    .theme-fishshop .trees-layer,
    .theme-sushi .trees-layer,
    .theme-cheese .trees-layer,
    .theme-chicken .trees-layer,
    .theme-noodle .trees-layer,
    .theme-smoothie .trees-layer,
    .theme-teahouse .trees-layer,
    .theme-fruit .ground-layer,
    .theme-drink .ground-layer,
    .theme-bakery .ground-layer,
    .theme-redbean .ground-layer,
    .theme-pizza .ground-layer,
    .theme-bubbletea .ground-layer,
    .theme-burger .ground-layer,
    .theme-icecream .ground-layer,
    .theme-fishshop .ground-layer,
    .theme-sushi .ground-layer,
    .theme-cheese .ground-layer,
    .theme-chicken .ground-layer,
    .theme-noodle .ground-layer,
    .theme-smoothie .ground-layer,
    .theme-teahouse .ground-layer,
    .theme-fruit .celestial-body,
    .theme-drink .celestial-body,
    .theme-bakery .celestial-body,
    .theme-redbean .celestial-body,
    .theme-pizza .celestial-body,
    .theme-bubbletea .celestial-body,
    .theme-burger .celestial-body,
    .theme-icecream .celestial-body,
    .theme-fishshop .celestial-body,
    .theme-sushi .celestial-body,
    .theme-cheese .celestial-body,
    .theme-chicken .celestial-body,
    .theme-noodle .celestial-body,
    .theme-smoothie .celestial-body,
    .theme-teahouse .celestial-body,
    .theme-fruit .cloud,
    .theme-drink .cloud,
    .theme-bakery .cloud,
    .theme-redbean .cloud,
    .theme-pizza .cloud,
    .theme-bubbletea .cloud,
    .theme-burger .cloud,
    .theme-icecream .cloud,
    .theme-fishshop .cloud,
    .theme-sushi .cloud,
    .theme-cheese .cloud,
    .theme-chicken .cloud,
    .theme-noodle .cloud,
    .theme-smoothie .cloud,
    .theme-teahouse .cloud {
      display: none !important;
      visibility: hidden !important;
    }

    /* === SKY LAYER (furthest back) === */
    .sky-layer {
      position: absolute;
      inset: 0;
      background: linear-gradient(180deg,
          #87CEEB 0%,
          #87CEEB 40%,
          #B0E0E6 60%,
          #E0F6FF 80%,
          #F0F8FF 100%);
      transition: background 1s ease;
    }

    /* Sun/Moon */
    .celestial-body {
      position: absolute;
      top: 10%;
      right: 15%;
      width: clamp(40px, 8vw, 60px);
      height: clamp(40px, 8vw, 60px);
      border-radius: 50%;
      background: radial-gradient(circle at 30% 30%, #FFF8DC, #FFD700);
      box-shadow:
        0 0 40px rgba(255, 215, 0, 0.6),
        0 0 80px rgba(255, 215, 0, 0.3);
      animation: sun-glow 4s ease-in-out infinite;
    }

    @keyframes sun-glow {

      0%,
      100% {
        transform: scale(1);
        opacity: 0.9;
      }

      50% {
        transform: scale(1.05);
        opacity: 1;
      }
    }

    /* === DISTANT MOUNTAINS (parallax layer 1 - slowest) === */
    .mountains-layer {
      position: absolute;
      bottom: 35%;
      left: 0;
      width: 400%;
      height: 30%;
      animation: parallax-distant 10s linear infinite;
    }

    .mountain {
      position: absolute;
      bottom: 0;
      width: 0;
      height: 0;
      border-style: solid;
    }

    .mountain-1 {
      left: 5%;
      border-width: 0 60px 100px 60px;
      border-color: transparent transparent #7B8B6F transparent;
    }

    .mountain-2 {
      left: 15%;
      border-width: 0 80px 140px 80px;
      border-color: transparent transparent #6B7B5F transparent;
    }

    .mountain-3 {
      left: 30%;
      border-width: 0 50px 80px 50px;
      border-color: transparent transparent #8B9B7F transparent;
    }

    .mountain-4 {
      left: 40%;
      border-width: 0 90px 160px 90px;
      border-color: transparent transparent #5B6B4F transparent;
    }

    .mountain-5 {
      left: 55%;
      border-width: 0 70px 120px 70px;
      border-color: transparent transparent #7B8B6F transparent;
    }

    .mountain-6 {
      left: 70%;
      border-width: 0 55px 90px 55px;
      border-color: transparent transparent #6B7B5F transparent;
    }

    .mountain-7 {
      left: 85%;
      border-width: 0 85px 150px 85px;
      border-color: transparent transparent #5B6B4F transparent;
    }

    /* Snow caps */
    .mountain::before {
      content: '';
      position: absolute;
      top: -100%;
      left: 50%;
      transform: translateX(-50%);
      border-style: solid;
      border-width: 0 20px 35px 20px;
      border-color: transparent transparent rgba(255, 255, 255, 0.8) transparent;
    }

    @keyframes parallax-distant {
      0% {
        transform: translateX(0);
      }

      100% {
        transform: translateX(-25%);
      }
    }

    /* === ROLLING HILLS (parallax layer 2) === */
    .hills-layer {
      position: absolute;
      bottom: 22%;
      left: 0;
      width: 300%;
      height: 25%;
      animation: parallax-mid 7s linear infinite;
    }

    .hill {
      position: absolute;
      bottom: 0;
      border-radius: 50% 50% 0 0;
    }

    .hill-1 {
      left: 0%;
      width: 180px;
      height: 80px;
      background: linear-gradient(180deg, #7CB342 0%, #558B2F 100%);
    }

    .hill-2 {
      left: 12%;
      width: 220px;
      height: 100px;
      background: linear-gradient(180deg, #8BC34A 0%, #689F38 100%);
    }

    .hill-3 {
      left: 28%;
      width: 160px;
      height: 70px;
      background: linear-gradient(180deg, #9CCC65 0%, #7CB342 100%);
    }

    .hill-4 {
      left: 42%;
      width: 200px;
      height: 90px;
      background: linear-gradient(180deg, #7CB342 0%, #558B2F 100%);
    }

    .hill-5 {
      left: 58%;
      width: 180px;
      height: 75px;
      background: linear-gradient(180deg, #8BC34A 0%, #689F38 100%);
    }

    .hill-6 {
      left: 72%;
      width: 240px;
      height: 110px;
      background: linear-gradient(180deg, #7CB342 0%, #558B2F 100%);
    }

    .hill-7 {
      left: 88%;
      width: 170px;
      height: 85px;
      background: linear-gradient(180deg, #9CCC65 0%, #7CB342 100%);
    }

    @keyframes parallax-mid {
      0% {
        transform: translateX(0);
      }

      100% {
        transform: translateX(-33.33%);
      }
    }

    /* === TREES AND OBJECTS (parallax layer 3 - fastest) === */
    .trees-layer {
      position: absolute;
      bottom: 12%;
      left: 0;
      width: 200%;
      height: 25%;
      display: flex;
      animation: parallax-near 3.5s linear infinite;
      will-change: transform;
      transform: translate3d(0, 0, 0);
    }

    .trees-strip {
      position: relative;
      flex: 0 0 50%;
      height: 100%;
    }

    .tree {
      position: absolute;
      bottom: 0;
    }

    /* Tree trunk */
    .tree::before {
      content: '';
      position: absolute;
      bottom: 0;
      left: 50%;
      transform: translateX(-50%);
      width: 12px;
      height: 30px;
      background: linear-gradient(90deg, #5D4037, #8D6E63, #5D4037);
      border-radius: 2px;
    }

    /* Tree foliage */
    .tree::after {
      content: '';
      position: absolute;
      bottom: 25px;
      left: 50%;
      transform: translateX(-50%);
      width: 0;
      height: 0;
      border-style: solid;
      border-width: 0 25px 50px 25px;
      border-color: transparent transparent #2E7D32 transparent;
      filter: drop-shadow(0 4px 2px rgba(0, 0, 0, 0.2));
    }

    .tree-1 {
      left: 3%;
    }

    .tree-2 {
      left: 8%;
      transform: scale(0.8);
    }

    .tree-3 {
      left: 15%;
      transform: scale(1.1);
    }

    .tree-4 {
      left: 22%;
      transform: scale(0.9);
    }

    .tree-5 {
      left: 28%;
    }

    .tree-6 {
      left: 35%;
      transform: scale(0.85);
    }

    .tree-7 {
      left: 42%;
      transform: scale(1.05);
    }

    .tree-8 {
      left: 50%;
      transform: scale(0.95);
    }

    .tree-9 {
      left: 58%;
    }

    .tree-10 {
      left: 65%;
      transform: scale(0.8);
    }

    .tree-11 {
      left: 73%;
      transform: scale(1.1);
    }

    .tree-12 {
      left: 80%;
      transform: scale(0.9);
    }

    .tree-13 {
      left: 88%;
    }

    .tree-14 {
      left: 95%;
      transform: scale(0.85);
    }

    @keyframes parallax-near {
      0% {
        transform: translate3d(0, 0, 0);
      }

      100% {
        transform: translate3d(-50%, 0, 0);
      }
    }

    /* === GROUND/GRASS LAYER === */
    .ground-layer {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 15%;
      background: linear-gradient(180deg,
          #558B2F 0%,
          #33691E 40%,
          #2E5016 100%);
    }

    /* Grass texture */
    .ground-layer::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 8px;
      background: repeating-linear-gradient(90deg,
          #7CB342 0px, #7CB342 3px,
          #8BC34A 3px, #8BC34A 6px,
          #689F38 6px, #689F38 9px);
    }

    /* === TRAIN TRACKS === */
    .train-track {
      position: absolute;
      bottom: 8%;
      left: 0;
      width: 400%;
      height: 20px;
      background: linear-gradient(180deg,
          #4A3728 0%,
          #6B5344 50%,
          #4A3728 100%);
      animation: track-scroll 0.55s linear infinite;
    }

    /* Rails */
    .train-track::before,
    .train-track::after {
      content: '';
      position: absolute;
      left: 0;
      width: 100%;
      height: 4px;
      background: linear-gradient(90deg,
          #C0C0C0 0%, #E8E8E8 50%, #C0C0C0 100%);
    }

    .train-track::before {
      top: 2px;
    }

    .train-track::after {
      bottom: 2px;
    }

    /* Railroad ties */
	    .track-ties {
	      position: absolute;
	      bottom: 8%;
	      left: 0;
      width: 400%;
      height: 20px;
      background: repeating-linear-gradient(90deg,
          transparent 0px,
          transparent 20px,
          #3E2723 20px,
          #3E2723 28px);
	      animation: track-scroll 0.55s linear infinite;
	    }

	    /* Return ride: reverse the ground motion to match the train direction. */
	    .mrt-ride-screen.returning .track-ties {
	      animation-direction: reverse;
	    }

    @keyframes track-scroll {
      0% {
        transform: translateX(0);
      }

      100% {
        transform: translateX(-28px);
      }
    }

    /* === TAIWAN MRT TRAIN (RIDE SCENE) === */
	    .mrt-ride-screen #mrtTrain {
	      --stripe-color: var(--line-red);
	      position: absolute;
	      bottom: 10%;
	      /* Positioned closer to track (track is at bottom: 8%) */
	      left: 0;
      display: flex;
      align-items: flex-end;
      z-index: 50;
      /* Above scenery, below window frame */
      /* Train glides along the track (left to right) */
      animation: mrt-glide 7.5s linear infinite;
      will-change: transform;
    }

    @keyframes mrt-glide {
      0% {
        transform: translateX(-85%);
      }

      100% {
        transform: translateX(120vw);
      }
    }

    /* Subtle vertical sway for realism - like real train motion */
    .mrt-car {
      position: relative;
      animation: mrt-sway 0.8s ease-in-out infinite;
    }

    @keyframes mrt-sway {

      0%,
      100% {
        transform: translateY(0);
      }

      50% {
        transform: translateY(-1.5px);
      }
    }

    /* Wheel rotation synced with fast movement */
    .mrt-train .mrt-wheel {
      animation: wheel-spin 0.25s linear infinite;
    }

    /* ===== ENHANCED RIDE SCENE TRAIN (matching welcome screen quality) ===== */

    /* Roof ridge for all cars in ride scene */
    .mrt-ride-screen .mrt-car::before {
      content: '';
      position: absolute;
      top: -3px;
      left: 8%;
      right: 8%;
      height: 3px;
      background: linear-gradient(90deg,
          transparent 0%,
          #C0C0C0 10%,
          #E0E0E0 50%,
          #C0C0C0 90%,
          transparent 100%);
      border-radius: 2px 2px 0 0;
      z-index: 10;
    }

    /* AC Units on ride scene train roofs */
    .mrt-ride-screen .mrt-car::after {
      content: '';
      position: absolute;
      top: -6px;
      left: 35%;
      width: 18%;
      height: 5px;
      background: linear-gradient(180deg, #B0B0B0 0%, #909090 100%);
      border-radius: 2px;
      z-index: 11;
    }

    /* Front car with driver's cab */
    .mrt-front {
      width: clamp(100px, 25vw, 140px);
      height: clamp(50px, 12vw, 70px);
    }

    .mrt-front .mrt-body {
      position: absolute;
      inset: 0;
      /* Silver metallic body - refined gradient */
      background: linear-gradient(180deg,
          #F8F8F8 0%,
          #F0F0F0 10%,
          #E8E8E8 30%,
          #D8D8D8 70%,
          #C8C8C8 90%,
          #B8B8B8 100%);
      border-radius: 14px 8px 8px 14px;
      box-shadow:
        0 4px 12px rgba(0, 0, 0, 0.25),
        0 2px 4px rgba(0, 0, 0, 0.15),
        inset 0 2px 6px rgba(255, 255, 255, 0.9),
        inset 0 -2px 4px rgba(0, 0, 0, 0.08);
      overflow: hidden;
    }

    /* Interior warm glow for ride scene */
    .mrt-ride-screen .mrt-body::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 40%;
      background: linear-gradient(180deg,
          rgba(255, 248, 225, 0.15) 0%,
          rgba(255, 248, 225, 0.05) 100%);
      pointer-events: none;
    }

    /* Aerodynamic front nose */
    .mrt-front .mrt-body::before {
      content: '';
      position: absolute;
      left: -8px;
      top: 10%;
      width: 10px;
      height: 80%;
      background: linear-gradient(180deg,
          #F0F0F0 0%,
          #D8D8D8 50%,
          #C0C0C0 100%);
      border-radius: 8px 0 0 8px;
      box-shadow: inset 2px 0 4px rgba(255, 255, 255, 0.5);
    }

    /* Front destination display (Taiwan MRT-style) */
    .mrt-front-display {
      position: absolute;
      top: 10%;
      left: 38px;
      width: 34px;
      height: 14px;
      background: linear-gradient(180deg, #0a0a14 0%, #1a1a2e 60%, #0a0a14 100%);
      border-radius: 3px;
      box-shadow:
        inset 0 0 10px rgba(74, 222, 128, 0.15),
        0 2px 4px rgba(0, 0, 0, 0.25);
      border: 1px solid rgba(255, 255, 255, 0.12);
    }

    .mrt-front-display::after {
      content: 'MRT';
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      font-family: 'VT323', monospace;
      font-size: 0.95rem;
      color: #4ADE80;
      letter-spacing: 1px;
      text-shadow: 0 0 10px rgba(74, 222, 128, 0.7);
      opacity: 0.95;
    }

    /* Colored stripe (MRT line color) - matching welcome screen */
    .mrt-stripe {
      position: absolute;
      left: -15px;
      right: 0;
      top: 42%;
      height: 12%;
      background: var(--mrt-stripe-color);
      box-shadow:
        0 1px 2px rgba(0, 0, 0, 0.25),
        inset 0 2px 4px rgba(255, 255, 255, 0.3),
        inset 0 -2px 4px rgba(0, 0, 0, 0.2);
    }

    /* Front windshield */
    .mrt-windshield {
      position: absolute;
      left: 4px;
      top: 12%;
      width: 30px;
      height: 58%;
      background: linear-gradient(135deg,
          #1a1a2e 0%,
          #2d2d44 50%,
          #1a1a2e 100%);
      border-radius: 10px 4px 6px 10px;
      box-shadow:
        inset 0 0 10px rgba(100, 200, 255, 0.3),
        0 2px 4px rgba(0, 0, 0, 0.3);
    }

    /* Windshield reflection */
    .mrt-windshield::after {
      content: '';
      position: absolute;
      top: 2px;
      left: 2px;
      width: 40%;
      height: 50%;
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.4) 0%, transparent 100%);
      border-radius: 4px;
    }

    /* Headlights */
    .mrt-headlight {
      position: absolute;
      width: 6px;
      height: 6px;
      background: radial-gradient(circle, #FFE082 0%, #FFC107 100%);
      border-radius: 50%;
      box-shadow: 0 0 8px #FFC107, 0 0 16px rgba(255, 193, 7, 0.5);
      left: -12px;
    }

    .mrt-headlight-l {
      top: 55%;
    }

    .mrt-headlight-r {
      top: 70%;
    }

    /* Passenger windows container */
    .mrt-windows {
      position: absolute;
      top: 12%;
      right: 8px;
      left: 25px;
      display: flex;
      gap: 4px;
      height: 35%;
    }

    .mrt-window {
      flex: 1;
      position: relative;
      /* Matching welcome screen's refined tinted window look */
      background: linear-gradient(180deg,
          #1a3a5c 0%,
          #2d5a7b 30%,
          #4a8ab0 100%);
      border-radius: 3px;
      box-shadow:
        inset 0 0 0 2px rgba(0, 0, 0, 0.15),
        inset 0 2px 4px rgba(0, 0, 0, 0.2),
        0 1px 2px rgba(0, 0, 0, 0.2);
      border: 1px solid #A0A0A0;
      overflow: hidden;
    }

    /* Window shine/reflection effect - matching welcome screen */
    .mrt-window::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 60%;
      bottom: 60%;
      background: linear-gradient(135deg,
          rgba(255, 255, 255, 0.4) 0%,
          transparent 100%);
    }

    .mrt-window::after {
      content: '';
      position: absolute;
      top: 2px;
      left: 2px;
      width: 30%;
      height: 40%;
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.5) 0%, transparent 100%);
      border-radius: 2px;
    }

    /* Door - refined styling */
    .mrt-door {
      position: absolute;
      bottom: 5px;
      right: 20%;
      width: 18%;
      height: 55%;
      background: linear-gradient(90deg,
          #D0D0D0 0%,
          #E8E8E8 30%,
          #F0F0F0 50%,
          #E8E8E8 70%,
          #D0D0D0 100%);
      border-radius: 2px 2px 0 0;
      box-shadow:
        inset 0 0 4px rgba(0, 0, 0, 0.15),
        inset 0 1px 2px rgba(255, 255, 255, 0.5);
    }

    /* Door window - matching window tint */
    .mrt-door::before {
      content: '';
      position: absolute;
      top: 8%;
      left: 15%;
      width: 70%;
      height: 40%;
      background: linear-gradient(180deg, #1a3a5c 0%, #2d5a7b 50%, #4a8ab0 100%);
      border-radius: 2px;
      box-shadow: inset 0 0 4px rgba(255, 255, 255, 0.5);
    }

    /* Undercarriage */
    .mrt-undercarriage {
      position: absolute;
      bottom: -8px;
      left: 10%;
      right: 10%;
      height: 10px;
      background: linear-gradient(180deg, #3a3a3a 0%, #1a1a1a 100%);
      border-radius: 2px;
      display: flex;
      justify-content: space-between;
      padding: 0 10%;
    }

    .mrt-wheel {
      width: 14px;
      height: 14px;
      background: radial-gradient(circle at 30% 30%, #666 0%, #222 100%);
      border-radius: 50%;
      border: 2px solid #444;
      position: relative;
      top: 2px;
      animation: wheel-spin 0.3s linear infinite;
    }

    .mrt-wheel::after {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 6px;
      height: 6px;
      background: #888;
      border-radius: 50%;
    }

    @keyframes wheel-spin {
      0% {
        transform: rotate(0deg);
      }

      100% {
        transform: rotate(360deg);
      }
    }

    /* Middle car */
    .mrt-middle {
      width: clamp(90px, 22vw, 130px);
      height: clamp(50px, 12vw, 70px);
    }

    .mrt-middle .mrt-body {
      position: absolute;
      inset: 0;
      /* Refined silver gradient matching welcome screen */
      background: linear-gradient(180deg,
          #F8F8F8 0%,
          #F0F0F0 10%,
          #E8E8E8 30%,
          #D8D8D8 70%,
          #C8C8C8 90%,
          #B8B8B8 100%);
      border-radius: 4px;
      box-shadow:
        0 4px 12px rgba(0, 0, 0, 0.25),
        0 2px 4px rgba(0, 0, 0, 0.15),
        inset 0 2px 6px rgba(255, 255, 255, 0.9),
        inset 0 -2px 4px rgba(0, 0, 0, 0.08);
      overflow: hidden;
    }

    .mrt-middle .mrt-windows {
      left: 8px;
      right: 8px;
    }

    .mrt-middle .mrt-door-1 {
      left: 15%;
      right: auto;
    }

    .mrt-middle .mrt-door-2 {
      right: 15%;
    }

    /* Connector between cars - matching welcome screen style */
    .mrt-connector {
      width: clamp(8px, 1.5vw, 12px);
      height: 34px;
      margin: 0 -2px;
      transform: translateY(-14px);
      background: linear-gradient(90deg,
          #3a3a3a 0%,
          #4a4a4a 30%,
          #5a5a5a 50%,
          #4a4a4a 70%,
          #3a3a3a 100%);
      border-radius: 3px;
      box-shadow:
        inset 0 0 4px rgba(0, 0, 0, 0.5),
        0 2px 4px rgba(0, 0, 0, 0.25);
      align-self: flex-end;
      position: relative;
    }

    /* Connector ribbed texture */
    .mrt-connector::before {
      content: '';
      position: absolute;
      top: 20%;
      left: 20%;
      right: 20%;
      bottom: 20%;
      background: repeating-linear-gradient(0deg,
          #2a2a2a 0px, #2a2a2a 2px,
          #4a4a4a 2px, #4a4a4a 4px);
      border-radius: 1px;
    }

    /* Rear car (same as middle, rounded back) */
    .mrt-rear {
      width: clamp(90px, 22vw, 130px);
      height: clamp(50px, 12vw, 70px);
    }

    .mrt-rear .mrt-body {
      position: absolute;
      inset: 0;
      /* Refined silver gradient matching welcome screen */
      background: linear-gradient(180deg,
          #F8F8F8 0%,
          #F0F0F0 10%,
          #E8E8E8 30%,
          #D8D8D8 70%,
          #C8C8C8 90%,
          #B8B8B8 100%);
      border-radius: 8px 14px 14px 8px;
      box-shadow:
        0 4px 12px rgba(0, 0, 0, 0.25),
        0 2px 4px rgba(0, 0, 0, 0.15),
        inset 0 2px 6px rgba(255, 255, 255, 0.9),
        inset 0 -2px 4px rgba(0, 0, 0, 0.08);
      overflow: hidden;
    }

    .mrt-rear .mrt-windows {
      left: 8px;
      right: 8px;
    }

    .mrt-rear .mrt-door-1 {
      left: 15%;
      right: auto;
    }

    .mrt-rear .mrt-door-2 {
      right: 15%;
    }

    /* Station-themed train stripe colors - Taipei MRT Lines */
    /* Red Line (Level 1) */
    .theme-fruit #mrtTrain,
    .theme-drink #mrtTrain,
    .theme-bakery #mrtTrain,
    .theme-redbean #mrtTrain {
      --stripe-color: var(--line-red);
    }

    /* Blue Line (Level 2) */
    .theme-pizza #mrtTrain,
    .theme-bubbletea #mrtTrain,
    .theme-burger #mrtTrain,
    .theme-icecream #mrtTrain {
      --stripe-color: var(--line-blue);
    }

    /* Green Line (Level 3) */
    .theme-fishshop #mrtTrain,
    .theme-sushi #mrtTrain,
    .theme-cheese #mrtTrain,
    .theme-chicken #mrtTrain {
      --stripe-color: var(--line-green);
    }

    /* Orange Line (Level 4) */
    .theme-noodle #mrtTrain,
    .theme-smoothie #mrtTrain,
    .theme-teahouse #mrtTrain {
      --stripe-color: var(--line-orange);
    }

    /* === FLOATING CLOUDS === */
    .cloud-layer {
      position: absolute;
      top: 5%;
      left: 0;
      width: 300%;
      height: 30%;
      animation: clouds-drift 8s linear infinite;
      pointer-events: none;
    }

    .cloud {
      position: absolute;
      background: rgba(255, 255, 255, 0.9);
      border-radius: 50px;
      filter: blur(1px);
    }

    .cloud::before,
    .cloud::after {
      content: '';
      position: absolute;
      background: inherit;
      border-radius: 50%;
    }

    .cloud-1 {
      width: 70px;
      height: 25px;
      top: 20%;
      left: 8%;
    }

    .cloud-1::before {
      width: 35px;
      height: 35px;
      top: -18px;
      left: 10px;
    }

    .cloud-1::after {
      width: 45px;
      height: 45px;
      top: -22px;
      left: 28px;
    }

    .cloud-2 {
      width: 90px;
      height: 30px;
      top: 10%;
      left: 35%;
    }

    .cloud-2::before {
      width: 45px;
      height: 45px;
      top: -22px;
      left: 12px;
    }

    .cloud-2::after {
      width: 55px;
      height: 55px;
      top: -28px;
      left: 35px;
    }

    .cloud-3 {
      width: 60px;
      height: 22px;
      top: 30%;
      left: 65%;
    }

    .cloud-3::before {
      width: 30px;
      height: 30px;
      top: -15px;
      left: 8px;
    }

    .cloud-3::after {
      width: 40px;
      height: 40px;
      top: -20px;
      left: 22px;
    }

    @keyframes clouds-drift {
      0% {
        transform: translateX(0);
      }

      100% {
        transform: translateX(-33.33%);
      }
    }

    /* === ANIMATED TAIPEI ELEMENTS === */
    /* Birds flying across the sky */
    .taipei-bird {
      position: absolute;
      width: 28px;
      height: 18px;
      background-image: url('assets/ride/bird.svg');
      background-repeat: no-repeat;
      background-size: contain;
      background-position: center;
      animation: bird-fly 15s linear infinite;
      z-index: 5;
      opacity: 0.95;
      filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.2));
      will-change: transform;
    }

    .taipei-bird-1 {
      top: 15%;
      left: -50px;
      animation-delay: 0s;
    }

    .taipei-bird-2 {
      top: 25%;
      left: -50px;
      animation-delay: 5s;
      width: 22px;
      height: 14px;
    }

    .taipei-bird-3 {
      top: 20%;
      left: -50px;
      animation-delay: 10s;
      width: 26px;
      height: 16px;
    }

    @keyframes bird-fly {
      0% {
        transform: translateX(0) translateY(0);
      }

      25% {
        transform: translateX(30vw) translateY(-10px);
      }

      50% {
        transform: translateX(60vw) translateY(0);
      }

      75% {
        transform: translateX(90vw) translateY(-5px);
      }

      100% {
        transform: translateX(120vw) translateY(0);
      }
    }

    /* Hot air balloon floating */
    .taipei-balloon {
      position: absolute;
      width: 54px;
      height: 72px;
      background-image: url('assets/ride/balloon.svg');
      background-repeat: no-repeat;
      background-size: contain;
      background-position: center;
      animation: balloon-float 20s ease-in-out infinite;
      z-index: 4;
      top: 10%;
      left: 80%;
      opacity: 0.95;
      filter: drop-shadow(0 3px 8px rgba(0, 0, 0, 0.2));
      will-change: transform;
    }

    @keyframes balloon-float {

      0%,
      100% {
        transform: translateX(0) translateY(0);
      }

      25% {
        transform: translateX(-20px) translateY(-15px);
      }

      50% {
        transform: translateX(-10px) translateY(-25px);
      }

      75% {
        transform: translateX(-30px) translateY(-10px);
      }
    }


    /* Lanterns swaying in night market scene */
    .taipei-lantern {
      position: absolute;
      width: 28px;
      height: 36px;
      background-image: url('assets/ride/lantern.svg');
      background-repeat: no-repeat;
      background-size: contain;
      background-position: center;
      animation: lantern-sway 3s ease-in-out infinite;
      z-index: 10;
      transform-origin: 50% 0%;
      opacity: 0.95;
      filter: drop-shadow(0 3px 8px rgba(0, 0, 0, 0.25));
      will-change: transform;
    }

    .taipei-lantern-1 {
      top: 10%;
      left: 20%;
      animation-delay: 0s;
    }

    .taipei-lantern-2 {
      top: 12%;
      left: 50%;
      animation-delay: 1s;
    }

    .taipei-lantern-3 {
      top: 8%;
      left: 75%;
      animation-delay: 2s;
    }

    @keyframes lantern-sway {

      0%,
      100% {
        transform: translateX(0) rotate(0deg);
      }

      25% {
        transform: translateX(-5px) rotate(-3deg);
      }

      50% {
        transform: translateX(0) rotate(0deg);
      }

      75% {
        transform: translateX(5px) rotate(3deg);
      }
    }

    /* Show/hide elements based on theme */
    .taipei-bird,
    .taipei-balloon,
    .taipei-lantern {
      display: none;
    }

    /* Birds for mountain, riverside, and skyline scenes */
    .theme-icecream .taipei-bird,
    .theme-drink .taipei-bird,
    .theme-fruit .taipei-bird {
      display: block;
    }

    /* Balloon for mountain scene */
    .theme-icecream .taipei-balloon {
      display: block;
    }


    /* Lanterns for night market scenes */
    .theme-pizza .taipei-lantern,
    .theme-noodle .taipei-lantern {
      display: block;
    }

    /* === LED DESTINATION DISPLAY === */
    .destination-display {
      position: absolute;
      top: clamp(24px, 6vw, 40px);
      left: 50%;
      transform: translateX(-50%);
      z-index: 50;
      background: linear-gradient(180deg, #1a1a1a 0%, #0d0d0d 100%);
      border: 3px solid #333;
      border-radius: 8px;
      padding: clamp(8px, 2vw, 14px) clamp(16px, 4vw, 28px);
      box-shadow:
        0 4px 20px rgba(0, 0, 0, 0.8),
        inset 0 1px 0 rgba(255, 255, 255, 0.1);
    }

    .destination-display::before {
      content: '';
      position: absolute;
      top: 4px;
      left: 4px;
      right: 4px;
      height: 2px;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
    }

    .display-label {
      font-family: 'VT323', monospace;
      font-size: clamp(0.7rem, 2vw, 0.9rem);
      color: #FFB300;
      text-transform: uppercase;
      letter-spacing: 2px;
      text-align: center;
      margin-bottom: 4px;
      text-shadow: 0 0 10px rgba(255, 179, 0, 0.5);
    }

    .display-destination {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: clamp(8px, 2vw, 12px);
    }

    .display-icon {
      font-size: clamp(1.5rem, 4vw, 2rem);
      filter: drop-shadow(0 0 8px rgba(255, 255, 255, 0.3));
      animation: icon-pulse 2s ease-in-out infinite;
    }

    @keyframes icon-pulse {

      0%,
      100% {
        transform: scale(1);
      }

      50% {
        transform: scale(1.1);
      }
    }

    .display-name {
      font-family: 'VT323', monospace;
      font-size: clamp(1.2rem, 3.5vw, 1.8rem);
      color: #4ADE80;
      text-shadow:
        0 0 10px rgba(74, 222, 128, 0.8),
        0 0 20px rgba(74, 222, 128, 0.4);
      letter-spacing: 1px;
    }

    /* LED dots effect */
    .display-name::before {
      content: '';
      color: #4ADE80;
      animation: blink-arrow 1s step-end infinite;
    }

    @keyframes blink-arrow {

      0%,
      100% {
        opacity: 1;
      }

      50% {
        opacity: 0.3;
      }
    }

    /* === THEMED FLOATING ELEMENTS === */
    .themed-floaters {
      position: absolute;
      top: 15%;
      left: 0;
      width: 100%;
      height: 40%;
      pointer-events: none;
      overflow: hidden;
      z-index: 30;
    }

    .floater {
      position: absolute;
      font-size: clamp(1.5rem, 4vw, 2.5rem);
      opacity: 0.9;
      animation: floater-drift 4s ease-in-out infinite;
      filter: drop-shadow(2px 4px 6px rgba(0, 0, 0, 0.3));
    }

    .floater:nth-child(1) {
      top: 5%;
      animation-delay: 0s;
      left: 110%;
    }

    .floater:nth-child(2) {
      top: 35%;
      animation-delay: -1s;
      left: 110%;
      font-size: clamp(1.2rem, 3vw, 1.8rem);
    }

    .floater:nth-child(3) {
      top: 20%;
      animation-delay: -2s;
      left: 110%;
      font-size: clamp(1.8rem, 5vw, 2.8rem);
    }

    .floater:nth-child(4) {
      top: 50%;
      animation-delay: -0.5s;
      left: 110%;
      font-size: clamp(1.4rem, 3.5vw, 2rem);
    }

    .floater:nth-child(5) {
      top: 10%;
      animation-delay: -1.5s;
      left: 110%;
      font-size: clamp(1.3rem, 3vw, 1.6rem);
    }

    @keyframes floater-drift {
      0% {
        transform: translateX(0) translateY(0) rotate(0deg);
      }

      25% {
        transform: translateX(-30vw) translateY(-10px) rotate(5deg);
      }

      50% {
        transform: translateX(-60vw) translateY(5px) rotate(-3deg);
      }

      75% {
        transform: translateX(-90vw) translateY(-5px) rotate(3deg);
      }

      100% {
        transform: translateX(-120vw) translateY(0) rotate(0deg);
      }
    }

    /* === MAGICAL SPARKLES === */
    .sparkle-layer {
      position: absolute;
      inset: 0;
      pointer-events: none;
      z-index: 25;
      overflow: hidden;
    }

    .sparkle {
      position: absolute;
      width: 8px;
      height: 8px;
      background: radial-gradient(circle, #FFF 0%, #FFE66D 50%, transparent 70%);
      border-radius: 50%;
      animation: sparkle-twinkle 1.5s ease-in-out infinite, sparkle-float 4s ease-in-out infinite;
      box-shadow: 0 0 10px 2px rgba(255, 230, 109, 0.6);
    }

    .sparkle-1 {
      top: 15%;
      left: 10%;
      animation-delay: 0s;
    }

    .sparkle-2 {
      top: 25%;
      left: 30%;
      animation-delay: 0.3s;
      width: 6px;
      height: 6px;
    }

    .sparkle-3 {
      top: 10%;
      left: 50%;
      animation-delay: 0.6s;
    }

    .sparkle-4 {
      top: 35%;
      left: 70%;
      animation-delay: 0.9s;
      width: 10px;
      height: 10px;
    }

    .sparkle-5 {
      top: 20%;
      left: 85%;
      animation-delay: 1.2s;
      width: 5px;
      height: 5px;
    }

    .sparkle-6 {
      top: 40%;
      left: 20%;
      animation-delay: 0.4s;
    }

    .sparkle-7 {
      top: 8%;
      left: 65%;
      animation-delay: 0.7s;
      width: 7px;
      height: 7px;
    }

    .sparkle-8 {
      top: 30%;
      left: 45%;
      animation-delay: 1.0s;
    }

    @keyframes sparkle-twinkle {

      0%,
      100% {
        opacity: 0.3;
        transform: scale(0.8);
      }

      50% {
        opacity: 1;
        transform: scale(1.2);
      }
    }

    @keyframes sparkle-float {

      0%,
      100% {
        transform: translateY(0) translateX(0);
      }

      25% {
        transform: translateY(-10px) translateX(5px);
      }

      50% {
        transform: translateY(-5px) translateX(-5px);
      }

      75% {
        transform: translateY(-15px) translateX(3px);
      }
    }

    /* Gentle train wobble effect */
    .mrt-ride-screen.active .scenery-container {
      animation: train-wobble 2s ease-in-out infinite;
    }

    @keyframes train-wobble {

      0%,
      100% {
        transform: translateY(0);
      }

      25% {
        transform: translateY(-2px);
      }

      50% {
        transform: translateY(1px);
      }

      75% {
        transform: translateY(-1px);
      }
    }

    /* === STATION THEME VARIATIONS === */

    /* Fruit Stand - Golden Orchard Sunset */
    .theme-fruit .sky-layer {
      background: linear-gradient(180deg,
          #FF6B35 0%, #FF8C42 20%, #FFD93D 45%,
          #C1E1C1 70%, #6BCB77 100%);
    }

    .theme-fruit .celestial-body {
      background: radial-gradient(circle at 30% 30%, #FFFACD, #FF8C00);
      box-shadow: 0 0 60px rgba(255, 140, 0, 0.6);
    }

    .theme-fruit .hill {
      background: linear-gradient(180deg, #6BCB77 0%, #4A9E5C 100%) !important;
    }

    .theme-fruit .tree::after {
      border-color: transparent transparent #FF6B35 transparent !important;
    }

    .theme-fruit .ground-layer {
      background: linear-gradient(180deg, #6BCB77 0%, #4A9E5C 100%);
    }

    /* Drink Bar - Crystal Blue Waterfall */
    .theme-drink .sky-layer {
      background: linear-gradient(180deg,
          #00B4D8 0%, #48CAE4 25%, #90E0EF 50%,
          #CAF0F8 75%, #ADE8F4 100%);
    }

    .theme-drink .celestial-body {
      background: radial-gradient(circle at 30% 30%, #FFFFFF, #B8E2F2);
      box-shadow: 0 0 50px rgba(144, 224, 239, 0.8);
    }

    .theme-drink .cloud {
      background: rgba(255, 255, 255, 0.95);
    }

    .theme-drink .mountain {
      border-bottom-color: #0077B6 !important;
    }

    .theme-drink .hill {
      background: linear-gradient(180deg, #48CAE4 0%, #0096C7 100%) !important;
    }

    .theme-drink .tree::after {
      border-color: transparent transparent #00B4D8 transparent !important;
    }

    .theme-drink .ground-layer {
      background: linear-gradient(180deg, #0077B6 0%, #023E8A 100%);
    }

    /* Bakery - Warm Cozy Village */
    .theme-bakery .sky-layer {
      background: linear-gradient(180deg,
          #FFAB76 0%, #FFD4A3 25%, #FFF1E6 50%,
          #E8D5C4 75%, #C9A87C 100%);
    }

    .theme-bakery .celestial-body {
      background: radial-gradient(circle at 30% 30%, #FFF8DC, #DEB887);
      box-shadow: 0 0 50px rgba(222, 184, 135, 0.6);
    }

    .theme-bakery .mountain {
      border-bottom-color: #A0785A !important;
    }

    .theme-bakery .hill {
      background: linear-gradient(180deg, #D4A574 0%, #B8860B 100%) !important;
    }

    .theme-bakery .tree::after {
      border-color: transparent transparent #8B4513 transparent !important;
    }

    .theme-bakery .ground-layer {
      background: linear-gradient(180deg, #C9A87C 0%, #8B7355 100%);
    }

    /* Pizza - Italian Tuscan Sunset */
    .theme-pizza .sky-layer {
      background: linear-gradient(180deg,
          #FF6B6B 0%, #FF8E72 25%, #FFC3A0 50%,
          #F0E68C 75%, #98D8AA 100%);
    }

    .theme-pizza .celestial-body {
      background: radial-gradient(circle at 30% 30%, #FFE4B5, #FF7F50);
      box-shadow: 0 0 60px rgba(255, 127, 80, 0.7);
    }

    .theme-pizza .mountain {
      border-bottom-color: #CD853F !important;
    }

    .theme-pizza .hill {
      background: linear-gradient(180deg, #9ACD32 0%, #6B8E23 100%) !important;
    }

    .theme-pizza .tree::after {
      border-color: transparent transparent #228B22 transparent !important;
    }

    .theme-pizza .ground-layer {
      background: linear-gradient(180deg, #6B8E23 0%, #556B2F 100%);
    }

    /* Ice Cream - Pastel Candy Dream */
    .theme-icecream .sky-layer {
      background: linear-gradient(180deg,
          #FFB5E8 0%, #DCD3FF 25%, #B5DEFF 45%,
          #D5FFD0 65%, #FFFFD1 85%, #FFD1DC 100%);
    }

    .theme-icecream .celestial-body {
      background: radial-gradient(circle at 30% 30%, #FFFFFF, #FFB5E8);
      box-shadow: 0 0 50px rgba(255, 181, 232, 0.8);
    }

    .theme-icecream .cloud {
      background: rgba(255, 255, 255, 1);
    }

    .theme-icecream .mountain {
      border-bottom-color: #DDA0DD !important;
    }

    .theme-icecream .mountain::before {
      border-bottom-color: #FFFFFF !important;
    }

    .theme-icecream .hill {
      background: linear-gradient(180deg, #98D8C8 0%, #7EC8B8 100%) !important;
    }

    .theme-icecream .tree::after {
      border-color: transparent transparent #FF69B4 transparent !important;
    }

    .theme-icecream .ground-layer {
      background: linear-gradient(180deg, #FFB5E8 0%, #FF69B4 100%);
    }

    /* Fish Shop - Deep Ocean Adventure */
    .theme-fishshop .sky-layer {
      background: linear-gradient(180deg,
          #0077B6 0%, #0096C7 20%, #00B4D8 40%,
          #48CAE4 60%, #90E0EF 80%, #00CED1 100%);
    }

    .theme-fishshop .celestial-body {
      background: radial-gradient(circle at 50% 50%, rgba(255, 255, 255, 0.3), transparent);
      box-shadow: none;
      animation: none;
    }

    /* Bubbles instead of sun */
    .theme-fishshop .celestial-body::after {
      content: '';
      font-size: 3rem;
      position: absolute;
      animation: bubble-rise 3s ease-in-out infinite;
    }

    @keyframes bubble-rise {

      0%,
      100% {
        transform: translateY(0);
        opacity: 0.7;
      }

      50% {
        transform: translateY(-15px);
        opacity: 1;
      }
    }

    .theme-fishshop .cloud {
      background: rgba(144, 224, 239, 0.4);
    }

    .theme-fishshop .mountain {
      border-bottom-color: #006994 !important;
    }

    .theme-fishshop .hill {
      background: linear-gradient(180deg, #20B2AA 0%, #008B8B 100%) !important;
    }

    .theme-fishshop .tree::after {
      border-color: transparent transparent #008080 transparent !important;
    }

    .theme-fishshop .ground-layer {
      background: linear-gradient(180deg, #20B2AA 0%, #006666 100%);
    }

    /* Seaweed effect */
    .theme-fishshop .ground-layer::after {
      content: '';
      position: absolute;
      top: -20px;
      left: 0;
      width: 100%;
      font-size: 1.5rem;
      letter-spacing: 20px;
      animation: seaweed-sway 2s ease-in-out infinite;
    }

    @keyframes seaweed-sway {

      0%,
      100% {
        transform: skewX(-3deg);
      }

      50% {
        transform: skewX(3deg);
      }
    }

    /* Cheese Shop - Swiss Alps Golden Hour */
    .theme-cheese .sky-layer {
      background: linear-gradient(180deg,
          #FFD700 0%, #FFA500 20%, #FFEFD5 45%,
          #E0F2E9 70%, #90EE90 100%);
    }

    .theme-cheese .celestial-body {
      background: radial-gradient(circle at 30% 30%, #FFFACD, #FFD700);
      box-shadow: 0 0 70px rgba(255, 215, 0, 0.7);
    }

    .theme-cheese .mountain {
      border-bottom-color: #DAA520 !important;
    }

    .theme-cheese .mountain::before {
      border-bottom-color: #FFFAF0 !important;
    }

    .theme-cheese .hill {
      background: linear-gradient(180deg, #9ACD32 0%, #6B8E23 100%) !important;
    }

    .theme-cheese .tree::after {
      border-color: transparent transparent #228B22 transparent !important;
    }

    .theme-cheese .ground-layer {
      background: linear-gradient(180deg, #7CB342 0%, #558B2F 100%);
    }

    /* Noodle House - Asian Evening Glow */
    .theme-noodle .sky-layer {
      background: linear-gradient(180deg,
          #DC143C 0%, #FF6347 20%, #FFA07A 40%,
          #FFE4B5 60%, #98FB98 80%, #3CB371 100%);
    }

    .theme-noodle .celestial-body {
      background: radial-gradient(circle at 30% 30%, #FFE4E1, #FF6347);
      box-shadow: 0 0 60px rgba(255, 99, 71, 0.6);
    }

    .theme-noodle .mountain {
      border-bottom-color: #8B0000 !important;
    }

    .theme-noodle .hill {
      background: linear-gradient(180deg, #66CDAA 0%, #3CB371 100%) !important;
    }

    .theme-noodle .tree::after {
      border-color: transparent transparent #006400 transparent !important;
    }

    .theme-noodle .ground-layer {
      background: linear-gradient(180deg, #3CB371 0%, #2E8B57 100%);
    }

    /* Lantern glow effect */
    .theme-noodle .destination-display {
      border-color: #FFD700;
      box-shadow: 0 0 30px rgba(255, 215, 0, 0.4);
    }

    /* ===== ELEVATOR SCREEN ===== */
    .elevator-screen {
      background: linear-gradient(180deg, #D5D0C8 0%, #E8E3DB 50%, #C9C4BC 100%);
      display: flex;
      flex-direction: row;
      padding: clamp(0.5rem, 1vh, 1rem);
      gap: clamp(0.5rem, 1vh, 1rem);
      /* Subtle tile pattern for elevator lobby */
      background-image:
        linear-gradient(180deg, #D5D0C8 0%, #E8E3DB 50%, #C9C4BC 100%),
        repeating-linear-gradient(90deg, transparent 0, transparent 49px, rgba(0, 0, 0, 0.03) 49px, rgba(0, 0, 0, 0.03) 50px),
        repeating-linear-gradient(0deg, transparent 0, transparent 49px, rgba(0, 0, 0, 0.03) 49px, rgba(0, 0, 0, 0.03) 50px);
    }

    .elevator-shaft {
      flex: 1;
      /* Warm wooden elevator interior */
      background:
        linear-gradient(135deg, #8B7355 0%, #A0826D 25%, #6F5E52 50%, #8B7355 75%, #9B8169 100%);
      border-radius: 12px;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: clamp(0.5rem, 1vh, 1rem);
      /* Cozy interior shadow with soft ambient lighting */
      box-shadow:
        inset 0 4px 12px rgba(0, 0, 0, 0.3),
        inset 0 -2px 6px rgba(255, 255, 255, 0.1),
        0 8px 24px rgba(0, 0, 0, 0.2),
        inset 0 0 60px rgba(255, 230, 180, 0.15);
      border: 4px solid #5D4E41;
      position: relative;
      /* Wood panel texture */
      background-image:
        linear-gradient(135deg, #8B7355 0%, #A0826D 25%, #6F5E52 50%, #8B7355 75%, #9B8169 100%),
        repeating-linear-gradient(90deg, transparent 0, transparent 3px, rgba(0, 0, 0, 0.05) 3px, rgba(0, 0, 0, 0.05) 6px);
      /* Gentle ambient glow pulsing */
      animation: interior-glow-pulse 6s ease-in-out infinite;
    }

    @keyframes interior-glow-pulse {
      0%, 100% {
        box-shadow:
          inset 0 4px 12px rgba(0, 0, 0, 0.3),
          inset 0 -2px 6px rgba(255, 255, 255, 0.1),
          0 8px 24px rgba(0, 0, 0, 0.2),
          inset 0 0 60px rgba(255, 230, 180, 0.15);
      }
      50% {
        box-shadow:
          inset 0 4px 12px rgba(0, 0, 0, 0.3),
          inset 0 -2px 6px rgba(255, 255, 255, 0.12),
          0 8px 24px rgba(0, 0, 0, 0.2),
          inset 0 0 70px rgba(255, 230, 180, 0.22);
      }
    }

    /* Decorative brass corner accents */
    .elevator-shaft::before,
    .elevator-shaft::after {
      content: '';
      position: absolute;
      width: 20px;
      height: 20px;
      border: 3px solid #B8860B;
      filter: drop-shadow(0 1px 2px rgba(0, 0, 0, 0.3));
    }

    .elevator-shaft::before {
      top: 8px;
      left: 8px;
      border-right: none;
      border-bottom: none;
    }

    .elevator-shaft::after {
      top: 8px;
      right: 8px;
      border-left: none;
      border-bottom: none;
    }

    /* Soft ceiling light effect with gentle pulsing */
    .elevator-shaft>*:first-child::before {
      content: '';
      position: absolute;
      top: -16px;
      left: 50%;
      transform: translateX(-50%);
      width: 80px;
      height: 30px;
      background: radial-gradient(ellipse at center, rgba(255, 244, 214, 0.9) 0%, rgba(255, 244, 214, 0.5) 40%, rgba(255, 244, 214, 0.2) 70%, transparent 100%);
      border-radius: 50%;
      pointer-events: none;
      z-index: 10;
      filter: blur(2px);
      animation: ceiling-light-pulse 4s ease-in-out infinite;
    }

    @keyframes ceiling-light-pulse {
      0%, 100% {
        opacity: 1;
        filter: blur(2px);
      }
      50% {
        opacity: 0.85;
        filter: blur(2.5px);
      }
    }

    /* Interior handrail accent on left side */
    .elevator-shaft>.floor-display::after {
      content: '';
      position: absolute;
      left: -45px;
      top: 50%;
      transform: translateY(-50%);
      width: 35px;
      height: 6px;
      background: linear-gradient(90deg, #B8860B 0%, #DAA520 50%, #B8860B 100%);
      border-radius: 3px;
      box-shadow:
        0 2px 4px rgba(0, 0, 0, 0.3),
        inset 0 1px 1px rgba(255, 255, 255, 0.3);
      z-index: 0;
    }

    .floor-display {
      /* Realistic LED display */
      background: linear-gradient(180deg, #0a0a14 0%, #1a1a2e 50%, #0a0a14 100%);
      color: #FFB84D;
      font-family: 'Courier New', monospace;
      font-size: clamp(3rem, 7vh, 4rem);
      font-weight: bold;
      padding: clamp(12px, 1.5vh, 20px) var(--space-lg);
      border-radius: 8px;
      margin-bottom: clamp(0.5rem, 1vh, 1rem);
      min-width: 120px;
      text-align: center;
      /* Warm amber LED glow effect */
      text-shadow:
        0 0 15px #FFB84D,
        0 0 25px #FFB84D,
        0 0 35px rgba(255, 184, 77, 0.6);
      box-shadow:
        0 0 25px rgba(255, 184, 77, 0.3),
        inset 0 2px 8px rgba(0, 0, 0, 0.8),
        inset 0 -1px 2px rgba(255, 255, 255, 0.1),
        0 2px 4px rgba(0, 0, 0, 0.4);
      border: 3px solid #2a2a3e;
      position: relative;
      overflow: hidden;
    }

    /* Scanline effect for LED */
    .floor-display::after {
      content: '';
      position: absolute;
      inset: 0;
      background: repeating-linear-gradient(0deg,
          transparent 0,
          transparent 2px,
          rgba(0, 0, 0, 0.1) 2px,
          rgba(0, 0, 0, 0.1) 4px);
      pointer-events: none;
    }

    /* Floor changing animation with LED effect */
    .floor-display.changing {
      animation: floor-change 0.4s ease-in-out, floor-led-flicker 0.4s ease-in-out;
    }

    @keyframes floor-change {
      0%, 100% {
        opacity: 1;
        transform: scale(1);
      }
      50% {
        opacity: 0.4;
        transform: scale(0.95);
      }
    }

    @keyframes floor-led-flicker {
      0%, 100% {
        text-shadow:
          0 0 15px #FFB84D,
          0 0 25px #FFB84D,
          0 0 35px rgba(255, 184, 77, 0.6);
      }
      25% {
        text-shadow:
          0 0 8px #FFB84D,
          0 0 15px #FFB84D,
          0 0 20px rgba(255, 184, 77, 0.4);
      }
      50% {
        text-shadow:
          0 0 5px #FFB84D,
          0 0 10px #FFB84D,
          0 0 15px rgba(255, 184, 77, 0.3);
      }
      75% {
        text-shadow:
          0 0 12px #FFB84D,
          0 0 20px #FFB84D,
          0 0 28px rgba(255, 184, 77, 0.5);
      }
    }

    /* === NEW ELEVATOR ANIMATIONS === */

    /* Light streaks during elevator travel */
    .elevator-shaft.elevator-moving {
      will-change: transform;
    }

    .elevator-shaft.elevator-moving::before {
      content: '';
      position: absolute;
      left: 0;
      right: 0;
      height: 30%;
      background: linear-gradient(180deg,
        transparent 0%,
        rgba(255, 255, 255, 0.4) 50%,
        transparent 100%);
      animation: light-streak-up 0.6s linear infinite;
      pointer-events: none;
      z-index: 10;
    }

    @keyframes light-streak-up {
      from { transform: translateY(100%); opacity: 0; }
      20% { opacity: 0.8; }
      80% { opacity: 0.8; }
      to { transform: translateY(-100%); opacity: 0; }
    }

    /* Joy hop on arrival */
    .elevator-shaft.arrived {
      animation: joy-hop 0.6s cubic-bezier(0.34, 1.56, 0.64, 1);
    }

    @keyframes joy-hop {
      0%, 100% { transform: translateY(0); }
      25% { transform: translateY(-10px); }
      50% { transform: translateY(0); }
      70% { transform: translateY(-5px); }
    }

    /* Floor counter pulse */
    .floor-display.floor-pulse {
      animation: floor-pulse 0.4s ease-out;
      will-change: transform;
    }

    @keyframes floor-pulse {
      0% { transform: scale(1); }
      50% {
        transform: scale(1.15);
        text-shadow: 0 0 30px currentColor, 0 0 15px #FFB84D, 0 0 25px #FFB84D, 0 0 35px rgba(255, 184, 77, 0.6);
      }
      100% { transform: scale(1); }
    }

    /* Door chime visual pulse */
    .floor-display.chime::before {
      content: '';
      position: absolute;
      inset: -4px;
      border-radius: 8px;
      border: 2px solid currentColor;
      animation: chime-ring 0.8s ease-out;
      pointer-events: none;
    }

    @keyframes chime-ring {
      0% { box-shadow: 0 0 0 0 currentColor; opacity: 1; }
      100% { box-shadow: 0 0 0 20px transparent; opacity: 0; }
    }

    /* Particle drift animation */
    @keyframes particle-drift {
      0% { transform: translateY(-20px) rotate(0deg); opacity: 0; }
      20% { opacity: 1; }
      80% { opacity: 1; }
      100% { transform: translateY(100vh) rotate(360deg); opacity: 0; }
    }

    /* Themed particle containers */
    .elevator-shaft.with-particles::after {
      content: '';
      position: absolute;
      inset: 0;
      pointer-events: none;
      z-index: 15;
      overflow: hidden;
    }

    /* Style 6 - Golden sparkles */
    .elevator-screen.elevator-style-6 .elevator-shaft.with-particles::after {
      content: 'âœ¨ âœ¨ âœ¨ âœ¨ âœ¨ âœ¨ âœ¨ âœ¨';
      font-size: 20px;
      line-height: 80px;
      word-spacing: 40px;
      animation: particle-drift 4s linear infinite;
      text-shadow: 0 0 10px rgba(255, 215, 0, 0.8);
    }

    /* Style 7 - Nature leaves */
    .elevator-screen.elevator-style-7 .elevator-shaft.with-particles::after {
      content: 'ðŸƒ ðŸƒ ðŸƒ ðŸƒ ðŸƒ ðŸƒ';
      font-size: 24px;
      line-height: 100px;
      word-spacing: 50px;
      animation: particle-drift 5s linear infinite;
      filter: drop-shadow(0 0 4px rgba(76, 175, 80, 0.6));
    }

    /* Style 8 - Cyberpunk digital particles */
    .elevator-screen.elevator-style-8 .elevator-shaft.with-particles::after {
      background-image:
        radial-gradient(2px 2px at 20% 30%, #00E5FF 0%, transparent 50%),
        radial-gradient(2px 2px at 60% 70%, #EC4899 0%, transparent 50%),
        radial-gradient(2px 2px at 50% 50%, #8B5CF6 0%, transparent 50%),
        radial-gradient(2px 2px at 80% 20%, #00E5FF 0%, transparent 50%),
        radial-gradient(2px 2px at 30% 80%, #EC4899 0%, transparent 50%);
      background-size: 100% 200%;
      animation: particle-drift 3s linear infinite;
      box-shadow:
        0 0 20px rgba(0, 229, 255, 0.4),
        0 0 10px rgba(236, 72, 153, 0.3);
    }

    /* === END NEW ELEVATOR ANIMATIONS === */

    /* Elevator movement animation with realistic acceleration/deceleration */
    .elevator-shaft.moving {
      animation: elevator-shake 3.5s cubic-bezier(0.45, 0.05, 0.55, 0.95);
    }

    @keyframes elevator-shake {
      /* Initial acceleration - stronger shake */
      0% {
        transform: translateY(0) translateX(0) rotate(0deg);
      }
      5% {
        transform: translateY(1.5px) translateX(0.8px) rotate(0.1deg);
      }
      10% {
        transform: translateY(-1.2px) translateX(-0.6px) rotate(-0.1deg);
      }
      15% {
        transform: translateY(1px) translateX(0.7px) rotate(0.08deg);
      }

      /* Steady travel - moderate shake */
      20%, 25%, 30%, 35%, 40%, 45%, 50%, 55%, 60% {
        animation-timing-function: linear;
      }
      20% {
        transform: translateY(-0.8px) translateX(-0.5px) rotate(-0.05deg);
      }
      30% {
        transform: translateY(0.9px) translateX(0.5px) rotate(0.06deg);
      }
      40% {
        transform: translateY(-0.9px) translateX(-0.5px) rotate(-0.06deg);
      }
      50% {
        transform: translateY(1px) translateX(0.6px) rotate(0.05deg);
      }
      60% {
        transform: translateY(-1px) translateX(-0.6px) rotate(-0.05deg);
      }

      /* Deceleration - gentler shake */
      70% {
        transform: translateY(0.7px) translateX(0.4px) rotate(0.04deg);
      }
      80% {
        transform: translateY(-0.5px) translateX(-0.3px) rotate(-0.03deg);
      }
      90% {
        transform: translateY(0.2px) translateX(0.1px) rotate(0.01deg);
      }
      95% {
        transform: translateY(-0.1px) translateX(0) rotate(0deg);
      }
      100% {
        transform: translateY(0) translateX(0) rotate(0deg);
      }
    }

    .elevator-doors {
      flex: 1;
      width: 100%;
      /* Elevator door frame with viewing window */
      background: linear-gradient(180deg, #5D4E41 0%, #6F5E52 5%, #4A3F35 100%);
      border-radius: 6px;
      display: flex;
      overflow: hidden;
      position: relative;
      box-shadow:
        inset 0 0 30px rgba(0, 0, 0, 0.4),
        0 4px 8px rgba(0, 0, 0, 0.3);
      padding: 12px;
      gap: 6px;
      /* Slightly smaller to show interior walls around it */
      max-height: 85%;
      margin: auto;
    }

    .door {
      width: calc(50% - 3px);
      height: 100%;
      /* Warm metallic door with subtle brass tint */
      background:
        linear-gradient(90deg,
          #9B8169 0%,
          #B8A090 15%,
          #D0C0B0 30%,
          #B8A090 50%,
          #A08875 70%,
          #B8A090 85%,
          #9B8169 100%);
      border-radius: 4px;
      /* Premium easing: smooth opening with slight bounce for weighty, satisfying feel */
      transition: transform 1.8s cubic-bezier(0.34, 1.18, 0.42, 1);
      position: relative;
      z-index: 2;
      /* Vertical brushed texture */
      background-image:
        linear-gradient(90deg,
          #9B8169 0%, #B8A090 15%, #D0C0B0 30%,
          #B8A090 50%, #A08875 70%, #B8A090 85%, #9B8169 100%),
        repeating-linear-gradient(180deg,
          transparent 0,
          transparent 1px,
          rgba(255, 255, 255, 0.03) 1px,
          rgba(255, 255, 255, 0.03) 2px);
      box-shadow:
        inset 2px 0 4px rgba(255, 255, 255, 0.2),
        inset -2px 0 4px rgba(0, 0, 0, 0.3);
    }

    /* Door handle/indent */
    .door::before {
      content: '';
      position: absolute;
      top: 50%;
      transform: translateY(-50%);
      width: 10px;
      height: 100px;
      background: linear-gradient(90deg, #B8860B 0%, #DAA520 50%, #B8860B 100%);
      border-radius: 3px;
      box-shadow:
        inset 0 1px 2px rgba(255, 255, 255, 0.4),
        0 2px 4px rgba(0, 0, 0, 0.3);
    }

    .door-left::before {
      right: 16px;
    }

    .door-right::before {
      left: 16px;
    }

    /* Door gap indicator line */
    .door::after {
      content: '';
      position: absolute;
      top: 0;
      bottom: 0;
      width: 2px;
      background: linear-gradient(180deg, #3a3028 0%, #4a3f35 50%, #3a3028 100%);
    }

    .door-left::after {
      right: 0;
    }

    .door-right::after {
      left: 0;
    }

    .doors-open .door-left {
      transform: translateX(-98%);
    }

    .doors-open .door-right {
      transform: translateX(98%);
    }

    /* Restaurant/destination view behind doors */
    .door-window {
      position: absolute;
      top: 12px;
      left: 12px;
      right: 12px;
      bottom: 12px;
      border-radius: 4px;
      pointer-events: none;
      opacity: 0;
      transform: scale(1.02);
      transition:
        opacity 0.6s ease 0.15s,
        transform 0.9s ease 0.15s,
        filter 0.9s ease 0.15s;
      display: block;
      z-index: 1;
      /* Warm destination interior glimpse (fallback if no image is set) */
      background:
        linear-gradient(180deg, #FFF8E7 0%, #FFF0D4 50%, #FFE8C4 100%);
      background-size: cover;
      background-position: center;
      background-repeat: no-repeat;
      filter: saturate(1.05) contrast(1.02);
      box-shadow:
        inset 0 0 20px rgba(255, 200, 100, 0.25),
        0 0 18px rgba(255, 220, 150, 0.12);
    }

    .doors-open .door-window {
      opacity: 1;
      transform: scale(1);
    }

    .door-window::after {
      content: '';
      position: absolute;
      inset: 0;
      border-radius: 4px;
      background:
        radial-gradient(ellipse at 50% 30%, rgba(255, 255, 255, 0.22) 0%, rgba(255, 255, 255, 0.06) 45%, rgba(0, 0, 0, 0.10) 100%),
        linear-gradient(180deg, rgba(0, 0, 0, 0.10) 0%, transparent 35%, transparent 65%, rgba(0, 0, 0, 0.18) 100%);
      pointer-events: none;
    }

    /* Subtle whoosh/air effect when doors open */
    .elevator-doors::after {
      content: '';
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      width: 0;
      height: 80%;
      background: radial-gradient(ellipse at center, rgba(255, 255, 255, 0.4) 0%, rgba(255, 255, 255, 0.1) 40%, transparent 70%);
      opacity: 0;
      pointer-events: none;
      z-index: 3;
      transition: none;
    }

    .doors-open.elevator-doors::after {
      animation: door-whoosh 0.9s ease-out forwards;
    }

    @keyframes door-whoosh {
      0% {
        width: 0;
        opacity: 0.8;
      }
      60% {
        width: 100%;
        opacity: 0.3;
      }
      100% {
        width: 120%;
        opacity: 0;
      }
    }

    .elevator-panel {
      width: 160px;
      /* Interior wall-mounted brushed metal panel */
      background:
        linear-gradient(180deg, #A8967B 0%, #C0AE93 20%, #B0A088 80%, #988770 100%);
      border-radius: 12px;
      padding: clamp(0.5rem, 1vh, 1rem);
      display: flex;
      flex-direction: column;
      gap: clamp(0.25rem, 0.5vh, 0.75rem);
      box-shadow:
        0 6px 20px rgba(0, 0, 0, 0.3),
        inset 0 1px 0 rgba(255, 255, 255, 0.3),
        inset 0 -1px 0 rgba(0, 0, 0, 0.2);
      border: 3px solid #6F5E52;
      position: relative;
      align-self: center;
      /* center panel within elevator scene */
    }

    /* Removed small decorative screws (cleaner UI) */
    .elevator-panel::before,
    .elevator-panel::after {
      display: none;
      content: none;
    }

	    .panel-title {
	      font-family: var(--font-display);
	      font-size: 0.85rem;
	      font-weight: 700;
	      color: #4a3f35;
      text-align: center;
      text-transform: uppercase;
      letter-spacing: 0.15em;
      text-shadow: 0 1px 0 rgba(255, 255, 255, 0.3);
      padding-bottom: 8px;
      border-bottom: 1px solid rgba(0, 0, 0, 0.1);
      margin-bottom: 4px;
      position: relative;
    }

    /* Removed decorative icon box (cleaner UI) */
    .panel-title::before {
      display: none;
      content: none;
    }

    .floor-btn {
      width: 100%;
      min-height: 72px;
      /* 3D tactile button */
      background:
        linear-gradient(180deg, #F8F8F8 0%, #E8E8E8 40%, #D8D8D8 100%);
      border: none;
      border-radius: 10px;
      font-family: var(--font-display);
      font-size: 1.1rem;
      font-weight: 700;
      color: var(--text-primary);
      cursor: pointer;
      /* Only transition transform for smooth hover/press, NOT background/box-shadow */
      transition: transform 0.1s ease;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 2px;
      position: relative;
      /* 3D raised effect */
      box-shadow:
        0 4px 0 #A0A0A0,
        0 6px 8px rgba(0, 0, 0, 0.2),
        inset 0 1px 0 rgba(255, 255, 255, 0.8),
        inset 0 -1px 0 rgba(0, 0, 0, 0.1);
    }

    .floor-btn:hover:not(:disabled):not(.active) {
      background: linear-gradient(180deg, #FFFFFF 0%, #F0F0F0 40%, #E0E0E0 100%);
      transform: translateY(-2px) scale(1.02);
      box-shadow:
        0 6px 0 #A0A0A0,
        0 10px 16px rgba(0, 0, 0, 0.28),
        0 0 0 2px rgba(100, 150, 255, 0.2),
        inset 0 1px 0 rgba(255, 255, 255, 0.9),
        inset 0 -1px 0 rgba(0, 0, 0, 0.1);
    }

    .floor-btn:active:not(:disabled) {
      transform: translateY(4px) scale(0.98);
      box-shadow:
        0 1px 0 #A0A0A0,
        0 2px 4px rgba(0, 0, 0, 0.2),
        0 0 12px rgba(100, 150, 255, 0.4),
        inset 0 3px 6px rgba(0, 0, 0, 0.15);
      animation: button-press-ripple 0.6s ease-out;
    }

    @keyframes button-press-ripple {
      0% {
        box-shadow:
          0 1px 0 #A0A0A0,
          0 2px 4px rgba(0, 0, 0, 0.2),
          0 0 0 0px rgba(100, 150, 255, 0.6),
          inset 0 3px 6px rgba(0, 0, 0, 0.15);
      }
      100% {
        box-shadow:
          0 1px 0 #A0A0A0,
          0 2px 4px rgba(0, 0, 0, 0.2),
          0 0 0 20px rgba(100, 150, 255, 0),
          inset 0 3px 6px rgba(0, 0, 0, 0.15);
      }
    }

    .floor-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    /* Keep the selected floor fully lit even while controls are disabled during travel. */
    .floor-btn.active:disabled {
      opacity: 1;
    }

    .floor-btn.active {
      background: linear-gradient(180deg, #FFE566 0%, #FFD93D 40%, #F0C800 100%);
      transform: translateY(1px);
      box-shadow:
        0 3px 0 #C4A000,
        0 6px 12px rgba(255, 217, 102, 0.5),
        0 0 25px rgba(255, 217, 102, 0.4),
        inset 0 1px 0 rgba(255, 255, 255, 0.6),
        inset 0 0 30px rgba(255, 235, 100, 0.3);
      /* Instant highlight - no transition! */
      transition: none;
      animation: button-glow 2s ease-in-out infinite;
      position: relative;
    }

    /* "Ding" indicator for active floor */
    .floor-btn.active::before {
      content: '';
      position: absolute;
      top: -3px;
      right: -3px;
      width: 8px;
      height: 8px;
      background: #00FF88;
      border-radius: 50%;
      box-shadow:
        0 0 8px #00FF88,
        0 0 16px rgba(0, 255, 136, 0.6),
        inset 0 1px 2px rgba(255, 255, 255, 0.8);
      animation: ding-pulse 1.5s ease-in-out infinite;
    }

    @keyframes ding-pulse {
      0%, 100% {
        transform: scale(1);
        opacity: 1;
      }
      50% {
        transform: scale(1.15);
        opacity: 0.85;
      }
    }

    @keyframes button-glow {
      0%, 100% {
        box-shadow:
          0 3px 0 #C4A000,
          0 6px 12px rgba(255, 217, 102, 0.5),
          0 0 25px rgba(255, 217, 102, 0.4),
          inset 0 1px 0 rgba(255, 255, 255, 0.6),
          inset 0 0 30px rgba(255, 235, 100, 0.3);
      }
      50% {
        box-shadow:
          0 3px 0 #C4A000,
          0 6px 16px rgba(255, 217, 102, 0.7),
          0 0 40px rgba(255, 217, 102, 0.6),
          inset 0 1px 0 rgba(255, 255, 255, 0.7),
          inset 0 0 40px rgba(255, 235, 100, 0.5);
      }
    }

    /* Interior button panel indicators */
    .floor-btn::after {
      display: none;
      content: none;
    }

    .floor-btn.active::after {
      display: none;
      content: none;
    }

    .floor-btn .floor-num {
      font-size: 1.5rem;
      text-shadow: 0 1px 0 rgba(255, 255, 255, 0.5);
    }

    .floor-btn .floor-name {
      font-size: 0.65rem;
      color: #666;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    /* Enhanced button press animation for touch devices */
	    @media (hover: none) {
	      .floor-btn:active:not(:disabled) {
	        transform: translateY(5px) scale(0.96);
	        box-shadow:
	          0 1px 0 #A0A0A0,
	          0 2px 4px rgba(0, 0, 0, 0.2),
	          0 0 16px rgba(100, 150, 255, 0.5),
	          inset 0 4px 8px rgba(0, 0, 0, 0.2);
	        animation: button-press-ripple 0.6s ease-out;
	      }
	    }

		    /* ===== ELEVATOR STYLE VARIANTS (10) ===== */
		    /* Each trip applies `.elevator-style-N` to `#elevatorScreen` for variety. */
		    .elevator-screen[class*="elevator-style-"] .elevator-doors::before {
		      content: '';
		      position: absolute;
		      inset: 10px;
		      border-radius: 6px;
		      pointer-events: none;
		      background:
		        linear-gradient(180deg, rgba(255, 255, 255, 0.18) 0%, transparent 35%, transparent 65%, rgba(0, 0, 0, 0.20) 100%),
		        linear-gradient(90deg, rgba(255, 255, 255, 0.12) 0%, transparent 20%, transparent 80%, rgba(0, 0, 0, 0.12) 100%);
		      opacity: 0.9;
		      z-index: 0;
		    }

		    .elevator-screen[class*="elevator-style-"] .elevator-doors::after {
		      content: '';
		      position: absolute;
		      left: 10px;
		      right: 10px;
		      top: 10px;
		      height: 10px;
		      border-radius: 5px;
		      pointer-events: none;
		      background:
		        linear-gradient(180deg, rgba(255, 255, 255, 0.22) 0%, rgba(0, 0, 0, 0.10) 100%),
		        repeating-linear-gradient(90deg, rgba(255, 255, 255, 0.10) 0 8px, rgba(0, 0, 0, 0.10) 8px 12px);
		      opacity: 0.35;
		      z-index: 0;
		    }

		    .elevator-screen[class*="elevator-style-"] .elevator-panel::before {
		      display: block;
		      content: '';
		      position: absolute;
		      inset: 0;
		      border-radius: 12px;
		      pointer-events: none;
		      background:
		        radial-gradient(circle at 12px 12px, rgba(0, 0, 0, 0.32) 0 2px, transparent 3px),
		        radial-gradient(circle at calc(100% - 12px) 12px, rgba(0, 0, 0, 0.32) 0 2px, transparent 3px),
		        radial-gradient(circle at 12px calc(100% - 12px), rgba(0, 0, 0, 0.32) 0 2px, transparent 3px),
		        radial-gradient(circle at calc(100% - 12px) calc(100% - 12px), rgba(0, 0, 0, 0.32) 0 2px, transparent 3px),
		        linear-gradient(180deg, rgba(255, 255, 255, 0.22) 0%, transparent 40%, transparent 70%, rgba(0, 0, 0, 0.18) 100%);
		      opacity: 0.55;
		      z-index: 0;
		    }

		    .elevator-screen[class*="elevator-style-"] .elevator-panel::after {
		      display: block;
		      content: '';
		      position: absolute;
		      inset: 0;
		      border-radius: 12px;
		      pointer-events: none;
		      background:
		        repeating-linear-gradient(180deg, rgba(255, 255, 255, 0.035) 0 1px, transparent 1px 4px);
		      opacity: 0.55;
		      z-index: 0;
		    }

		    .elevator-screen[class*="elevator-style-"] .elevator-panel>* {
		      position: relative;
		      z-index: 1;
		    }

		    		    /* 1 â€” HERITAGE GRAND HOTEL ELEVATOR (Art Nouveau mahogany, aged brass filigree, warm amber luxury) */
		    .elevator-screen.elevator-style-1 {
		      background-image:
		        /* Ornate brass corner details */
		        radial-gradient(circle at 0% 0%, rgba(205, 127, 50, 0.4) 0%, transparent 8%),
		        radial-gradient(circle at 100% 0%, rgba(205, 127, 50, 0.4) 0%, transparent 8%),
		        radial-gradient(circle at 0% 100%, rgba(205, 127, 50, 0.4) 0%, transparent 8%),
		        radial-gradient(circle at 100% 100%, rgba(205, 127, 50, 0.4) 0%, transparent 8%),
		        /* Rich wood grain with depth */
		        repeating-linear-gradient(90deg,
		          #3E1F0F 0px, #4A2415 1px, #5C2E1A 2px, #4A2415 3px,
		          #3E1F0F 4px, #5C2E1A 5px, #6D3920 7px, #5C2E1A 8px,
		          #4A2415 10px, #3E1F0F 12px, #5C2E1A 15px, #4A2415 18px,
		          #3E1F0F 20px, #6D3920 25px, #5C2E1A 30px),
		        /* Vertical wood grain variation */
		        repeating-linear-gradient(0deg,
		          transparent 0, transparent 60px,
		          rgba(139, 69, 19, 0.15) 60px, rgba(205, 127, 50, 0.1) 62px,
		          transparent 62px, transparent 140px,
		          rgba(92, 46, 26, 0.2) 140px, rgba(62, 31, 15, 0.15) 142px),
		        /* Wood marquetry pattern */
		        repeating-linear-gradient(45deg,
		          transparent 0, transparent 80px,
		          rgba(205, 127, 50, 0.08) 80px, rgba(205, 127, 50, 0.08) 82px),
		        repeating-linear-gradient(-45deg,
		          transparent 0, transparent 80px,
		          rgba(205, 127, 50, 0.08) 80px, rgba(205, 127, 50, 0.08) 82px),
		        /* Base mahogany gradient */
		        linear-gradient(180deg, #3E1F0F 0%, #5C2E1A 20%, #4A2415 50%, #6D3920 80%, #3E1F0F 100%);
		    }

		    .elevator-screen.elevator-style-1 .elevator-shaft {
		      border-color: #CD7F32;
		      border-width: 6px;
		      border-style: double;
		      border-radius: 120px 120px 0 0 / 60px 60px 0 0;
		      background-image:
		        /* Brass ornamental border inlay */
		        linear-gradient(90deg, transparent 0%, transparent 2%, rgba(205, 127, 50, 0.3) 2%, rgba(184, 134, 11, 0.2) 3%, transparent 3%, transparent 97%, rgba(205, 127, 50, 0.3) 97%, rgba(184, 134, 11, 0.2) 98%, transparent 98%),
		        /* Deep mahogany shaft with polish */
		        linear-gradient(135deg, #2C1810 0%, #3E2723 15%, #4E342E 30%, #3E2723 50%, #5D4037 70%, #4E342E 85%, #2C1810 100%),
		        /* Vertical wood planks */
		        repeating-linear-gradient(90deg,
		          #3E2723 0, #3E2723 80px,
		          #2C1810 80px, #2C1810 82px,
		          #4E342E 82px, #4E342E 160px),
		        /* Subtle grain detail */
		        repeating-linear-gradient(180deg,
		          transparent 0 15px,
		          rgba(205, 127, 50, 0.08) 15px 16px,
		          transparent 16px 35px,
		          rgba(184, 134, 11, 0.12) 35px 37px),
		        /* Warm ambient glow from top */
		        radial-gradient(ellipse at 50% 0%, rgba(255, 223, 128, 0.35) 0%, rgba(205, 127, 50, 0.15) 30%, transparent 70%);
		      box-shadow:
		        inset 0 0 60px rgba(62, 31, 15, 0.8),
		        inset 0 0 30px rgba(205, 127, 50, 0.2),
		        inset 3px 0 12px rgba(0, 0, 0, 0.6),
		        inset -3px 0 12px rgba(0, 0, 0, 0.6),
		        0 12px 40px rgba(0, 0, 0, 0.7),
		        0 0 25px rgba(205, 127, 50, 0.15);
		    }

		    .elevator-screen.elevator-style-1 .elevator-shaft::before,
		    .elevator-screen.elevator-style-1 .elevator-shaft::after {
		      border-color: #B8860B;
		      border-width: 4px;
		      border-style: ridge;
		      filter: drop-shadow(0 3px 6px rgba(139, 69, 19, 0.6)) drop-shadow(0 0 12px rgba(205, 127, 50, 0.3));
		    }

		    .elevator-screen.elevator-style-1 .elevator-shaft>*:first-child::before {
		      background: radial-gradient(ellipse at center, rgba(255, 223, 128, 0.95) 0%, rgba(255, 215, 100, 0.6) 35%, rgba(255, 200, 87, 0.30) 65%, rgba(205, 127, 50, 0.1) 85%, transparent 100%);
		    }

		    .elevator-screen.elevator-style-1 .elevator-doors {
		      border-radius: 100px 100px 0 0 / 50px 50px 0 0;
		      background:
		        /* Brass threshold strip */
		        linear-gradient(0deg, #CD7F32 0%, #B8860B 1%, transparent 1%, transparent 99%, #B8860B 99%, #CD7F32 100%),
		        /* Dark wood frame */
		        linear-gradient(180deg, #1C0F0A 0%, #2C1810 5%, #3E2723 10%, #2C1810 90%, #1C0F0A 100%),
		        /* Subtle brass accents */
		        repeating-linear-gradient(90deg, rgba(205, 127, 50, 0.15) 0 15px, transparent 15px 35px);
		    }

		    .elevator-screen.elevator-style-1 .door {
		      border-radius: 40px 40px 0 0 / 20px 20px 0 0;
		      background-image:
		        /* Brass handle plate (center vertical strip) */
		        linear-gradient(90deg, transparent 0%, transparent 48%, rgba(205, 127, 50, 0.6) 48%, rgba(184, 134, 11, 0.8) 49%, rgba(205, 127, 50, 0.9) 50%, rgba(184, 134, 11, 0.8) 51%, rgba(205, 127, 50, 0.6) 52%, transparent 52%),
		        /* Rich wood panel with depth */
		        linear-gradient(90deg, #2C1810 0%, #3E2723 8%, #5D4037 18%, #4E342E 30%, #6D4C41 50%, #4E342E 70%, #5D4037 82%, #3E2723 92%, #2C1810 100%),
		        /* Intricate vertical wood grain */
		        repeating-linear-gradient(180deg,
		          rgba(62, 31, 15, 0.5) 0 1px,
		          transparent 1px 6px,
		          rgba(205, 127, 50, 0.15) 6px 7px,
		          transparent 7px 12px,
		          rgba(92, 46, 26, 0.3) 12px 13px,
		          transparent 13px 20px),
		        /* Horizontal grain variation */
		        repeating-linear-gradient(90deg,
		          transparent 0 40px,
		          rgba(205, 127, 50, 0.08) 40px 41px,
		          transparent 41px 90px),
		        /* Wood polish sheen */
		        radial-gradient(ellipse at 50% 30%, rgba(205, 127, 50, 0.25) 0%, rgba(139, 90, 43, 0.15) 40%, transparent 70%);
		      border-left: 3px solid rgba(205, 127, 50, 0.5);
		      border-right: 3px solid rgba(205, 127, 50, 0.5);
		      box-shadow: inset 0 0 20px rgba(62, 31, 15, 0.6), inset 0 0 40px rgba(0, 0, 0, 0.3);
		    }

		    .elevator-screen.elevator-style-1 .elevator-panel {
		      border-color: #CD7F32;
		      border-width: 5px;
		      border-style: ridge;
		      background:
		        /* Ornate brass frame edge */
		        linear-gradient(90deg, rgba(205, 127, 50, 0.4) 0%, transparent 3%, transparent 97%, rgba(205, 127, 50, 0.4) 100%),
		        linear-gradient(0deg, rgba(205, 127, 50, 0.4) 0%, transparent 3%, transparent 97%, rgba(205, 127, 50, 0.4) 100%),
		        /* Polished brass panel */
		        linear-gradient(135deg, #A0826D 0%, #C9A56E 15%, #B8956F 30%, #8B7355 50%, #B8956F 70%, #C9A56E 85%, #A0826D 100%),
		        /* Brushed metal texture */
		        repeating-linear-gradient(90deg, rgba(205, 127, 50, 0.2) 0 1px, rgba(139, 69, 19, 0.1) 1px 2px, transparent 2px 8px),
		        /* Radial polish highlight */
		        radial-gradient(ellipse at 50% 30%, rgba(255, 223, 128, 0.3) 0%, transparent 60%);
		      box-shadow:
		        inset 0 3px 12px rgba(205, 127, 50, 0.4),
		        inset 0 -3px 12px rgba(62, 31, 15, 0.5),
		        0 6px 20px rgba(0, 0, 0, 0.6),
		        0 0 20px rgba(205, 127, 50, 0.2);
		    }

		    .elevator-screen.elevator-style-1 .floor-display {
		      color: #FFD700;
		      background:
		        /* Aged brass bezel */
		        linear-gradient(0deg, rgba(139, 69, 19, 0.6) 0%, rgba(62, 31, 15, 0.8) 100%),
		        linear-gradient(180deg, #0D0805 0%, #1C0F0A 20%, #2C1810 50%, #1C0F0A 80%, #0D0805 100%);
		      border: 4px ridge #B8860B;
		      text-shadow:
		        0 0 25px rgba(255, 215, 0, 1),
		        0 0 40px rgba(255, 215, 0, 0.8),
		        0 0 60px rgba(255, 215, 0, 0.5),
		        0 3px 8px rgba(0, 0, 0, 0.9);
		      box-shadow:
		        inset 0 0 30px rgba(62, 31, 15, 0.9),
		        inset 0 0 15px rgba(139, 69, 19, 0.6),
		        0 0 40px rgba(255, 215, 0, 0.4),
		        0 0 20px rgba(205, 127, 50, 0.3);
		      font-weight: 700;
		    }

		    		    /* 2 â€” QUANTUM SPACECRAFT ELEVATOR (holographic HUD, plasma energy, cyberpunk neon, hard sci-fi tech) */
		    @keyframes holographic-scan {
		      0%, 100% { background-position: 0% 0%; opacity: 0.6; }
		      50% { background-position: 0% 100%; opacity: 1; }
		    }
		    @keyframes energy-pulse {
		      0%, 100% { opacity: 0.4; filter: brightness(1); }
		      50% { opacity: 1; filter: brightness(1.5); }
		    }
		    @keyframes grid-flicker {
		      0%, 100% { opacity: 0.8; }
		      25% { opacity: 1; }
		      75% { opacity: 0.6; }
		    }

		    .elevator-screen.elevator-style-2 {
		      background-image:
		        /* Holographic corner HUD elements */
		        radial-gradient(circle at 0% 0%, rgba(0, 191, 255, 0.4) 0%, rgba(59, 130, 246, 0.2) 5%, transparent 10%),
		        radial-gradient(circle at 100% 0%, rgba(0, 191, 255, 0.4) 0%, rgba(59, 130, 246, 0.2) 5%, transparent 10%),
		        radial-gradient(circle at 0% 100%, rgba(0, 191, 255, 0.4) 0%, rgba(59, 130, 246, 0.2) 5%, transparent 10%),
		        radial-gradient(circle at 100% 100%, rgba(0, 191, 255, 0.4) 0%, rgba(59, 130, 246, 0.2) 5%, transparent 10%),
		        /* Energy grid - vertical lines */
		        repeating-linear-gradient(90deg,
		          transparent 0, transparent 3px,
		          rgba(0, 191, 255, 0.6) 3px, rgba(59, 130, 246, 0.8) 4px, rgba(0, 191, 255, 0.6) 5px,
		          transparent 5px, transparent 50px),
		        /* Energy grid - horizontal lines */
		        repeating-linear-gradient(0deg,
		          transparent 0, transparent 50px,
		          rgba(59, 130, 246, 0.3) 50px, rgba(0, 191, 255, 0.5) 51px, rgba(59, 130, 246, 0.3) 52px,
		          transparent 52px, transparent 102px),
		        /* Plasma glow from top */
		        radial-gradient(ellipse at 50% 0%, rgba(0, 191, 255, 0.25) 0%, rgba(59, 130, 246, 0.15) 30%, transparent 60%),
		        /* Deep space black */
		        linear-gradient(180deg, #020817 0%, #0A0F1E 30%, #0F172A 50%, #0A0F1E 70%, #020817 100%);
		      animation: grid-flicker 4s ease-in-out infinite;
		    }

		    .elevator-screen.elevator-style-2 .elevator-shaft {
		      border-color: #00BFFF;
		      border-width: 3px;
		      border-style: solid;
		      max-width: 550px;
		      aspect-ratio: 2.2 / 1;
		      background-image:
		        /* Holographic scan lines */
		        repeating-linear-gradient(0deg,
		          transparent 0, transparent 2px,
		          rgba(0, 191, 255, 0.15) 2px, rgba(0, 191, 255, 0.15) 3px,
		          transparent 3px, transparent 8px),
		        /* Energy conduits - vertical */
		        repeating-linear-gradient(90deg,
		          transparent 0, transparent 60px,
		          rgba(0, 191, 255, 0.3) 60px, rgba(59, 130, 246, 0.5) 62px, rgba(0, 191, 255, 0.3) 64px,
		          transparent 64px, transparent 124px),
		        /* Brushed titanium base */
		        linear-gradient(135deg, #475569 0%, #64748B 20%, #94A3B8 40%, #CBD5E1 50%, #94A3B8 60%, #64748B 80%, #475569 100%),
		        /* Metallic highlights */
		        linear-gradient(90deg, rgba(248, 250, 252, 0.1) 0%, transparent 2%, transparent 98%, rgba(248, 250, 252, 0.1) 100%),
		        /* Plasma energy glow */
		        radial-gradient(ellipse at 50% 0%, rgba(0, 191, 255, 0.5) 0%, rgba(59, 130, 246, 0.3) 25%, transparent 60%);
		      background-size: 100% 100%, 100% 100%, 100% 100%, 100% 100%, 100% 200%;
		      box-shadow:
		        inset 0 0 80px rgba(0, 191, 255, 0.3),
		        inset 0 0 40px rgba(59, 130, 246, 0.2),
		        0 0 60px rgba(0, 191, 255, 0.4),
		        0 0 30px rgba(59, 130, 246, 0.3),
		        0 15px 40px rgba(0, 0, 0, 0.8);
		      animation: holographic-scan 3s ease-in-out infinite;
		    }

		    .elevator-screen.elevator-style-2 .elevator-shaft::before,
		    .elevator-screen.elevator-style-2 .elevator-shaft::after {
		      border-color: #00BFFF;
		      border-width: 3px;
		      border-style: solid;
		      box-shadow:
		        0 0 20px rgba(0, 191, 255, 1),
		        0 0 40px rgba(59, 130, 246, 0.8),
		        0 0 60px rgba(0, 191, 255, 0.5);
		      animation: energy-pulse 2s ease-in-out infinite;
		    }

		    .elevator-screen.elevator-style-2 .elevator-shaft>.floor-display::after {
		      background: linear-gradient(90deg, #00BFFF 0%, #3B82F6 25%, #60A5FA 50%, #3B82F6 75%, #00BFFF 100%);
		      animation: energy-pulse 2.5s ease-in-out infinite;
		    }

		    .elevator-screen.elevator-style-2 .elevator-shaft>*:first-child::before {
		      background: radial-gradient(ellipse at center, rgba(0, 191, 255, 1) 0%, rgba(96, 165, 250, 0.8) 35%, rgba(59, 130, 246, 0.4) 60%, rgba(0, 191, 255, 0.1) 80%, transparent 100%);
		    }

		    .elevator-screen.elevator-style-2 .elevator-doors {
		      flex-direction: column;
		      background:
		        /* HUD interface lines */
		        repeating-linear-gradient(90deg,
		          transparent 0, transparent 10px,
		          rgba(0, 191, 255, 0.1) 10px, rgba(0, 191, 255, 0.1) 11px),
		        /* Energy threshold */
		        linear-gradient(90deg, rgba(0, 191, 255, 0.3) 0%, rgba(0, 191, 255, 0.1) 2%, transparent 2%, transparent 98%, rgba(0, 191, 255, 0.1) 98%, rgba(0, 191, 255, 0.3) 100%),
		        /* Deep space frame */
		        linear-gradient(180deg, #020817 0%, #0A0F1E 20%, #0F172A 50%, #0A0F1E 80%, #020817 100%),
		        /* Ambient plasma glow */
		        radial-gradient(circle at 50% 50%, rgba(0, 191, 255, 0.15) 0%, transparent 70%);
		    }

		    .elevator-screen.elevator-style-2 .door {
		      width: 100%;
		      height: calc(50% - 3px);
		      background-image:
		        /* Central energy strip (now horizontal for airlock style) */
		        linear-gradient(180deg, transparent 0%, transparent 49%, rgba(0, 191, 255, 0.8) 49%, rgba(0, 191, 255, 1) 50%, rgba(0, 191, 255, 0.8) 51%, transparent 51%),
		        /* Vertical HUD lines */
		        linear-gradient(90deg,
		          transparent 0%, transparent 33%,
		          rgba(59, 130, 246, 0.4) 33%, rgba(0, 191, 255, 0.6) 34%, rgba(59, 130, 246, 0.4) 35%,
		          transparent 35%, transparent 66%,
		          rgba(59, 130, 246, 0.4) 66%, rgba(0, 191, 255, 0.6) 67%, rgba(59, 130, 246, 0.4) 68%,
		          transparent 68%, transparent 100%),
		        /* Brushed chrome surface (rotated orientation) */
		        linear-gradient(180deg, #64748B 0%, #94A3B8 15%, #CBD5E1 30%, #F8FAFC 50%, #CBD5E1 70%, #94A3B8 85%, #64748B 100%),
		        /* Micro-texture */
		        repeating-linear-gradient(180deg, rgba(248, 250, 252, 0.15) 0 1px, transparent 1px 6px),
		        /* Holographic sheen */
		        radial-gradient(ellipse at 50% 50%, rgba(0, 191, 255, 0.2) 0%, transparent 70%);
		      border-top: 2px solid rgba(0, 191, 255, 0.6);
		      border-bottom: 2px solid rgba(0, 191, 255, 0.6);
		      box-shadow:
		        inset 0 0 30px rgba(0, 191, 255, 0.2),
		        inset 0 0 60px rgba(0, 0, 0, 0.3);
		    }

		    .elevator-screen.elevator-style-2 .doors-open .door-left {
		      transform: translateY(-98%);
		    }

		    .elevator-screen.elevator-style-2 .doors-open .door-right {
		      transform: translateY(98%);
		    }

		    .elevator-screen.elevator-style-2 .elevator-panel {
		      border-color: #00BFFF;
		      border-width: 3px;
		      border-style: solid;
		      background:
		        /* HUD grid pattern */
		        repeating-linear-gradient(90deg,
		          transparent 0, transparent 10px,
		          rgba(0, 191, 255, 0.1) 10px, rgba(0, 191, 255, 0.1) 11px),
		        repeating-linear-gradient(0deg,
		          transparent 0, transparent 10px,
		          rgba(0, 191, 255, 0.08) 10px, rgba(0, 191, 255, 0.08) 11px),
		        /* Carbon fiber texture */
		        linear-gradient(135deg, #1E293B 0%, #334155 30%, #475569 50%, #334155 70%, #1E293B 100%),
		        /* Tech panel glow */
		        radial-gradient(circle at 50% 0%, rgba(0, 191, 255, 0.4) 0%, rgba(59, 130, 246, 0.2) 40%, transparent 80%);
		      box-shadow:
		        inset 0 0 40px rgba(0, 191, 255, 0.3),
		        inset 0 2px 10px rgba(0, 191, 255, 0.2),
		        0 0 30px rgba(0, 191, 255, 0.4),
		        0 5px 20px rgba(0, 0, 0, 0.7);
		    }

		    .elevator-screen.elevator-style-2 .floor-display {
		      color: #00BFFF;
		      background:
		        /* Holographic display texture */
		        repeating-linear-gradient(0deg,
		          rgba(0, 191, 255, 0.05) 0, rgba(0, 191, 255, 0.05) 1px,
		          transparent 1px, transparent 2px),
		        /* Deep display void */
		        linear-gradient(180deg, #020817 0%, #0A0F1E 40%, #0F172A 60%, #0A0F1E 100%);
		      border: 3px solid #00BFFF;
		      text-shadow:
		        0 0 25px rgba(0, 191, 255, 1),
		        0 0 40px rgba(0, 191, 255, 0.9),
		        0 0 60px rgba(59, 130, 246, 0.7),
		        0 0 80px rgba(59, 130, 246, 0.5),
		        0 2px 10px rgba(0, 0, 0, 1);
		      box-shadow:
		        inset 0 0 40px rgba(2, 8, 23, 1),
		        inset 0 0 20px rgba(0, 191, 255, 0.3),
		        0 0 50px rgba(0, 191, 255, 0.6),
		        0 0 30px rgba(59, 130, 246, 0.5),
		        0 0 80px rgba(0, 191, 255, 0.3);
		      font-weight: 700;
		      animation: energy-pulse 3s ease-in-out infinite;
		    }

		    		    /* 3 â€” INDUSTRIAL FREIGHT ELEVATOR (riveted steel plates, hazard stripes, concrete bunker, warning signage) */
		    .elevator-screen.elevator-style-3 {
		      background-image:
		        /* Rivet holes in corners */
		        radial-gradient(circle at 15px 15px, #000000 0 4px, rgba(0, 0, 0, 0.8) 4px 6px, transparent 7px),
		        radial-gradient(circle at calc(100% - 15px) 15px, #000000 0 4px, rgba(0, 0, 0, 0.8) 4px 6px, transparent 7px),
		        radial-gradient(circle at 15px calc(100% - 15px), #000000 0 4px, rgba(0, 0, 0, 0.8) 4px 6px, transparent 7px),
		        radial-gradient(circle at calc(100% - 15px) calc(100% - 15px), #000000 0 4px, rgba(0, 0, 0, 0.8) 4px 6px, transparent 7px),
		        /* Caution stripe border (refined diagonal pattern) */
		        repeating-linear-gradient(45deg,
		          #FBBF24 0px, #FBBF24 25px,
		          #1C1917 25px, #1C1917 50px),
		        /* Industrial metal plate texture */
		        linear-gradient(135deg, #374151 0%, #4B5563 30%, #6B7280 50%, #4B5563 70%, #374151 100%),
		        /* Weathered steel scratches */
		        repeating-linear-gradient(105deg,
		          transparent 0, transparent 80px,
		          rgba(107, 114, 128, 0.3) 80px, rgba(107, 114, 128, 0.3) 82px);
		      background-size: 100% 100%, 100% 100%, 100% 100%, 100% 100%, 71px 71px, 100% 100%, 100% 100%;
		    }

		    .elevator-screen.elevator-style-3 .elevator-shaft {
		      border-color: #FBBF24;
		      border-width: 8px;
		      border-style: double;
		      max-width: 280px;
		      min-height: 550px;
		      background-image:
		        /* Rivet pattern - left edge */
		        radial-gradient(circle at 12px 15px, #0A0A0A 0 3px, rgba(75, 85, 99, 0.8) 3px 4px, rgba(107, 114, 128, 0.6) 4px 5px, transparent 6px),
		        radial-gradient(circle at 12px 55px, #0A0A0A 0 3px, rgba(75, 85, 99, 0.8) 3px 4px, rgba(107, 114, 128, 0.6) 4px 5px, transparent 6px),
		        radial-gradient(circle at 12px 95px, #0A0A0A 0 3px, rgba(75, 85, 99, 0.8) 3px 4px, rgba(107, 114, 128, 0.6) 4px 5px, transparent 6px),
		        /* Rivet pattern - right edge */
		        radial-gradient(circle at calc(100% - 12px) 15px, #0A0A0A 0 3px, rgba(75, 85, 99, 0.8) 3px 4px, rgba(107, 114, 128, 0.6) 4px 5px, transparent 6px),
		        radial-gradient(circle at calc(100% - 12px) 55px, #0A0A0A 0 3px, rgba(75, 85, 99, 0.8) 3px 4px, rgba(107, 114, 128, 0.6) 4px 5px, transparent 6px),
		        radial-gradient(circle at calc(100% - 12px) 95px, #0A0A0A 0 3px, rgba(75, 85, 99, 0.8) 3px 4px, rgba(107, 114, 128, 0.6) 4px 5px, transparent 6px),
		        /* Steel plate seams */
		        repeating-linear-gradient(0deg,
		          transparent 0, transparent 80px,
		          rgba(31, 41, 55, 0.8) 80px, rgba(17, 24, 39, 1) 82px, rgba(31, 41, 55, 0.8) 84px,
		          transparent 84px, transparent 164px),
		        /* Concrete texture base */
		        linear-gradient(135deg, #1F2937 0%, #374151 20%, #4B5563 40%, #374151 60%, #1F2937 80%, #111827 100%),
		        /* Vertical steel panels */
		        repeating-linear-gradient(90deg,
		          transparent 0, transparent 100px,
		          rgba(75, 85, 99, 0.3) 100px, rgba(75, 85, 99, 0.3) 102px),
		        /* Industrial grime */
		        repeating-linear-gradient(125deg,
		          transparent 0, transparent 40px,
		          rgba(31, 41, 55, 0.4) 40px, rgba(31, 41, 55, 0.4) 42px);
		      background-size: 100% 40px, 100% 40px, 100% 40px, 100% 40px, 100% 40px, 100% 40px, 100% 100%, 100% 100%, 100% 100%, 100% 100%;
		      box-shadow:
		        inset 0 0 60px rgba(0, 0, 0, 0.8),
		        inset 5px 0 15px rgba(0, 0, 0, 0.7),
		        inset -5px 0 15px rgba(0, 0, 0, 0.7),
		        0 15px 50px rgba(0, 0, 0, 0.9);
		    }

		    .elevator-screen.elevator-style-3 .elevator-shaft::before,
		    .elevator-screen.elevator-style-3 .elevator-shaft::after {
		      border-color: #FBBF24;
		      border-width: 6px;
		      border-style: double;
		      filter: drop-shadow(0 0 12px rgba(251, 191, 36, 0.8)) drop-shadow(0 3px 8px rgba(0, 0, 0, 0.9));
		    }

		    .elevator-screen.elevator-style-3 .elevator-shaft>*:first-child::before {
		      background: radial-gradient(ellipse at center, rgba(251, 146, 60, 1) 0%, rgba(245, 158, 11, 0.7) 35%, rgba(251, 191, 36, 0.4) 60%, rgba(234, 88, 12, 0.15) 80%, transparent 100%);
		    }

		    .elevator-screen.elevator-style-3 .elevator-doors {
		      background:
		        /* Warning stripe at threshold */
		        repeating-linear-gradient(45deg,
		          transparent 0, transparent 3px,
		          #FBBF24 3px, #FBBF24 8px,
		          #1C1917 8px, #1C1917 13px,
		          transparent 13px, transparent 16px),
		        linear-gradient(0deg, rgba(251, 191, 36, 0.2) 0%, transparent 3%, transparent 97%, rgba(251, 191, 36, 0.2) 100%),
		        /* Concrete frame */
		        linear-gradient(180deg, #111827 0%, #1F2937 20%, #374151 50%, #1F2937 80%, #111827 100%),
		        /* Industrial wear marks */
		        repeating-linear-gradient(90deg,
		          transparent 0 30px,
		          rgba(75, 85, 99, 0.2) 30px 32px);
		    }

		    .elevator-screen.elevator-style-3 .door {
		      width: 100%;
		      background-image:
		        /* Rivet grid pattern */
		        radial-gradient(circle at 15px 20px, #0A0A0A 0 3px, rgba(75, 85, 99, 0.8) 3px 4px, transparent 5px),
		        radial-gradient(circle at 15px 70px, #0A0A0A 0 3px, rgba(75, 85, 99, 0.8) 3px 4px, transparent 5px),
		        radial-gradient(circle at 15px 120px, #0A0A0A 0 3px, rgba(75, 85, 99, 0.8) 3px 4px, transparent 5px),
		        radial-gradient(circle at calc(100% - 15px) 20px, #0A0A0A 0 3px, rgba(75, 85, 99, 0.8) 3px 4px, transparent 5px),
		        radial-gradient(circle at calc(100% - 15px) 70px, #0A0A0A 0 3px, rgba(75, 85, 99, 0.8) 3px 4px, transparent 5px),
		        radial-gradient(circle at calc(100% - 15px) 120px, #0A0A0A 0 3px, rgba(75, 85, 99, 0.8) 3px 4px, transparent 5px),
		        /* Caution stripes (horizontal) */
		        repeating-linear-gradient(0deg,
		          transparent 0, transparent 60px,
		          rgba(251, 191, 36, 0.25) 60px, rgba(251, 191, 36, 0.25) 65px,
		          rgba(28, 25, 23, 0.6) 65px, rgba(28, 25, 23, 0.6) 70px,
		          transparent 70px, transparent 130px),
		        /* Heavy steel plate */
		        linear-gradient(90deg, #374151 0%, #4B5563 15%, #6B7280 30%, #4B5563 50%, #6B7280 70%, #4B5563 85%, #374151 100%),
		        /* Weathered texture */
		        repeating-linear-gradient(95deg,
		          transparent 0, transparent 50px,
		          rgba(31, 41, 55, 0.4) 50px, rgba(31, 41, 55, 0.4) 52px),
		        /* Rust stains */
		        linear-gradient(175deg, transparent 0 30%, rgba(180, 83, 9, 0.15) 30% 40%, transparent 40% 100%);
		      background-size: 100% 100%, 100% 100%, 100% 100%, 100% 100%, 100% 100%, 100% 100%, 100% 100%, 100% 100%, 100% 100%, 100% 100%;
		      border-left: 4px solid rgba(251, 191, 36, 0.5);
		      border-right: 4px solid rgba(251, 191, 36, 0.5);
		      box-shadow:
		        inset 0 0 30px rgba(0, 0, 0, 0.7),
		        inset 0 0 60px rgba(31, 41, 55, 0.5);
		    }

		    .elevator-screen.elevator-style-3 .door-right {
		      display: none;
		    }

		    .elevator-screen.elevator-style-3 .doors-open .door-left {
		      transform: translateX(-98%);
		    }

		    .elevator-screen.elevator-style-3 .elevator-panel {
		      border-color: #FBBF24;
		      border-width: 6px;
		      border-style: double;
		      background:
		        /* Rivet corners */
		        radial-gradient(circle at 10px 10px, #0A0A0A 0 3px, rgba(75, 85, 99, 0.8) 3px 4px, transparent 5px),
		        radial-gradient(circle at calc(100% - 10px) 10px, #0A0A0A 0 3px, rgba(75, 85, 99, 0.8) 3px 4px, transparent 5px),
		        radial-gradient(circle at 10px calc(100% - 10px), #0A0A0A 0 3px, rgba(75, 85, 99, 0.8) 3px 4px, transparent 5px),
		        radial-gradient(circle at calc(100% - 10px) calc(100% - 10px), #0A0A0A 0 3px, rgba(75, 85, 99, 0.8) 3px 4px, transparent 5px),
		        /* Warning stripe edge */
		        repeating-linear-gradient(45deg,
		          rgba(251, 191, 36, 0.2) 0, rgba(251, 191, 36, 0.2) 3px,
		          rgba(28, 25, 23, 0.3) 3px, rgba(28, 25, 23, 0.3) 6px),
		        /* Heavy steel panel */
		        linear-gradient(180deg, #111827 0%, #1F2937 20%, #374151 50%, #1F2937 80%, #111827 100%),
		        /* Brushed metal texture */
		        repeating-linear-gradient(90deg,
		          rgba(75, 85, 99, 0.2) 0 1px,
		          transparent 1px 8px);
		      box-shadow:
		        inset 0 0 40px rgba(0, 0, 0, 0.9),
		        inset 0 5px 15px rgba(0, 0, 0, 0.7),
		        0 6px 20px rgba(0, 0, 0, 0.8);
		    }

		    .elevator-screen.elevator-style-3 .panel-title {
		      color: #FBBF24;
		      text-shadow:
		        0 0 10px rgba(251, 191, 36, 0.5),
		        0 3px 6px rgba(0, 0, 0, 0.9),
		        0 1px 0 rgba(0, 0, 0, 1);
		      font-weight: 900;
		      text-transform: uppercase;
		      letter-spacing: 0.15em;
		    }

		    .elevator-screen.elevator-style-3 .floor-display {
		      color: #FB923C;
		      background:
		        /* LED matrix texture */
		        repeating-linear-gradient(0deg,
		          rgba(245, 158, 11, 0.05) 0, rgba(245, 158, 11, 0.05) 2px,
		          transparent 2px, transparent 4px),
		        /* Dark display background */
		        linear-gradient(180deg, #0A0A0A 0%, #111827 30%, #1F2937 50%, #111827 70%, #0A0A0A 100%);
		      border: 6px double #FBBF24;
		      text-shadow:
		        0 0 30px rgba(251, 146, 60, 1),
		        0 0 50px rgba(245, 158, 11, 0.9),
		        0 0 70px rgba(251, 191, 36, 0.6),
		        0 3px 10px rgba(0, 0, 0, 1);
		      box-shadow:
		        inset 0 0 35px rgba(0, 0, 0, 1),
		        inset 0 0 20px rgba(31, 41, 55, 0.8),
		        0 0 50px rgba(245, 158, 11, 0.6),
		        0 0 25px rgba(251, 191, 36, 0.4);
		      font-weight: 900;
		    }

		    		    /* 4 â€” 1920s MANHATTAN ART DECO (Gatsby skyscraper: sunburst, chevron, brass, black lacquer) */
	    .elevator-screen.elevator-style-4 {
	      background-image:
	        repeating-conic-gradient(from 0deg at 50% 50%,
	          #000000 0deg 3deg,
	          #1a1410 3deg 6deg,
	          #000000 6deg 9deg,
	          #D4AF37 9deg 10deg,
	          #000000 10deg 13deg,
	          #1a1410 13deg 16deg,
	          #000000 16deg 18deg),
	        repeating-linear-gradient(135deg,
	          transparent 0 20px,
	          rgba(212, 175, 55, 0.15) 20px 22px,
	          transparent 22px 42px,
	          rgba(212, 175, 55, 0.08) 42px 43px,
	          transparent 43px 63px),
	        repeating-linear-gradient(-135deg,
	          transparent 0 20px,
	          rgba(212, 175, 55, 0.15) 20px 22px,
	          transparent 22px 42px,
	          rgba(212, 175, 55, 0.08) 42px 43px,
	          transparent 43px 63px),
	        linear-gradient(180deg, #0a0a0a 0%, #1a1410 50%, #000000 100%);
	      background-size: 300px 300px, 100% 100%, 100% 100%, 100% 100%;
	      background-position: center center, 0 0, 0 0, 0 0;
	    }

	    .elevator-screen.elevator-style-4 .elevator-shaft {
	      border: 5px solid transparent;
	      border-image: linear-gradient(180deg, #F4E4B7 0%, #D4AF37 50%, #B8860B 100%) 1;
	      /* Octagonal Art Deco shape - Manhattan skyscraper geometry */
	      clip-path: polygon(15% 0%, 85% 0%, 100% 15%, 100% 85%, 85% 100%, 15% 100%, 0% 85%, 0% 15%);
	      background-image:
	        linear-gradient(90deg,
	          #000000 0%, #D4AF37 2%, #F4E4B7 3%, #D4AF37 4%, #000000 6%,
	          #1a1410 6%, #1a1410 94%,
	          #000000 94%, #D4AF37 96%, #F4E4B7 97%, #D4AF37 98%, #000000 100%),
	        repeating-linear-gradient(0deg,
	          transparent 0 40px,
	          rgba(212, 175, 55, 0.4) 40px 41px,
	          rgba(244, 228, 183, 0.3) 41px 42px,
	          rgba(212, 175, 55, 0.4) 42px 43px,
	          transparent 43px 83px),
	        radial-gradient(ellipse 200px 80px at 50% -20px,
	          rgba(244, 228, 183, 0.3) 0%,
	          rgba(212, 175, 55, 0.15) 40%,
	          transparent 80%),
	        linear-gradient(180deg, #0a0a0a 0%, #1a1410 50%, #0a0a0a 100%);
	      box-shadow:
	        inset 0 0 60px rgba(212, 175, 55, 0.25),
	        inset 0 4px 20px rgba(0, 0, 0, 0.9),
	        0 10px 40px rgba(0, 0, 0, 0.9),
	        0 0 60px rgba(212, 175, 55, 0.2);
	    }

	    .elevator-screen.elevator-style-4 .elevator-shaft::before,
	    .elevator-screen.elevator-style-4 .elevator-shaft::after {
	      border: 3px solid transparent;
	      border-image: linear-gradient(90deg, #D4AF37 0%, #F4E4B7 50%, #D4AF37 100%) 1;
	      filter: drop-shadow(0 0 8px rgba(212, 175, 55, 0.6)) drop-shadow(0 2px 4px rgba(0, 0, 0, 0.8));
	    }

	    .elevator-screen.elevator-style-4 .elevator-shaft>*:first-child::before {
	      background: radial-gradient(ellipse at center,
	        rgba(255, 220, 120, 0.95) 0%,
	        rgba(244, 228, 183, 0.7) 30%,
	        rgba(212, 175, 55, 0.4) 60%,
	        transparent 100%);
	      filter: drop-shadow(0 0 20px rgba(212, 175, 55, 0.8));
	    }

	    .elevator-screen.elevator-style-4 .elevator-doors {
	      /* Adjusted positioning to fit within octagonal shape */
	      margin: 8% 5%;
	      background:
	        linear-gradient(90deg, #D4AF37 0%, #000000 1%, #000000 99%, #D4AF37 100%),
	        linear-gradient(180deg, #D4AF37 0%, #000000 2%, #000000 98%, #D4AF37 100%),
	        linear-gradient(180deg, #0a0a0a 0%, #1a1410 50%, #0a0a0a 100%);
	    }

	    .elevator-screen.elevator-style-4 .door {
	      background-image:
	        repeating-linear-gradient(90deg,
	          transparent 0 35px,
	          rgba(212, 175, 55, 0.4) 35px 37px,
	          rgba(244, 228, 183, 0.5) 37px 38px,
	          rgba(212, 175, 55, 0.4) 38px 40px,
	          transparent 40px 75px),
	        repeating-linear-gradient(45deg,
	          transparent 0 12px,
	          rgba(212, 175, 55, 0.12) 12px 13px,
	          transparent 13px 25px),
	        repeating-linear-gradient(-45deg,
	          transparent 0 12px,
	          rgba(212, 175, 55, 0.12) 12px 13px,
	          transparent 13px 25px),
	        linear-gradient(90deg,
	          #000000 0%, #1a1410 5%, #2a2520 20%, #1a1410 40%,
	          #0a0a0a 50%, #1a1410 60%, #2a2520 80%, #1a1410 95%, #000000 100%),
	        radial-gradient(ellipse 100% 60% at 50% 0%, rgba(244, 228, 183, 0.15) 0%, transparent 70%);
	      border-left: 4px solid #D4AF37;
	      border-right: 4px solid #D4AF37;
	      box-shadow:
	        inset 2px 0 8px rgba(212, 175, 55, 0.3),
	        inset -2px 0 8px rgba(212, 175, 55, 0.3);
	    }

	    .elevator-screen.elevator-style-4 .elevator-panel {
	      border: 5px solid transparent;
	      border-image: linear-gradient(180deg, #F4E4B7 0%, #D4AF37 50%, #B8860B 100%) 1;
	      background:
	        radial-gradient(circle at 5% 5%, rgba(244, 228, 183, 0.4) 0 8px, transparent 10px),
	        radial-gradient(circle at 95% 5%, rgba(244, 228, 183, 0.4) 0 8px, transparent 10px),
	        radial-gradient(circle at 5% 95%, rgba(244, 228, 183, 0.4) 0 8px, transparent 10px),
	        radial-gradient(circle at 95% 95%, rgba(244, 228, 183, 0.4) 0 8px, transparent 10px),
	        repeating-linear-gradient(0deg,
	          rgba(212, 175, 55, 0.15) 0 1px,
	          transparent 1px 8px),
	        linear-gradient(180deg, #0a0a0a 0%, #1a1410 30%, #2a2520 50%, #1a1410 70%, #0a0a0a 100%);
	      box-shadow:
	        inset 0 0 40px rgba(212, 175, 55, 0.3),
	        inset 0 2px 10px rgba(0, 0, 0, 0.9),
	        0 8px 25px rgba(0, 0, 0, 0.8),
	        0 0 40px rgba(212, 175, 55, 0.2);
	    }

	    .elevator-screen.elevator-style-4 .floor-display {
	      color: #FFE9A0;
	      background:
	        radial-gradient(ellipse at center, #1a1410 0%, #0a0a0a 70%),
	        linear-gradient(180deg, #000000 0%, #1a1410 100%);
	      border: 5px solid transparent;
	      border-image: linear-gradient(135deg, #D4AF37 0%, #F4E4B7 50%, #D4AF37 100%) 1;
	      text-shadow:
	        0 0 25px rgba(255, 233, 160, 0.95),
	        0 0 40px rgba(212, 175, 55, 0.8),
	        0 0 60px rgba(212, 175, 55, 0.5),
	        0 3px 8px rgba(0, 0, 0, 0.9);
	      box-shadow:
	        inset 0 0 30px rgba(0, 0, 0, 0.95),
	        0 0 40px rgba(212, 175, 55, 0.5),
	        0 0 80px rgba(212, 175, 55, 0.3);
	      font-weight: 700;
	      letter-spacing: 0.15em;
	    }

		    		    /* 5 â€” CLEAN MODERN (Apple Store: ultra-minimalist, frosted glass, silver/platinum) */
	    .elevator-screen.elevator-style-5 {
	      background-image:
	        repeating-linear-gradient(90deg,
	          rgba(255, 255, 255, 0.4) 0px, rgba(255, 255, 255, 0.4) 1px,
	          transparent 1px, transparent 2px,
	          rgba(255, 255, 255, 0.2) 2px, rgba(255, 255, 255, 0.2) 3px,
	          transparent 3px, transparent 120px),
	        linear-gradient(180deg, #FFFFFF 0%, #F8F9FA 30%, #F5F5F7 70%, #ECECEE 100%);
	      background-attachment: fixed, scroll;
	    }

	    .elevator-screen.elevator-style-5 .elevator-shaft {
	      border: 1px solid rgba(200, 200, 205, 0.3);
	      background-image:
	        linear-gradient(90deg,
	          rgba(255, 255, 255, 0.9) 0%, rgba(255, 255, 255, 0.95) 2%,
	          rgba(248, 249, 250, 0.85) 2%, rgba(248, 249, 250, 0.85) 98%,
	          rgba(255, 255, 255, 0.95) 98%, rgba(255, 255, 255, 0.9) 100%),
	        repeating-linear-gradient(0deg,
	          transparent 0 60px,
	          rgba(200, 200, 205, 0.08) 60px 61px,
	          transparent 61px 121px),
	        radial-gradient(ellipse 250px 120px at 50% -30px,
	          rgba(255, 255, 255, 0.9) 0%,
	          rgba(245, 245, 247, 0.4) 50%,
	          transparent 90%),
	        linear-gradient(180deg, #FAFAFA 0%, #F5F5F7 50%, #EEEEEE 100%);
	      box-shadow:
	        inset 0 1px 0 rgba(255, 255, 255, 0.9),
	        inset 1px 0 3px rgba(200, 200, 205, 0.15),
	        inset -1px 0 3px rgba(200, 200, 205, 0.15),
	        0 2px 8px rgba(0, 0, 0, 0.04),
	        0 8px 16px rgba(0, 0, 0, 0.06);
	      backdrop-filter: blur(20px);
	    }

	    .elevator-screen.elevator-style-5 .elevator-shaft::before,
	    .elevator-screen.elevator-style-5 .elevator-shaft::after {
	      border: 1px solid rgba(174, 174, 178, 0.25);
	      filter: drop-shadow(0 1px 2px rgba(0, 0, 0, 0.03));
	      background: linear-gradient(90deg,
	        rgba(255, 255, 255, 0.6) 0%,
	        rgba(245, 245, 247, 0.3) 50%,
	        rgba(255, 255, 255, 0.6) 100%);
	    }

	    .elevator-screen.elevator-style-5 .elevator-shaft>*:first-child::before {
	      background: radial-gradient(ellipse at center,
	        rgba(255, 255, 255, 0.95) 0%,
	        rgba(248, 249, 250, 0.6) 40%,
	        rgba(245, 245, 247, 0.2) 70%,
	        transparent 100%);
	      filter: blur(1px);
	    }

	    .elevator-screen.elevator-style-5 .elevator-doors {
	      background:
	        linear-gradient(90deg,
	          rgba(174, 174, 178, 0.12) 0%, transparent 0.5%,
	          transparent 99.5%, rgba(174, 174, 178, 0.12) 100%),
	        linear-gradient(180deg,
	          rgba(255, 255, 255, 0.4) 0%, rgba(245, 245, 247, 0.2) 100%);
	      backdrop-filter: blur(10px);
	    }

	    .elevator-screen.elevator-style-5 .door {
	      background-image:
	        repeating-linear-gradient(0deg,
	          transparent 0 80px,
	          rgba(200, 200, 205, 0.06) 80px 81px,
	          transparent 81px 161px),
	        linear-gradient(90deg,
	          rgba(255, 255, 255, 0.9) 0%, rgba(248, 249, 250, 0.95) 15%,
	          rgba(245, 245, 247, 0.98) 50%,
	          rgba(248, 249, 250, 0.95) 85%, rgba(255, 255, 255, 0.9) 100%),
	        radial-gradient(ellipse 80% 50% at 20% 20%,
	          rgba(255, 255, 255, 0.7) 0%, transparent 70%);
	      border-left: 1px solid rgba(200, 200, 205, 0.2);
	      border-right: 1px solid rgba(200, 200, 205, 0.2);
	      box-shadow:
	        inset 0 1px 1px rgba(255, 255, 255, 0.6),
	        inset 0 -1px 1px rgba(200, 200, 205, 0.1);
	      backdrop-filter: blur(40px);
	    }

	    .elevator-screen.elevator-style-5 .elevator-panel {
	      border: 1px solid rgba(200, 200, 205, 0.25);
	      background:
	        radial-gradient(circle at 10% 10%, rgba(255, 255, 255, 0.8) 0 3px, transparent 5px),
	        radial-gradient(circle at 90% 10%, rgba(255, 255, 255, 0.8) 0 3px, transparent 5px),
	        linear-gradient(180deg,
	          rgba(255, 255, 255, 0.85) 0%,
	          rgba(250, 250, 250, 0.9) 30%,
	          rgba(245, 245, 247, 0.85) 100%);
	      box-shadow:
	        inset 0 1px 0 rgba(255, 255, 255, 0.8),
	        inset 0 -1px 0 rgba(200, 200, 205, 0.1),
	        0 1px 3px rgba(0, 0, 0, 0.04),
	        0 4px 12px rgba(0, 0, 0, 0.06);
	      backdrop-filter: blur(30px) saturate(120%);
	    }

	    .elevator-screen.elevator-style-5 .floor-display {
	      color: #1D1D1F;
	      background:
	        linear-gradient(180deg,
	          rgba(255, 255, 255, 0.95) 0%,
	          rgba(250, 250, 250, 0.9) 100%);
	      border: 1px solid rgba(200, 200, 205, 0.3);
	      text-shadow:
	        0 0.5px 0.5px rgba(255, 255, 255, 0.9),
	        0 1px 2px rgba(0, 0, 0, 0.08);
	      box-shadow:
	        inset 0 1px 1px rgba(255, 255, 255, 0.7),
	        inset 0 -1px 2px rgba(200, 200, 205, 0.15),
	        0 2px 4px rgba(0, 0, 0, 0.04),
	        0 4px 8px rgba(0, 0, 0, 0.06);
	      backdrop-filter: blur(20px);
	      font-weight: 300;
	      letter-spacing: -0.02em;
	    }

		    /* 6 â€” GOLDEN LUXURY (5-star hotel/casino VIP: champagne, crystal, gold filigree) */
	    .elevator-screen.elevator-style-6 {
	      background-image:
	        radial-gradient(circle at 15% 25%, rgba(255, 215, 0, 0.12) 0 2px, transparent 3px),
	        radial-gradient(circle at 35% 15%, rgba(218, 165, 32, 0.08) 0 3px, transparent 4px),
	        radial-gradient(circle at 65% 35%, rgba(255, 215, 0, 0.10) 0 2px, transparent 3px),
	        radial-gradient(circle at 85% 20%, rgba(218, 165, 32, 0.08) 0 3px, transparent 4px),
	        radial-gradient(circle at 25% 65%, rgba(255, 215, 0, 0.08) 0 2px, transparent 3px),
	        radial-gradient(circle at 75% 75%, rgba(218, 165, 32, 0.10) 0 3px, transparent 4px),
	        repeating-linear-gradient(45deg,
	          transparent 0 120px,
	          rgba(218, 165, 32, 0.04) 120px 121px,
	          transparent 121px 241px),
	        repeating-linear-gradient(-45deg,
	          transparent 0 120px,
	          rgba(218, 165, 32, 0.04) 120px 121px,
	          transparent 121px 241px),
	        linear-gradient(180deg,
	          #FFF9E6 0%, #FFF5DC 30%, #FAEBD7 70%, #F5E6D3 100%);
	      background-size: 180px 140px, 180px 140px, 180px 140px, 180px 140px, 180px 140px, 180px 140px, auto, auto, auto;
	    }

	    .elevator-screen.elevator-style-6 .elevator-shaft {
	      border: 3px solid #DAA520;
	      /* Grand palatial arched top - more dramatic than Heritage style */
	      border-radius: 140px 140px 0 0 / 70px 70px 0 0;
	      background-image:
	        linear-gradient(90deg,
	          #B8860B 0%, #DAA520 3%, #FFD700 5%, #DAA520 7%, #B8860B 10%,
	          rgba(218, 165, 32, 0.3) 10%, rgba(218, 165, 32, 0.3) 90%,
	          #B8860B 90%, #DAA520 93%, #FFD700 95%, #DAA520 97%, #B8860B 100%),
	        repeating-linear-gradient(0deg,
	          transparent 0 30px,
	          rgba(255, 215, 0, 0.25) 30px 31px,
	          rgba(218, 165, 32, 0.15) 31px 32px,
	          rgba(255, 215, 0, 0.25) 32px 33px,
	          transparent 33px 63px),
	        radial-gradient(ellipse 180px 100px at 50% -30px,
	          rgba(255, 215, 0, 0.4) 0%,
	          rgba(218, 165, 32, 0.2) 50%,
	          transparent 90%),
	        radial-gradient(circle at 10% 15%, rgba(255, 255, 255, 0.3) 0 5px, transparent 8px),
	        radial-gradient(circle at 90% 25%, rgba(255, 255, 255, 0.3) 0 4px, transparent 7px),
	        radial-gradient(circle at 30% 60%, rgba(255, 255, 255, 0.3) 0 6px, transparent 9px),
	        radial-gradient(circle at 70% 80%, rgba(255, 255, 255, 0.3) 0 5px, transparent 8px),
	        linear-gradient(180deg,
	          #FAEBD7 0%, #F5DEB3 25%, #DEB887 50%, #D2B48C 75%, #C19A6B 100%);
	      box-shadow:
	        inset 0 0 60px rgba(218, 165, 32, 0.3),
	        inset 0 4px 20px rgba(139, 69, 19, 0.2),
	        0 12px 40px rgba(0, 0, 0, 0.25),
	        0 0 80px rgba(255, 215, 0, 0.25);
	    }

	    .elevator-screen.elevator-style-6 .elevator-shaft::before,
	    .elevator-screen.elevator-style-6 .elevator-shaft::after {
	      border: 2px solid #FFD700;
	      filter:
	        drop-shadow(0 0 6px rgba(218, 165, 32, 0.5))
	        drop-shadow(0 2px 8px rgba(139, 69, 19, 0.3));
	      background: linear-gradient(90deg,
	        rgba(218, 165, 32, 0.4) 0%,
	        rgba(255, 215, 0, 0.2) 50%,
	        rgba(218, 165, 32, 0.4) 100%);
	    }

	    .elevator-screen.elevator-style-6 .elevator-shaft>*:first-child::before {
	      background:
	        radial-gradient(circle at 48% 45%, rgba(255, 255, 255, 0.8) 0 2px, transparent 4px),
	        radial-gradient(circle at 52% 45%, rgba(255, 255, 255, 0.8) 0 2px, transparent 4px),
	        radial-gradient(circle at 50% 50%, rgba(255, 255, 255, 0.6) 0 3px, transparent 5px),
	        radial-gradient(ellipse at center,
	          rgba(255, 248, 220, 0.95) 0%,
	          rgba(255, 235, 180, 0.8) 30%,
	          rgba(255, 215, 0, 0.5) 60%,
	          transparent 100%);
	      filter: drop-shadow(0 0 25px rgba(255, 215, 0, 0.8));
	    }

	    .elevator-screen.elevator-style-6 .elevator-doors {
	      background:
	        linear-gradient(90deg,
	          #DAA520 0%, rgba(218, 165, 32, 0.3) 2%,
	          rgba(218, 165, 32, 0.3) 98%, #DAA520 100%),
	        linear-gradient(180deg,
	          #DAA520 0%, rgba(218, 165, 32, 0.3) 3%,
	          rgba(218, 165, 32, 0.3) 97%, #DAA520 100%),
	        linear-gradient(180deg, #F5DEB3 0%, #DEB887 50%, #D2B48C 100%);
	    }

	    .elevator-screen.elevator-style-6 .door {
	      /* Arched appearance to match palatial shaft styling */
	      border-radius: 100px 100px 0 0 / 50px 50px 0 0;
	      background-image:
	        repeating-linear-gradient(90deg,
	          transparent 0 40px,
	          rgba(255, 215, 0, 0.3) 40px 42px,
	          rgba(218, 165, 32, 0.4) 42px 43px,
	          rgba(255, 215, 0, 0.3) 43px 45px,
	          transparent 45px 85px),
	        repeating-linear-gradient(0deg,
	          transparent 0 50px,
	          rgba(255, 215, 0, 0.15) 50px 52px,
	          transparent 52px 102px),
	        radial-gradient(circle at 20% 20%, rgba(255, 215, 0, 0.25) 0 8px, transparent 12px),
	        radial-gradient(circle at 80% 30%, rgba(255, 215, 0, 0.25) 0 10px, transparent 14px),
	        radial-gradient(circle at 40% 70%, rgba(255, 215, 0, 0.25) 0 7px, transparent 11px),
	        radial-gradient(circle at 70% 80%, rgba(255, 215, 0, 0.25) 0 9px, transparent 13px),
	        linear-gradient(90deg,
	          #D4AF37 0%, #F0E68C 8%, #FFD700 18%, #F5DEB3 35%,
	          #DEB887 50%, #F5DEB3 65%, #FFD700 82%, #F0E68C 92%, #D4AF37 100%),
	        radial-gradient(ellipse 100% 50% at 50% 0%,
	          rgba(255, 255, 255, 0.3) 0%, transparent 80%);
	      border-left: 3px solid #DAA520;
	      border-right: 3px solid #DAA520;
	      box-shadow:
	        inset 3px 0 12px rgba(255, 215, 0, 0.4),
	        inset -3px 0 12px rgba(255, 215, 0, 0.4),
	        inset 0 2px 8px rgba(255, 255, 255, 0.2);
	    }

	    .elevator-screen.elevator-style-6 .elevator-panel {
	      border: 3px solid #DAA520;
	      background:
	        radial-gradient(circle at 8% 8%, rgba(255, 215, 0, 0.5) 0 6px, transparent 10px),
	        radial-gradient(circle at 92% 8%, rgba(255, 215, 0, 0.5) 0 6px, transparent 10px),
	        radial-gradient(circle at 8% 92%, rgba(255, 215, 0, 0.5) 0 6px, transparent 10px),
	        radial-gradient(circle at 92% 92%, rgba(255, 215, 0, 0.5) 0 6px, transparent 10px),
	        repeating-linear-gradient(45deg,
	          transparent 0 3px,
	          rgba(218, 165, 32, 0.08) 3px 4px,
	          transparent 4px 7px),
	        repeating-linear-gradient(-45deg,
	          transparent 0 3px,
	          rgba(218, 165, 32, 0.08) 3px 4px,
	          transparent 4px 7px),
	        linear-gradient(180deg,
	          #F5DEB3 0%, #DEB887 20%, #D2B48C 40%,
	          #C9A961 60%, #D2B48C 80%, #DEB887 100%);
	      box-shadow:
	        inset 0 0 50px rgba(255, 215, 0, 0.3),
	        inset 0 3px 15px rgba(255, 255, 255, 0.2),
	        0 10px 30px rgba(0, 0, 0, 0.3),
	        0 0 50px rgba(218, 165, 32, 0.25);
	    }

	    .elevator-screen.elevator-style-6 .floor-display {
	      color: #8B4513;
	      background:
	        radial-gradient(ellipse at center,
	          #FFF8DC 0%, #FAEBD7 50%, #F5DEB3 100%);
	      border: 3px solid #DAA520;
	      text-shadow:
	        0 1px 0 rgba(255, 255, 255, 0.8),
	        0 2px 4px rgba(218, 165, 32, 0.5),
	        0 0 20px rgba(255, 215, 0, 0.4);
	      box-shadow:
	        inset 0 0 30px rgba(255, 215, 0, 0.25),
	        inset 0 2px 8px rgba(255, 255, 255, 0.3),
	        0 0 40px rgba(218, 165, 32, 0.35),
	        0 4px 12px rgba(0, 0, 0, 0.2);
	      font-weight: 600;
	      letter-spacing: 0.08em;
	    }

	    .elevator-screen.elevator-style-6 .panel-title {
	      color: #8B4513;
	      text-shadow:
	        0 1px 0 rgba(255, 255, 255, 0.6),
	        0 2px 4px rgba(218, 165, 32, 0.3);
	      font-weight: 600;
	    }		    /* 7 â€” NATURE (botanical garden greenhouse: moss greens, bamboo, dappled sunlight, organic textures) */
.elevator-screen.elevator-style-7 {
  background-image:
    /* Leaf shadow patterns - organic shapes creating dappled effect */
    radial-gradient(ellipse 35px 18px at 15% 12%, rgba(45, 106, 79, 0.18) 0%, transparent 50%),
    radial-gradient(ellipse 28px 22px at 82% 25%, rgba(56, 142, 60, 0.14) 0%, transparent 50%),
    radial-gradient(ellipse 42px 20px at 45% 65%, rgba(67, 160, 71, 0.16) 0%, transparent 50%),
    radial-gradient(ellipse 30px 25px at 25% 80%, rgba(46, 125, 50, 0.13) 0%, transparent 50%),
    radial-gradient(ellipse 38px 19px at 70% 88%, rgba(52, 133, 58, 0.15) 0%, transparent 50%),
    /* Dappled sunlight streaming through glass */
    radial-gradient(circle at 30% 5%, rgba(255, 251, 230, 0.35) 0%, rgba(255, 251, 230, 0.08) 40%, transparent 70%),
    radial-gradient(circle at 75% 10%, rgba(255, 251, 230, 0.28) 0%, rgba(255, 251, 230, 0.05) 35%, transparent 65%),
    /* Base gradient - soft moss to sage green */
    linear-gradient(165deg, #E8F3E8 0%, #F1F8EC 35%, #E5F2E0 70%, #DDE8D5 100%),
    /* Bamboo vertical grain texture */
    repeating-linear-gradient(90deg,
      transparent 0, transparent 18px,
      rgba(76, 124, 82, 0.04) 18px, rgba(76, 124, 82, 0.04) 19px,
      transparent 19px, transparent 42px,
      rgba(56, 102, 65, 0.06) 42px, rgba(56, 102, 65, 0.06) 43px);
  background-size: 100% 100%, 100% 100%, 100% 100%, 100% 100%, 100% 100%, 100% 100%, 100% 100%, auto, auto;
  animation: dappled-light-shift 25s ease-in-out infinite;
}

@keyframes dappled-light-shift {
  0%, 100% { filter: brightness(1) contrast(1); }
  33% { filter: brightness(1.05) contrast(0.98); }
  66% { filter: brightness(0.97) contrast(1.02); }
}

.elevator-screen.elevator-style-7 .elevator-shaft {
  border-color: #6B8E23;
  /* Organic greenhouse dome top - natural curved structure */
  border-radius: 50% 50% 0 0 / 40% 40% 0 0;
  background-image:
    /* Rattan/woven bamboo cross-hatch texture */
    repeating-linear-gradient(45deg,
      rgba(101, 84, 64, 0.15) 0, rgba(101, 84, 64, 0.15) 2px,
      transparent 2px, transparent 4px,
      rgba(121, 101, 77, 0.12) 4px, rgba(121, 101, 77, 0.12) 6px,
      transparent 6px, transparent 12px),
    repeating-linear-gradient(-45deg,
      rgba(91, 75, 58, 0.13) 0, rgba(91, 75, 58, 0.13) 2px,
      transparent 2px, transparent 4px,
      rgba(111, 92, 70, 0.10) 4px, rgba(111, 92, 70, 0.10) 6px,
      transparent 6px, transparent 12px),
    /* Bamboo base with natural grain variations */
    linear-gradient(135deg, #8D7456 0%, #A89070 25%, #9B8464 50%, #7D6346 75%, #8D7456 100%),
    repeating-linear-gradient(90deg,
      rgba(255, 255, 255, 0.08) 0 1px,
      transparent 1px 2px,
      rgba(0, 0, 0, 0.12) 2px 3px,
      transparent 3px 16px),
    /* Moss accents in crevices */
    repeating-linear-gradient(180deg,
      transparent 0 32px,
      rgba(76, 175, 80, 0.12) 32px 34px,
      transparent 34px 64px);
  box-shadow:
    inset 0 6px 18px rgba(0, 0, 0, 0.45),
    inset 0 0 60px rgba(106, 142, 35, 0.15),
    inset -2px 0 8px rgba(46, 125, 50, 0.18),
    0 10px 28px rgba(0, 0, 0, 0.30);
}

.elevator-screen.elevator-style-7 .elevator-shaft::before,
.elevator-screen.elevator-style-7 .elevator-shaft::after {
  border-color: #7CB342;
  box-shadow:
    0 0 8px rgba(124, 179, 66, 0.25),
    inset 0 1px 3px rgba(139, 195, 74, 0.35);
}

.elevator-screen.elevator-style-7 .elevator-shaft>*:first-child::before {
  /* Soft natural daylight from greenhouse skylight */
  background: radial-gradient(ellipse at center,
    rgba(255, 251, 230, 0.92) 0%,
    rgba(235, 245, 215, 0.75) 25%,
    rgba(200, 230, 201, 0.45) 55%,
    rgba(139, 195, 74, 0.18) 80%,
    transparent 100%);
  filter: blur(1px);
}

.elevator-screen.elevator-style-7 .elevator-doors {
  background:
    /* Dark earth tones for door frame */
    linear-gradient(180deg, #3A2F28 0%, #4A3A2E 12%, #2F251D 100%),
    repeating-linear-gradient(90deg,
      rgba(139, 195, 74, 0.10) 0 6px,
      rgba(0, 0, 0, 0.08) 6px 14px);
}

.elevator-screen.elevator-style-7 .door {
  background-image:
    /* Organic leaf vein patterns embedded in bamboo */
    radial-gradient(ellipse 4px 12px at 25% 20%, rgba(76, 175, 80, 0.18) 0%, transparent 60%),
    radial-gradient(ellipse 5px 15px at 75% 45%, rgba(56, 142, 60, 0.15) 0%, transparent 60%),
    radial-gradient(ellipse 4px 10px at 40% 70%, rgba(67, 160, 71, 0.16) 0%, transparent 60%),
    /* Bamboo door panels with natural segment joints */
    repeating-linear-gradient(180deg,
      transparent 0 85px,
      rgba(46, 125, 50, 0.14) 85px 88px,
      transparent 88px 90px,
      rgba(76, 175, 80, 0.10) 90px 92px,
      transparent 92px 180px),
    /* Natural bamboo grain texture */
    linear-gradient(90deg, #7D6B52 0%, #B5A084 18%, #9D8A6C 42%, #6E5D48 68%, #8C7A60 88%, #7D6B52 100%),
    repeating-linear-gradient(90deg,
      rgba(0, 0, 0, 0.15) 0 1px,
      transparent 1px 2px,
      rgba(255, 255, 255, 0.06) 2px 3px,
      transparent 3px 11px),
    /* Soft highlight from natural light */
    radial-gradient(ellipse at 35% 15%, rgba(255, 255, 255, 0.18) 0%, transparent 65%);
}

.elevator-screen.elevator-style-7 .elevator-panel {
  border-color: #6B8E23;
  border-width: 2px;
  background:
    /* Moss-covered stone panel effect with organic variations */
    radial-gradient(circle at 20% 15%, rgba(139, 195, 74, 0.22) 0%, transparent 40%),
    radial-gradient(circle at 75% 65%, rgba(124, 179, 66, 0.18) 0%, transparent 35%),
    linear-gradient(165deg, #6B8E23 0%, #8BC34A 22%, #7CB342 48%, #558B2F 75%, #689F38 100%),
    repeating-linear-gradient(90deg,
      rgba(0, 0, 0, 0.10) 0 1px,
      transparent 1px 14px),
    /* Organic texture highlight */
    radial-gradient(circle at 40% 8%, rgba(255, 255, 255, 0.20) 0%, transparent 55%);
  box-shadow:
    inset 0 2px 6px rgba(46, 125, 50, 0.35),
    0 4px 12px rgba(0, 0, 0, 0.25);
}

.elevator-screen.elevator-style-7 .floor-display {
  color: #A5D6A7;
  background: linear-gradient(135deg, #1B4D1B 0%, #1B5E20 50%, #1A4D1A 100%);
  text-shadow:
    0 0 20px rgba(165, 214, 167, 0.95),
    0 0 35px rgba(124, 179, 66, 0.70),
    0 0 48px rgba(76, 175, 80, 0.45);
  box-shadow:
    0 0 38px rgba(124, 179, 66, 0.42),
    inset 0 0 12px rgba(46, 125, 50, 0.25),
    inset 0 3px 10px rgba(0, 0, 0, 0.90);
  border: 1px solid rgba(124, 179, 66, 0.30);
}

.elevator-screen.elevator-style-7 .panel-title {
  color: rgba(27, 94, 32, 0.95);
  text-shadow:
    0 1px 0 rgba(255, 255, 255, 0.50),
    0 0 8px rgba(165, 214, 167, 0.25);
  font-weight: 600;
  letter-spacing: 0.3px;
}		    /* 8 â€” CYBERPUNK/NEON (Blade Runner, Tron: intense neon, circuit boards, glitch effects, dark chrome) */
.elevator-screen.elevator-style-8 {
  background-image:
    /* Circuit board traces - glowing paths */
    repeating-linear-gradient(90deg,
      transparent 0, transparent 45px,
      rgba(0, 229, 255, 0.08) 45px, rgba(0, 229, 255, 0.08) 46px,
      transparent 46px, transparent 91px),
    repeating-linear-gradient(0deg,
      transparent 0, transparent 32px,
      rgba(236, 72, 153, 0.06) 32px, rgba(236, 72, 153, 0.06) 33px,
      transparent 33px, transparent 65px),
    /* Electric scan lines */
    repeating-linear-gradient(180deg,
      rgba(0, 229, 255, 0.03) 0, rgba(0, 229, 255, 0.03) 1px,
      transparent 1px, transparent 3px),
    /* Radial neon glow spots */
    radial-gradient(circle at 15% 20%, rgba(0, 229, 255, 0.18) 0%, transparent 25%),
    radial-gradient(circle at 85% 75%, rgba(236, 72, 153, 0.15) 0%, transparent 30%),
    radial-gradient(circle at 45% 50%, rgba(139, 92, 246, 0.12) 0%, transparent 35%),
    /* Dark base gradient - carbon fiber/chrome */
    linear-gradient(170deg, #05080F 0%, #0A0E1A 25%, #0F172A 50%, #0A0E1A 75%, #05080F 100%);
  background-size: auto, auto, auto, 100% 100%, 100% 100%, 100% 100%, auto;
  animation: cyber-flicker 8s ease-in-out infinite, scan-line-move 15s linear infinite;
}

@keyframes cyber-flicker {
  0%, 100% { filter: brightness(1) contrast(1.1) saturate(1.3); }
  5% { filter: brightness(0.95) contrast(1.15) saturate(1.35); }
  10% { filter: brightness(1.02) contrast(1.08) saturate(1.28); }
  50% { filter: brightness(1.05) contrast(1.05) saturate(1.25); }
}

@keyframes scan-line-move {
  0% { background-position: 0 0, 0 0, 0 0, center, center, center, center; }
  100% { background-position: 0 100px, 0 65px, 0 30px, center, center, center, center; }
}

.elevator-screen.elevator-style-8 .elevator-shaft {
  border-color: #00E5FF;
  border-width: 2px;
  /* Hexagonal cyberpunk shape - tech-aesthetic geometry with sharper angles */
  clip-path: polygon(12% 0%, 88% 0%, 100% 20%, 100% 80%, 88% 100%, 12% 100%, 0% 80%, 0% 20%);
  background-image:
    /* Circuit board pattern - complex traces */
    repeating-linear-gradient(0deg,
      transparent 0 8px,
      rgba(0, 229, 255, 0.12) 8px 9px,
      transparent 9px 16px,
      rgba(236, 72, 153, 0.08) 16px 17px,
      transparent 17px 32px),
    repeating-linear-gradient(90deg,
      transparent 0 12px,
      rgba(0, 229, 255, 0.10) 12px 13px,
      transparent 13px 24px),
    /* Glitch/data stream effect */
    repeating-linear-gradient(45deg,
      rgba(139, 92, 246, 0.05) 0 2px,
      transparent 2px 4px),
    /* Dark carbon fiber/chrome base */
    linear-gradient(135deg, #0B1220 0%, #1A2845 20%, #0F1932 40%, #1E3A5F 60%, #0B1220 100%),
    /* Subtle metallic sheen */
    linear-gradient(90deg,
      rgba(255, 255, 255, 0.03) 0%,
      transparent 20%,
      transparent 80%,
      rgba(255, 255, 255, 0.03) 100%);
  box-shadow:
    inset 0 0 80px rgba(0, 229, 255, 0.20),
    inset 0 0 40px rgba(236, 72, 153, 0.10),
    inset 0 6px 18px rgba(0, 0, 0, 0.60),
    0 0 50px rgba(0, 229, 255, 0.18),
    0 0 25px rgba(236, 72, 153, 0.10),
    0 12px 32px rgba(0, 0, 0, 0.50);
  animation: shaft-pulse 4s ease-in-out infinite;
}

@keyframes shaft-pulse {
  0%, 100% {
    filter: brightness(1) saturate(1.2);
    border-color: rgba(0, 229, 255, 0.85);
  }
  50% {
    filter: brightness(1.15) saturate(1.4);
    border-color: rgba(0, 229, 255, 1);
  }
}

.elevator-screen.elevator-style-8 .elevator-shaft::before,
.elevator-screen.elevator-style-8 .elevator-shaft::after {
  border-color: rgba(0, 229, 255, 0.95);
  box-shadow:
    0 0 18px rgba(0, 229, 255, 0.70),
    0 0 35px rgba(0, 229, 255, 0.40),
    inset 0 1px 4px rgba(0, 229, 255, 0.50);
}

.elevator-screen.elevator-style-8 .elevator-shaft>*:first-child::before {
  /* Intense LED ceiling light with neon glow */
  background: radial-gradient(ellipse at center,
    rgba(0, 255, 255, 0.95) 0%,
    rgba(0, 229, 255, 0.85) 15%,
    rgba(0, 200, 255, 0.60) 35%,
    rgba(0, 229, 255, 0.30) 60%,
    rgba(139, 92, 246, 0.15) 80%,
    transparent 100%);
  filter: blur(2px);
  animation: led-pulse 3s ease-in-out infinite;
}

@keyframes led-pulse {
  0%, 100% {
    opacity: 0.90;
    transform: scale(1);
  }
  50% {
    opacity: 1;
    transform: scale(1.05);
  }
}

.elevator-screen.elevator-style-8 .elevator-doors {
  /* Adjusted positioning to fit within hexagonal shape */
  margin: 10% 5%;
  background:
    /* LED strip accents on frame */
    linear-gradient(180deg, rgba(0, 229, 255, 0.20) 0%, #0A1929 2%, #0B1220 98%, rgba(236, 72, 153, 0.15) 100%),
    repeating-linear-gradient(0deg,
      rgba(0, 229, 255, 0.10) 0 2px,
      transparent 2px 14px);
  box-shadow:
    inset 0 2px 15px rgba(0, 229, 255, 0.25),
    inset 0 -2px 15px rgba(236, 72, 153, 0.15);
}

.elevator-screen.elevator-style-8 .door {
  background-image:
    /* Glitch scan line effect */
    repeating-linear-gradient(180deg,
      transparent 0 2px,
      rgba(0, 229, 255, 0.06) 2px 3px,
      transparent 3px 8px),
    /* Circuit trace patterns on door */
    repeating-linear-gradient(0deg,
      transparent 0 45px,
      rgba(0, 229, 255, 0.15) 45px 48px,
      transparent 48px 90px),
    repeating-linear-gradient(90deg,
      transparent 0 30px,
      rgba(236, 72, 153, 0.08) 30px 31px,
      transparent 31px 60px),
    /* Dark chrome/carbon fiber base */
    linear-gradient(90deg, #0B1928 0%, #1E3A5F 15%, #0F2847 35%, #1A3752 65%, #0F2847 85%, #0A1625 100%),
    /* Metallic sheen overlay */
    linear-gradient(180deg,
      rgba(255, 255, 255, 0.08) 0%,
      transparent 15%,
      transparent 85%,
      rgba(0, 0, 0, 0.40) 100%),
    /* Neon edge glow */
    radial-gradient(ellipse at 10% 50%, rgba(0, 229, 255, 0.25) 0%, transparent 30%);
  box-shadow:
    inset 1px 0 8px rgba(0, 229, 255, 0.20),
    inset -1px 0 8px rgba(236, 72, 153, 0.15);
  animation: door-glitch 10s ease-in-out infinite;
}

@keyframes door-glitch {
  0%, 90%, 100% { filter: brightness(1); }
  91% { filter: brightness(1.3) saturate(1.5); }
  92% { filter: brightness(0.8); }
  93% { filter: brightness(1.2); }
  94% { filter: brightness(1); }
}

.elevator-screen.elevator-style-8 .elevator-panel {
  border-color: rgba(0, 229, 255, 0.75);
  border-width: 2px;
  background:
    /* Circuit board pattern */
    repeating-linear-gradient(90deg,
      transparent 0 14px,
      rgba(0, 229, 255, 0.12) 14px 15px,
      transparent 15px 28px),
    /* Neon glow spots */
    radial-gradient(circle at 25% 20%, rgba(0, 229, 255, 0.20) 0%, transparent 50%),
    radial-gradient(circle at 75% 70%, rgba(236, 72, 153, 0.15) 0%, transparent 45%),
    /* Dark tech base */
    linear-gradient(165deg, #0F1F2F 0%, #1A2F45 18%, #0E1B2E 42%, #152840 68%, #0A1625 100%),
    /* Top highlight */
    radial-gradient(ellipse at 50% 0%, rgba(0, 229, 255, 0.20) 0%, transparent 60%);
  box-shadow:
    inset 0 0 30px rgba(0, 229, 255, 0.12),
    inset 0 0 15px rgba(236, 72, 153, 0.08),
    0 0 20px rgba(0, 229, 255, 0.15),
    0 6px 16px rgba(0, 0, 0, 0.50);
}

.elevator-screen.elevator-style-8 .panel-title {
  color: rgba(0, 255, 255, 0.98);
  text-shadow:
    0 0 12px rgba(0, 229, 255, 0.80),
    0 0 24px rgba(0, 229, 255, 0.50),
    0 1px 0 rgba(0, 0, 0, 0.60);
  font-weight: 700;
  letter-spacing: 1.5px;
  text-transform: uppercase;
  animation: text-flicker 6s ease-in-out infinite;
}

@keyframes text-flicker {
  0%, 96%, 100% { opacity: 1; }
  97% { opacity: 0.8; }
  98% { opacity: 0.95; }
  99% { opacity: 0.85; }
}

.elevator-screen.elevator-style-8 .floor-display {
  color: #00FFFF;
  background: linear-gradient(135deg, #0A1625 0%, #0E1F32 50%, #0A1625 100%);
  text-shadow:
    0 0 25px rgba(0, 255, 255, 1),
    0 0 40px rgba(0, 229, 255, 0.80),
    0 0 60px rgba(0, 229, 255, 0.50),
    0 0 80px rgba(0, 229, 255, 0.30);
  box-shadow:
    0 0 50px rgba(0, 229, 255, 0.50),
    0 0 30px rgba(236, 72, 153, 0.20),
    inset 0 0 20px rgba(0, 229, 255, 0.15),
    inset 0 3px 12px rgba(0, 0, 0, 0.95);
  border: 2px solid rgba(0, 229, 255, 0.60);
  animation: display-pulse 2s ease-in-out infinite;
}

@keyframes display-pulse {
  0%, 100% {
    box-shadow:
      0 0 50px rgba(0, 229, 255, 0.50),
      0 0 30px rgba(236, 72, 153, 0.20),
      inset 0 0 20px rgba(0, 229, 255, 0.15),
      inset 0 3px 12px rgba(0, 0, 0, 0.95);
  }
  50% {
    box-shadow:
      0 0 70px rgba(0, 229, 255, 0.70),
      0 0 40px rgba(236, 72, 153, 0.30),
      inset 0 0 30px rgba(0, 229, 255, 0.25),
      inset 0 3px 12px rgba(0, 0, 0, 0.95);
  }
}		    /* 9 â€” SCANDINAVIAN (cozy Nordic cabin: birch wood, hygge warmth, textile patterns, natural light) */
.elevator-screen.elevator-style-9 {
  background-image:
    /* Knit/textile subtle pattern */
    repeating-linear-gradient(45deg,
      rgba(139, 105, 85, 0.02) 0 2px,
      transparent 2px 4px,
      rgba(139, 105, 85, 0.03) 4px 6px,
      transparent 6px 12px),
    repeating-linear-gradient(-45deg,
      rgba(139, 105, 85, 0.02) 0 2px,
      transparent 2px 4px,
      rgba(139, 105, 85, 0.03) 4px 6px,
      transparent 6px 12px),
    /* Soft linen weave texture */
    repeating-linear-gradient(90deg,
      transparent 0, transparent 3px,
      rgba(139, 105, 85, 0.015) 3px, rgba(139, 105, 85, 0.015) 4px,
      transparent 4px, transparent 8px),
    repeating-linear-gradient(0deg,
      transparent 0, transparent 3px,
      rgba(139, 105, 85, 0.015) 3px, rgba(139, 105, 85, 0.015) 4px,
      transparent 4px, transparent 8px),
    /* Natural light streaming effect */
    radial-gradient(ellipse 200px 150px at 65% 10%, rgba(255, 252, 245, 0.50) 0%, rgba(255, 248, 235, 0.15) 50%, transparent 100%),
    /* Warm cream base gradient */
    linear-gradient(175deg, #FAF7F2 0%, #FFFBF5 30%, #FFF8F0 60%, #F5F0E8 100%);
  background-size: auto, auto, auto, auto, 100% 100%, auto;
  animation: nordic-light-shift 30s ease-in-out infinite;
}

@keyframes nordic-light-shift {
  0%, 100% { filter: brightness(1) contrast(0.98); }
  50% { filter: brightness(1.03) contrast(0.96); }
}

.elevator-screen.elevator-style-9 .elevator-shaft {
  border-color: #C4AA8A;
  background-image:
    /* Birch wood grain - natural, light */
    repeating-linear-gradient(90deg,
      rgba(139, 105, 85, 0.08) 0 1px,
      transparent 1px 2px,
      rgba(107, 78, 60, 0.05) 2px 3px,
      transparent 3px 18px),
    /* Birch bark texture - horizontal bands */
    repeating-linear-gradient(180deg,
      transparent 0 28px,
      rgba(107, 78, 60, 0.12) 28px 30px,
      transparent 30px 32px,
      rgba(139, 105, 85, 0.06) 32px 33px,
      transparent 33px 70px),
    /* Light birch wood base with variation */
    linear-gradient(135deg, #F0E6D8 0%, #FFF8E7 20%, #F5EDE0 45%, #E8DDD0 70%, #F2E8DC 100%),
    /* Natural grain detail */
    repeating-linear-gradient(90deg,
      rgba(210, 180, 140, 0.06) 0 1px,
      transparent 1px 12px),
    /* Soft ambient light from above */
    radial-gradient(ellipse at 50% 0%, rgba(255, 255, 255, 0.60) 0%, rgba(255, 248, 220, 0.30) 40%, transparent 75%);
  box-shadow:
    inset 0 4px 14px rgba(0, 0, 0, 0.12),
    inset 0 0 40px rgba(255, 248, 220, 0.25),
    0 8px 24px rgba(0, 0, 0, 0.15);
}

.elevator-screen.elevator-style-9 .elevator-shaft::before,
.elevator-screen.elevator-style-9 .elevator-shaft::after {
  border-color: #D4B5A0;
  box-shadow:
    0 0 6px rgba(210, 180, 140, 0.30),
    inset 0 1px 2px rgba(255, 255, 255, 0.40);
}

.elevator-screen.elevator-style-9 .elevator-shaft>*:first-child::before {
  /* Warm natural daylight - hygge feel */
  background: radial-gradient(ellipse at center,
    rgba(255, 252, 245, 0.98) 0%,
    rgba(255, 248, 235, 0.85) 20%,
    rgba(255, 243, 224, 0.65) 45%,
    rgba(255, 238, 210, 0.35) 70%,
    rgba(255, 248, 220, 0.10) 90%,
    transparent 100%);
  filter: blur(0.5px);
}

.elevator-screen.elevator-style-9 .elevator-doors {
  background:
    /* Warm wood frame */
    linear-gradient(180deg, #9D8A6C 0%, #B5A084 10%, #A68968 90%, #8B7355 100%),
    repeating-linear-gradient(90deg,
      rgba(255, 255, 255, 0.06) 0 8px,
      rgba(0, 0, 0, 0.08) 8px 16px);
  box-shadow:
    inset 0 2px 6px rgba(0, 0, 0, 0.20);
}

.elevator-screen.elevator-style-9 .door {
  background-image:
    /* Subtle wood grain texture */
    repeating-linear-gradient(90deg,
      rgba(139, 105, 85, 0.08) 0 1px,
      transparent 1px 2px,
      rgba(107, 78, 60, 0.04) 2px 3px,
      transparent 3px 15px),
    /* Textile/linen overlay pattern */
    repeating-linear-gradient(180deg,
      transparent 0 50px,
      rgba(210, 180, 140, 0.08) 50px 52px,
      transparent 52px 100px),
    /* Light birch panel base */
    linear-gradient(90deg, #EDE3D5 0%, #FFF8E7 12%, #F8F0E3 28%, #F2E6D8 55%, #FFF8E7 72%, #E8DDD0 88%, #EDE3D5 100%),
    /* Panel separators - subtle lines */
    linear-gradient(180deg,
      transparent 0%, transparent 32%,
      rgba(210, 180, 140, 0.18) 32%, rgba(210, 180, 140, 0.18) 33%,
      transparent 33%, transparent 66%,
      rgba(210, 180, 140, 0.15) 66%, rgba(210, 180, 140, 0.15) 67%,
      transparent 67%, transparent 100%),
    /* Natural light highlight */
    radial-gradient(ellipse at 30% 20%, rgba(255, 255, 255, 0.45) 0%, rgba(255, 255, 255, 0.12) 50%, transparent 75%);
  box-shadow:
    inset 2px 0 6px rgba(255, 255, 255, 0.30),
    inset -2px 0 6px rgba(139, 105, 85, 0.15);
}

.elevator-screen.elevator-style-9 .elevator-panel {
  border-color: #C4AA8A;
  border-width: 2px;
  background:
    /* Soft textile pattern */
    repeating-linear-gradient(45deg,
      rgba(139, 105, 85, 0.04) 0 2px,
      transparent 2px 4px),
    /* Warm cream panel base */
    linear-gradient(165deg, #FAF5ED 0%, #FFF8E7 18%, #F5EDE0 42%, #FEFAF2 70%, #EDE3D5 100%),
    /* Natural grain */
    repeating-linear-gradient(90deg,
      rgba(139, 105, 85, 0.03) 0 1px,
      transparent 1px 16px),
    /* Soft top light */
    radial-gradient(ellipse at 50% 5%, rgba(255, 255, 255, 0.40) 0%, transparent 65%);
  box-shadow:
    inset 0 2px 8px rgba(255, 255, 255, 0.35),
    inset 0 -1px 4px rgba(139, 105, 85, 0.15),
    0 4px 12px rgba(0, 0, 0, 0.12);
}

.elevator-screen.elevator-style-9 .panel-title {
  color: rgba(90, 65, 50, 0.92);
  text-shadow:
    0 1px 0 rgba(255, 255, 255, 0.60),
    0 0 10px rgba(255, 248, 235, 0.30);
  font-weight: 500;
  letter-spacing: 0.5px;
}

.elevator-screen.elevator-style-9 .floor-display {
  color: #E89A6A;
  background: linear-gradient(135deg, #3E2F23 0%, #4A3A2E 50%, #3A2E22 100%);
  text-shadow:
    0 0 18px rgba(232, 154, 106, 0.95),
    0 0 32px rgba(217, 125, 71, 0.70),
    0 0 45px rgba(217, 125, 71, 0.40);
  box-shadow:
    0 0 35px rgba(217, 125, 71, 0.38),
    inset 0 0 10px rgba(232, 154, 106, 0.15),
    inset 0 3px 10px rgba(0, 0, 0, 0.80);
  border: 1px solid rgba(232, 154, 106, 0.35);
}		    /* 10 â€” PREMIUM LUXURY (penthouse, yacht club: marble/onyx, gold trim, crystal reflections, sophistication) */
.elevator-screen.elevator-style-10 {
  background-image:
    /* Gold dust sparkle accents */
    radial-gradient(circle at 18% 15%, rgba(212, 175, 55, 0.15) 0 1.5px, transparent 2px),
    radial-gradient(circle at 65% 28%, rgba(255, 215, 0, 0.12) 0 1px, transparent 1.5px),
    radial-gradient(circle at 42% 68%, rgba(212, 175, 55, 0.10) 0 1.5px, transparent 2px),
    radial-gradient(circle at 82% 52%, rgba(255, 215, 0, 0.08) 0 1px, transparent 1.5px),
    radial-gradient(circle at 25% 85%, rgba(212, 175, 55, 0.11) 0 1.5px, transparent 2px),
    /* Subtle marble vein pattern */
    linear-gradient(125deg,
      transparent 0%, transparent 28%,
      rgba(200, 200, 200, 0.08) 28%, rgba(200, 200, 200, 0.08) 29%,
      transparent 29%, transparent 62%,
      rgba(180, 180, 180, 0.06) 62%, rgba(180, 180, 180, 0.06) 63%,
      transparent 63%, transparent 100%),
    /* Crystal/mirror reflection effect */
    radial-gradient(ellipse 180px 120px at 75% 20%, rgba(255, 255, 255, 0.30) 0%, transparent 60%),
    /* Premium white/ivory base */
    linear-gradient(168deg, #FCFCFC 0%, #FFFFFF 25%, #F9F9F9 50%, #FEFEFE 75%, #F8F8F8 100%),
    /* Fine grid pattern - subtle luxury */
    repeating-linear-gradient(90deg,
      transparent 0, transparent 70px,
      rgba(0, 0, 0, 0.018) 70px, rgba(0, 0, 0, 0.018) 71px),
    repeating-linear-gradient(0deg,
      transparent 0, transparent 70px,
      rgba(0, 0, 0, 0.018) 70px, rgba(0, 0, 0, 0.018) 71px);
  background-size: 150px 100px, 150px 100px, 150px 100px, 150px 100px, 150px 100px, auto, 100% 100%, auto, auto, auto;
  animation: luxury-shimmer 20s ease-in-out infinite;
}

@keyframes luxury-shimmer {
  0%, 100% { filter: brightness(1) contrast(1.02); }
  50% { filter: brightness(1.02) contrast(1); }
}

.elevator-screen.elevator-style-10 .elevator-shaft {
  border-color: #D4AF37;
  border-width: 2px;
  background-image:
    /* Onyx/black marble veining */
    linear-gradient(145deg,
      transparent 0%, transparent 25%,
      rgba(80, 80, 80, 0.20) 25%, rgba(80, 80, 80, 0.20) 26%,
      transparent 26%, transparent 55%,
      rgba(100, 100, 100, 0.15) 55%, rgba(100, 100, 100, 0.15) 56%,
      transparent 56%, transparent 100%),
    /* Gold accent veins */
    repeating-linear-gradient(180deg,
      transparent 0 42px,
      rgba(212, 175, 55, 0.12) 42px 43px,
      transparent 43px 84px),
    /* Polished black onyx base */
    linear-gradient(135deg, #1A1A1A 0%, #2D2D2D 15%, #1F1F1F 35%, #2A2A2A 60%, #1A1A1A 85%, #252525 100%),
    /* Metallic sheen overlay */
    linear-gradient(90deg,
      rgba(255, 255, 255, 0.08) 0%,
      rgba(255, 255, 255, 0.12) 15%,
      transparent 30%,
      transparent 70%,
      rgba(255, 255, 255, 0.10) 85%,
      rgba(255, 255, 255, 0.08) 100%),
    /* Soft recessed lighting glow */
    radial-gradient(ellipse at 50% 0%, rgba(255, 215, 0, 0.18) 0%, rgba(212, 175, 55, 0.08) 40%, transparent 70%);
  box-shadow:
    inset 0 0 60px rgba(212, 175, 55, 0.10),
    inset 0 6px 20px rgba(0, 0, 0, 0.65),
    inset 2px 0 12px rgba(255, 215, 0, 0.08),
    0 0 30px rgba(212, 175, 55, 0.15),
    0 12px 36px rgba(0, 0, 0, 0.45);
}

.elevator-screen.elevator-style-10 .elevator-shaft::before,
.elevator-screen.elevator-style-10 .elevator-shaft::after {
  border-color: #F4D03F;
  box-shadow:
    0 0 15px rgba(244, 208, 63, 0.45),
    0 0 8px rgba(212, 175, 55, 0.30),
    inset 0 1px 4px rgba(255, 215, 0, 0.40);
}

.elevator-screen.elevator-style-10 .elevator-shaft>*:first-child::before {
  /* Soft recessed luxury lighting - crystal chandelier effect */
  background: radial-gradient(ellipse at center,
    rgba(255, 250, 240, 0.95) 0%,
    rgba(255, 240, 200, 0.85) 15%,
    rgba(255, 225, 150, 0.65) 35%,
    rgba(255, 215, 0, 0.35) 60%,
    rgba(212, 175, 55, 0.15) 80%,
    transparent 100%);
  filter: blur(1.5px);
  animation: crystal-glow 5s ease-in-out infinite;
}

@keyframes crystal-glow {
  0%, 100% { opacity: 0.90; filter: blur(1.5px) brightness(1); }
  50% { opacity: 1; filter: blur(1.5px) brightness(1.1); }
}

.elevator-screen.elevator-style-10 .elevator-doors {
  background:
    /* Gold trim on edges */
    linear-gradient(180deg,
      rgba(212, 175, 55, 0.25) 0%,
      #0A0A0A 1.5%,
      #1A1A1A 98.5%,
      rgba(212, 175, 55, 0.25) 100%),
    /* Subtle onyx texture */
    linear-gradient(90deg,
      rgba(212, 175, 55, 0.18) 0%,
      transparent 5%,
      transparent 95%,
      rgba(212, 175, 55, 0.18) 100%),
    repeating-linear-gradient(180deg,
      rgba(255, 255, 255, 0.02) 0 2px,
      transparent 2px 16px);
  box-shadow:
    inset 0 3px 18px rgba(212, 175, 55, 0.15),
    inset 0 -3px 18px rgba(212, 175, 55, 0.12);
}

.elevator-screen.elevator-style-10 .door {
  background-image:
    /* Marble veining - luxury natural stone */
    linear-gradient(155deg,
      transparent 0%, transparent 32%,
      rgba(180, 180, 180, 0.12) 32%, rgba(180, 180, 180, 0.12) 33%,
      transparent 33%, transparent 68%,
      rgba(200, 200, 200, 0.10) 68%, rgba(200, 200, 200, 0.10) 69%,
      transparent 69%, transparent 100%),
    /* Gold accent trim lines */
    repeating-linear-gradient(180deg,
      transparent 0 88px,
      rgba(212, 175, 55, 0.18) 88px 90px,
      transparent 90px 92px,
      rgba(255, 215, 0, 0.12) 92px 93px,
      transparent 93px 180px),
    /* Polished white marble/onyx base */
    linear-gradient(90deg, #F8F8F8 0%, #FFFFFF 8%, #FAFAFA 22%, #F5F5F5 45%, #FFFFFF 68%, #F7F7F7 88%, #F8F8F8 100%),
    /* Crystal reflection - mirror-like */
    linear-gradient(180deg,
      rgba(255, 255, 255, 0.35) 0%,
      rgba(255, 255, 255, 0.08) 18%,
      transparent 35%,
      transparent 65%,
      rgba(0, 0, 0, 0.08) 82%,
      rgba(0, 0, 0, 0.15) 100%),
    /* Gold edge glow */
    radial-gradient(ellipse at 5% 50%, rgba(212, 175, 55, 0.12) 0%, transparent 25%);
  box-shadow:
    inset 3px 0 12px rgba(255, 255, 255, 0.40),
    inset -3px 0 12px rgba(212, 175, 55, 0.15),
    inset 0 0 20px rgba(255, 255, 255, 0.15);
}

.elevator-screen.elevator-style-10 .elevator-panel {
  border-color: #D4AF37;
  border-width: 2px;
  background:
    /* Gold filigree pattern */
    repeating-linear-gradient(90deg,
      transparent 0 16px,
      rgba(212, 175, 55, 0.15) 16px 17px,
      transparent 17px 32px),
    /* Crystal/glass effect */
    radial-gradient(circle at 30% 25%, rgba(255, 255, 255, 0.30) 0%, transparent 50%),
    radial-gradient(circle at 70% 65%, rgba(212, 175, 55, 0.18) 0%, transparent 45%),
    /* Premium black base with gold gradient */
    linear-gradient(165deg, #1A1A1A 0%, #2D2D2D 12%, #252525 30%, #1F1F1F 58%, #2A2A2A 82%, #1A1A1A 100%),
    /* Polished sheen */
    linear-gradient(90deg,
      rgba(255, 255, 255, 0.12) 0%,
      transparent 30%,
      transparent 70%,
      rgba(255, 255, 255, 0.10) 100%),
    /* Recessed glow */
    radial-gradient(ellipse at 50% 0%, rgba(255, 215, 0, 0.25) 0%, rgba(212, 175, 55, 0.10) 45%, transparent 75%);
  box-shadow:
    inset 0 0 35px rgba(212, 175, 55, 0.12),
    inset 0 2px 10px rgba(255, 215, 0, 0.15),
    0 0 25px rgba(212, 175, 55, 0.18),
    0 6px 20px rgba(0, 0, 0, 0.50);
}

.elevator-screen.elevator-style-10 .panel-title {
  color: rgba(244, 208, 63, 0.98);
  text-shadow:
    0 0 10px rgba(212, 175, 55, 0.60),
    0 0 20px rgba(212, 175, 55, 0.30),
    0 2px 4px rgba(0, 0, 0, 0.70);
  font-weight: 600;
  letter-spacing: 2px;
  text-transform: uppercase;
}

.elevator-screen.elevator-style-10 .floor-display {
  color: #FFD700;
  background: linear-gradient(135deg, #0A0A0A 0%, #1A1A1A 35%, #0F0F0F 70%, #0A0A0A 100%);
  text-shadow:
    0 0 22px rgba(255, 215, 0, 1),
    0 0 38px rgba(212, 175, 55, 0.80),
    0 0 55px rgba(212, 175, 55, 0.50),
    0 0 75px rgba(212, 175, 55, 0.30);
  box-shadow:
    0 0 45px rgba(255, 215, 0, 0.48),
    0 0 25px rgba(212, 175, 55, 0.35),
    inset 0 0 25px rgba(212, 175, 55, 0.12),
    inset 0 3px 12px rgba(0, 0, 0, 0.95);
  border: 2px solid rgba(212, 175, 55, 0.65);
}


		    
			    /* Handle material overrides for realism */
			    .elevator-screen.elevator-style-2 .door::before,
			    .elevator-screen.elevator-style-4 .door::before {
			      background: linear-gradient(90deg, #4B5563 0%, #E5E7EB 45%, #9CA3AF 55%, #374151 100%);
			      box-shadow:
			        inset 0 1px 2px rgba(255, 255, 255, 0.55),
			        0 2px 4px rgba(0, 0, 0, 0.35);
			    }

			    .elevator-screen.elevator-style-6 .door::before {
			      background: linear-gradient(90deg, #B8860B 0%, #F4D03F 35%, #DAA520 65%, #8B6914 100%);
			      box-shadow:
			        inset 0 1px 3px rgba(255, 200, 100, 0.45),
			        0 2px 6px rgba(0, 0, 0, 0.40),
			        0 0 12px rgba(255, 140, 0, 0.25);
			    }

			    .elevator-screen.elevator-style-7 .door::before {
			      background: linear-gradient(90deg, #5D4037 0%, #8D6E63 35%, #6D4C41 65%, #4E342E 100%);
			      box-shadow:
			        inset 0 1px 2px rgba(255, 255, 255, 0.15),
			        0 2px 5px rgba(0, 0, 0, 0.45);
			    }

			    .elevator-screen.elevator-style-8 .door::before {
			      background: linear-gradient(90deg, #0A1625 0%, #1E3A5F 35%, #0F2847 65%, #0B1928 100%);
			      box-shadow:
			        inset 0 1px 2px rgba(0, 229, 255, 0.35),
			        0 2px 6px rgba(0, 0, 0, 0.60),
			        0 0 16px rgba(0, 229, 255, 0.30);
			    }

			    .elevator-screen.elevator-style-9 .door::before {
			      background: linear-gradient(90deg, #A68968 0%, #D9C8B6 35%, #C4AA8A 65%, #8B7355 100%);
			      box-shadow:
			        inset 0 1px 3px rgba(255, 255, 255, 0.40),
			        0 2px 5px rgba(0, 0, 0, 0.35);
			    }

			    .elevator-screen.elevator-style-10 .door::before {
			      background: linear-gradient(90deg, #8B7355 0%, #D4AF37 35%, #F4D03F 50%, #C9A236 65%, #6F5415 100%);
			      box-shadow:
			        inset 0 1px 3px rgba(255, 240, 200, 0.45),
			        0 2px 6px rgba(0, 0, 0, 0.50),
			        0 0 16px rgba(212, 175, 55, 0.35);
			    }
		    /* === DISTINCTIVE DOOR HANDLES FOR EACH VARIANT === */
		    
		    /* Variant 1 - OLD TAIPEI: Ornate brass handles */
		    .elevator-screen.elevator-style-1 .door::before {
		      background: linear-gradient(90deg, #B8860B 0%, #DAA520 20%, #F4E4B7 50%, #DAA520 80%, #B8860B 100%);
		      box-shadow:
		        inset 0 2px 4px rgba(255, 215, 0, 0.4),
		        inset 0 -2px 4px rgba(139, 69, 19, 0.6),
		        0 4px 8px rgba(0, 0, 0, 0.5);
		      border-radius: 5px;
		    }

		    /* Variant 2 - TAIPEI 101: Sleek LED strip handle */
		    .elevator-screen.elevator-style-2 .door::before {
		      background: linear-gradient(90deg, #1E293B 0%, #3B82F6 20%, #60A5FA 50%, #3B82F6 80%, #1E293B 100%);
		      box-shadow:
		        inset 0 1px 2px rgba(96, 165, 250, 0.6),
		        0 0 15px rgba(59, 130, 246, 0.8),
		        0 2px 4px rgba(0, 0, 0, 0.5);
		      border-radius: 2px;
		      height: 80px;
		    }

		    /* Variant 3 - INDUSTRIAL: Heavy-duty lever with warning stripe */
		    .elevator-screen.elevator-style-3 .door::before {
		      background: 
		        linear-gradient(180deg,
		          #FCD34D 0%, #FCD34D 15%,
		          #1F2937 15%, #1F2937 30%,
		          #FCD34D 30%, #FCD34D 45%,
		          #1F2937 45%, #1F2937 60%,
		          #FCD34D 60%, #FCD34D 75%,
		          #1F2937 75%, #1F2937 90%,
		          #FCD34D 90%, #FCD34D 100%),
		        linear-gradient(90deg, #374151 0%, #4B5563 50%, #374151 100%);
		      box-shadow:
		        inset 2px 0 4px rgba(0, 0, 0, 0.6),
		        0 4px 8px rgba(0, 0, 0, 0.7);
		      border-radius: 3px;
		      width: 14px;
		      height: 110px;
		    }

		    /* Variant 4 - ART DECO: Ornate gold geometric handle */
		    .elevator-screen.elevator-style-4 .door::before {
		      background: 
		        linear-gradient(90deg, #0F172A 0%, #D4AF37 10%, #F4E4B7 50%, #D4AF37 90%, #0F172A 100%),
		        repeating-linear-gradient(45deg,
		          rgba(244, 228, 183, 0.3) 0 2px,
		          transparent 2px 4px);
		      box-shadow:
		        inset 0 2px 4px rgba(244, 228, 183, 0.5),
		        inset 0 -2px 4px rgba(0, 0, 0, 0.7),
		        0 4px 10px rgba(212, 175, 55, 0.4);
		      border-radius: 6px;
		      border: 2px solid #D4AF37;
		    }

		    /* Variant 5 - ZEN MINIMALIST: Recessed, almost invisible handle */
		    .elevator-screen.elevator-style-5 .door::before {
		      background: linear-gradient(90deg, #E7E5E4 0%, #F5F5F4 50%, #E7E5E4 100%);
		      box-shadow:
		        inset 1px 0 2px rgba(0, 0, 0, 0.1),
		        inset -1px 0 2px rgba(255, 255, 255, 0.5);
		      border-radius: 1px;
		      width: 8px;
		      height: 90px;
		      opacity: 0.6;
		    }

		    .elevator-screen.elevator-style-10 .elevator-doors {
		      background:
		        linear-gradient(180deg, #0A0A0A 0%, #1A1A1A 100%),
		        linear-gradient(90deg, rgba(212, 175, 55, 0.15) 0%, transparent 20%, transparent 80%, rgba(212, 175, 55, 0.15) 100%),
		        repeating-linear-gradient(180deg, rgba(255, 255, 255, 0.02) 0 2px, transparent 2px 12px);
		    }
		      color: #D4AF37;
		      text-shadow: 0 0 8px rgba(212, 175, 55, 0.35), 0 1px 0 rgba(0, 0, 0, 0.50);
		    }

		    .elevator-screen.elevator-style-10 .floor-display {
		      color: #FFD700;
		      background: #0A0A0A;
		      text-shadow: 0 0 18px rgba(255, 215, 0, 0.95), 0 0 32px rgba(212, 175, 55, 0.65);
		      box-shadow:
		        0 0 38px rgba(255, 215, 0, 0.38),
		        inset 0 2px 8px rgba(0, 0, 0, 0.90);
		      border-color: rgba(212, 175, 55, 0.55);
		    }

			    /* Handle material overrides for realism */
			    .elevator-screen.elevator-style-2 .door::before,
			    .elevator-screen.elevator-style-4 .door::before,
			    .elevator-screen.elevator-style-6 .door::before,
			    .elevator-screen.elevator-style-9 .door::before {
			      background: linear-gradient(90deg, #4B5563 0%, #E5E7EB 45%, #9CA3AF 55%, #374151 100%);
			      box-shadow:
			        inset 0 1px 2px rgba(255, 255, 255, 0.55),
			        0 2px 4px rgba(0, 0, 0, 0.35);
			    }

			    .elevator-screen.elevator-style-7 .door::before {
			      background: linear-gradient(90deg, #5B4636 0%, #D6BE9E 38%, #B08D57 60%, #3F2F25 100%);
			    }

			    .elevator-screen.elevator-style-10 .door::before {
			      background: linear-gradient(90deg, #0B1220 0%, #374151 50%, #111827 100%);
			      box-shadow:
			        inset 0 1px 2px rgba(255, 255, 255, 0.18),
			        0 2px 4px rgba(0, 0, 0, 0.55);
			    }

			    /* Door seam color tuning (avoid brown seams on metal finishes) */
			    .elevator-screen.elevator-style-2 .door::after,
			    .elevator-screen.elevator-style-4 .door::after {
			      background: linear-gradient(180deg, rgba(17, 24, 39, 0.9) 0%, rgba(75, 85, 99, 0.85) 50%, rgba(17, 24, 39, 0.9) 100%);
			    }

			    .elevator-screen.elevator-style-3 .door::after {
			      background: linear-gradient(180deg, rgba(72, 202, 228, 0.55) 0%, rgba(14, 165, 233, 0.22) 50%, rgba(72, 202, 228, 0.55) 100%);
			    }

			    .elevator-screen.elevator-style-6 .door::after {
			      background: linear-gradient(180deg, rgba(139, 69, 19, 0.90) 0%, rgba(184, 115, 51, 0.75) 50%, rgba(139, 69, 19, 0.90) 100%);
			    }

			    .elevator-screen.elevator-style-7 .door::after {
			      background: linear-gradient(180deg, rgba(62, 39, 35, 0.95) 0%, rgba(109, 76, 65, 0.85) 50%, rgba(62, 39, 35, 0.95) 100%);
			    }

			    .elevator-screen.elevator-style-8 .door::after {
			      background: linear-gradient(180deg, rgba(0, 229, 255, 0.45) 0%, rgba(10, 22, 37, 0.95) 50%, rgba(0, 229, 255, 0.45) 100%);
			    }

			    .elevator-screen.elevator-style-9 .door::after {
			      background: linear-gradient(180deg, rgba(139, 105, 85, 0.85) 0%, rgba(107, 78, 60, 0.90) 50%, rgba(139, 105, 85, 0.85) 100%);
			    }

			    .elevator-screen.elevator-style-10 .door::after {
			      background: linear-gradient(180deg, rgba(212, 175, 55, 0.75) 0%, rgba(10, 10, 10, 0.95) 50%, rgba(212, 175, 55, 0.75) 100%);
			    }

		    /* ========================================
		       GLASS/TRANSPARENT DOOR EFFECTS
		       Production-grade glass overlays enhancing existing door aesthetics
		       ======================================== */

		    /* STYLE 2 - SPACECRAFT: LED EDGE-LIT CLEAR GLASS */
		    .elevator-screen.elevator-style-2 .door {
		      position: relative;
		      backdrop-filter: blur(1px);
		      border: 2px solid rgba(0, 191, 255, 0.6);
		      box-shadow:
		        inset 0 0 20px rgba(0, 191, 255, 0.3),
		        0 0 30px rgba(0, 191, 255, 0.5),
		        inset 1px 0 8px rgba(0, 191, 255, 0.20),
		        inset -1px 0 8px rgba(236, 72, 153, 0.15);
		      animation: led-edge-pulse 2s ease-in-out infinite;
		    }

		    /* Override background to add glass tint layer */
		    .elevator-screen.elevator-style-2 .door {
		      background-image:
		        /* Glass tint overlay */
		        linear-gradient(0deg, rgba(0, 20, 40, 0.15), rgba(0, 20, 40, 0.15)),
		        /* Central energy strip */
		        linear-gradient(90deg, transparent 0%, transparent 49%, rgba(0, 191, 255, 0.8) 49%, rgba(0, 191, 255, 1) 50%, rgba(0, 191, 255, 0.8) 51%, transparent 51%),
		        /* Horizontal HUD lines */
		        linear-gradient(180deg,
		          transparent 0%, transparent 33%,
		          rgba(59, 130, 246, 0.4) 33%, rgba(0, 191, 255, 0.6) 34%, rgba(59, 130, 246, 0.4) 35%,
		          transparent 35%, transparent 66%,
		          rgba(59, 130, 246, 0.4) 66%, rgba(0, 191, 255, 0.6) 67%, rgba(59, 130, 246, 0.4) 68%,
		          transparent 68%, transparent 100%),
		        /* Brushed chrome surface */
		        linear-gradient(90deg, #64748B 0%, #94A3B8 15%, #CBD5E1 30%, #F8FAFC 50%, #CBD5E1 70%, #94A3B8 85%, #64748B 100%),
		        /* Micro-texture */
		        repeating-linear-gradient(90deg, rgba(248, 250, 252, 0.15) 0 1px, transparent 1px 6px),
		        /* Holographic sheen */
		        radial-gradient(circle at 30% 25%, rgba(0, 191, 255, 0.2) 0%, transparent 40%);
		    }

		    @keyframes led-edge-pulse {
		      0%, 100% {
		        border-color: rgba(0, 191, 255, 0.6);
		        box-shadow:
		          inset 0 0 20px rgba(0, 191, 255, 0.3),
		          0 0 30px rgba(0, 191, 255, 0.5),
		          inset 1px 0 8px rgba(0, 191, 255, 0.20),
		          inset -1px 0 8px rgba(236, 72, 153, 0.15);
		      }
		      50% {
		        border-color: rgba(0, 191, 255, 0.9);
		        box-shadow:
		          inset 0 0 30px rgba(0, 191, 255, 0.5),
		          0 0 45px rgba(0, 191, 255, 0.8),
		          0 0 60px rgba(59, 130, 246, 0.4),
		          inset 1px 0 12px rgba(0, 191, 255, 0.35),
		          inset -1px 0 12px rgba(236, 72, 153, 0.25);
		      }
		    }

		    /* STYLE 3 - INDUSTRIAL: WIRE MESH SAFETY GLASS */
		    .elevator-screen.elevator-style-3 .door {
		      position: relative;
		      backdrop-filter: blur(2px) contrast(0.95);
		    }

		    /* Add wire mesh pattern as glass overlay */
		    .elevator-screen.elevator-style-3 .door {
		      background-image:
		        /* Wire mesh pattern */
		        repeating-linear-gradient(0deg,
		          transparent 0 8px,
		          rgba(100, 100, 100, 0.2) 8px 9px),
		        repeating-linear-gradient(90deg,
		          transparent 0 8px,
		          rgba(100, 100, 100, 0.2) 8px 9px),
		        /* Glass tint */
		        linear-gradient(0deg, rgba(100, 149, 237, 0.25), rgba(100, 149, 237, 0.25)),
		        /* Rivet grid pattern */
		        radial-gradient(circle at 15px 20px, #0A0A0A 0 3px, rgba(75, 85, 99, 0.8) 3px 4px, transparent 5px),
		        radial-gradient(circle at 15px 70px, #0A0A0A 0 3px, rgba(75, 85, 99, 0.8) 3px 4px, transparent 5px),
		        radial-gradient(circle at 15px 120px, #0A0A0A 0 3px, rgba(75, 85, 99, 0.8) 3px 4px, transparent 5px),
		        radial-gradient(circle at calc(100% - 15px) 20px, #0A0A0A 0 3px, rgba(75, 85, 99, 0.8) 3px 4px, transparent 5px),
		        radial-gradient(circle at calc(100% - 15px) 70px, #0A0A0A 0 3px, rgba(75, 85, 99, 0.8) 3px 4px, transparent 5px),
		        radial-gradient(circle at calc(100% - 15px) 120px, #0A0A0A 0 3px, rgba(75, 85, 99, 0.8) 3px 4px, transparent 5px),
		        /* Caution stripes (horizontal) */
		        repeating-linear-gradient(0deg,
		          transparent 0, transparent 60px,
		          rgba(251, 191, 36, 0.25) 60px, rgba(251, 191, 36, 0.25) 65px,
		          rgba(28, 25, 23, 0.6) 65px, rgba(28, 25, 23, 0.6) 70px,
		          transparent 70px, transparent 130px),
		        /* Heavy steel plate */
		        linear-gradient(90deg, #4B5563 0%, #6B7280 10%, #9CA3AF 25%, #D1D5DB 50%, #9CA3AF 75%, #6B7280 90%, #4B5563 100%),
		        /* Industrial grime texture */
		        repeating-linear-gradient(45deg, rgba(17, 24, 39, 0.5) 0 2px, transparent 2px 10px),
		        /* Hammered metal effect */
		        radial-gradient(circle at 35% 30%, rgba(209, 213, 219, 0.4) 0%, transparent 25%);
		    }

		    /* STYLE 5 - MODERN: CRYSTAL CLEAR MINIMAL */
		    .elevator-screen.elevator-style-5 .door {
		      position: relative;
		      backdrop-filter: blur(0.5px);
		      border: 1px solid rgba(200, 200, 200, 0.4);
		    }

		    /* Add ultra-subtle glass tint */
		    .elevator-screen.elevator-style-5 .door {
		      background-image:
		        /* Glass tint - barely perceptible */
		        linear-gradient(0deg, rgba(255, 255, 255, 0.12), rgba(255, 255, 255, 0.12)),
		        /* Subtle grid lines */
		        repeating-linear-gradient(0deg,
		          transparent 0 80px,
		          rgba(200, 200, 205, 0.06) 80px 81px,
		          transparent 81px 161px),
		        /* Pristine white gradient */
		        linear-gradient(90deg,
		          rgba(255, 255, 255, 0.9) 0%, rgba(248, 249, 250, 0.95) 15%,
		          rgba(245, 245, 247, 0.98) 50%,
		          rgba(248, 249, 250, 0.95) 85%, rgba(255, 255, 255, 0.9) 100%),
		        /* Reflection highlight */
		        radial-gradient(ellipse 80% 50% at 20% 20%,
		          rgba(255, 255, 255, 0.7) 0%, transparent 70%);
		    }

		    /* STYLE 6 - GOLDEN LUXURY: SMART FROSTED GLASS */
		    .elevator-screen.elevator-style-6 .door {
		      position: relative;
		      backdrop-filter: blur(10px);
		      border: 2px solid rgba(218, 165, 32, 0.5);
		      transition: backdrop-filter 1.2s cubic-bezier(0.4, 0, 0.2, 1),
		                  box-shadow 1.2s cubic-bezier(0.4, 0, 0.2, 1);
		      box-shadow:
		        inset 1px 0 4px rgba(255, 215, 0, 0.3),
		        inset -1px 0 4px rgba(218, 165, 32, 0.25);
		    }

		    /* Smart glass: becomes clearer when doors open */
		    .doors-open .elevator-screen.elevator-style-6 .door {
		      backdrop-filter: blur(2px);
		    }

		    /* Add frosted glass tint layer */
		    .elevator-screen.elevator-style-6 .door {
		      background-image:
		        /* Frosted glass overlay */
		        linear-gradient(0deg, rgba(255, 248, 231, 0.7), rgba(255, 248, 231, 0.7)),
		        /* Gold accent lines */
		        repeating-linear-gradient(90deg,
		          transparent 0 40px,
		          rgba(255, 215, 0, 0.3) 40px 42px,
		          rgba(218, 165, 32, 0.4) 42px 43px,
		          rgba(255, 215, 0, 0.3) 43px 45px,
		          transparent 45px 85px),
		        repeating-linear-gradient(0deg,
		          transparent 0 50px,
		          rgba(255, 215, 0, 0.15) 50px 52px,
		          transparent 52px 102px),
		        /* Decorative gold dots */
		        radial-gradient(circle at 20% 20%, rgba(255, 215, 0, 0.25) 0 8px, transparent 12px),
		        radial-gradient(circle at 80% 30%, rgba(255, 215, 0, 0.25) 0 10px, transparent 14px),
		        radial-gradient(circle at 40% 70%, rgba(255, 215, 0, 0.25) 0 7px, transparent 11px),
		        radial-gradient(circle at 70% 80%, rgba(255, 215, 0, 0.25) 0 9px, transparent 13px),
		        /* Luxurious cream gradient */
		        linear-gradient(90deg,
		          #F5DEB3 0%, #FAEBD7 12%, #FFE4B5 28%,
		          #FFF8DC 50%, #FFE4B5 72%,
		          #FAEBD7 88%, #F5DEB3 100%),
		        /* Golden sheen */
		        radial-gradient(ellipse at 25% 25%, rgba(255, 215, 0, 0.25) 0%, transparent 50%);
		    }

		    /* Golden shimmer animation */
		    .elevator-screen.elevator-style-6 .door::before {
		      animation: golden-shimmer 4s ease-in-out infinite;
		    }

		    @keyframes golden-shimmer {
		      0%, 100% {
		        box-shadow:
		          inset 0 1px 3px rgba(255, 200, 100, 0.45),
		          0 2px 6px rgba(0, 0, 0, 0.40),
		          0 0 12px rgba(255, 140, 0, 0.25);
		      }
		      50% {
		        box-shadow:
		          inset 0 1px 3px rgba(255, 200, 100, 0.60),
		          0 2px 6px rgba(0, 0, 0, 0.40),
		          0 0 20px rgba(255, 140, 0, 0.40);
		      }
		    }

		    /* STYLE 7 - NATURE: GREEN TINTED GREENHOUSE GLASS */
		    .elevator-screen.elevator-style-7 .door {
		      position: relative;
		      backdrop-filter: blur(1px) saturate(1.2);
		    }

		    /* Add greenhouse glass tint */
		    .elevator-screen.elevator-style-7 .door {
		      background-image:
		        /* Green greenhouse tint */
		        linear-gradient(0deg, rgba(139, 195, 74, 0.2), rgba(139, 195, 74, 0.2)),
		        /* Organic leaf vein patterns */
		        radial-gradient(ellipse 4px 12px at 25% 20%, rgba(76, 175, 80, 0.18) 0%, transparent 60%),
		        radial-gradient(ellipse 5px 15px at 75% 45%, rgba(56, 142, 60, 0.15) 0%, transparent 60%),
		        radial-gradient(ellipse 4px 10px at 40% 70%, rgba(67, 160, 71, 0.16) 0%, transparent 60%),
		        /* Bamboo door panels with natural segment joints */
		        repeating-linear-gradient(180deg,
		          transparent 0 85px,
		          rgba(46, 125, 50, 0.14) 85px 88px,
		          transparent 88px 90px,
		          rgba(76, 175, 80, 0.10) 90px 92px,
		          transparent 92px 180px),
		        /* Natural bamboo grain texture */
		        linear-gradient(90deg, #7D6B52 0%, #B5A084 18%, #9D8A6C 42%, #6E5D48 68%, #8C7A60 88%, #7D6B52 100%),
		        repeating-linear-gradient(90deg,
		          rgba(62, 39, 35, 0.15) 0 1px,
		          transparent 1px 3px,
		          rgba(109, 76, 65, 0.08) 3px 4px,
		          transparent 4px 12px),
		        /* Soft natural highlights */
		        radial-gradient(ellipse at 30% 20%, rgba(139, 195, 74, 0.20) 0%, transparent 40%);
		    }

		    /* Organic light filtering animation */
		    .elevator-screen.elevator-style-7 .door {
		      animation: greenhouse-light 8s ease-in-out infinite;
		    }

		    @keyframes greenhouse-light {
		      0%, 100% {
		        filter: brightness(1) saturate(1);
		      }
		      50% {
		        filter: brightness(1.05) saturate(1.15);
		      }
		    }

		    /* STYLE 8 - CYBERPUNK: DARK TINTED + GLITCH */
		    .elevator-screen.elevator-style-8 .door {
		      position: relative;
		      backdrop-filter: blur(1px);
		      border: 2px solid rgba(255, 0, 255, 0.5);
		      box-shadow:
		        0 0 20px rgba(0, 255, 255, 0.4),
		        inset 1px 0 8px rgba(0, 229, 255, 0.20),
		        inset -1px 0 8px rgba(236, 72, 153, 0.15);
		      animation: cyberpunk-glitch 8s ease-in-out infinite, door-glitch 10s ease-in-out infinite;
		    }

		    /* Add dark glass tint with scan lines */
		    .elevator-screen.elevator-style-8 .door {
		      background-image:
		        /* Dark cyberpunk tint */
		        linear-gradient(0deg, rgba(10, 10, 30, 0.3), rgba(10, 10, 30, 0.3)),
		        /* Glitch scan line effect */
		        repeating-linear-gradient(180deg,
		          transparent 0 2px,
		          rgba(0, 229, 255, 0.06) 2px 3px,
		          transparent 3px 8px),
		        /* Circuit trace patterns on door */
		        repeating-linear-gradient(0deg,
		          transparent 0 45px,
		          rgba(0, 229, 255, 0.15) 45px 48px,
		          transparent 48px 90px),
		        repeating-linear-gradient(90deg,
		          transparent 0 30px,
		          rgba(236, 72, 153, 0.08) 30px 31px,
		          transparent 31px 60px),
		        /* Dark chrome/carbon fiber base */
		        linear-gradient(90deg, #0B1928 0%, #1E3A5F 15%, #0F2847 35%, #1A3752 65%, #0F2847 85%, #0A1625 100%),
		        /* Metallic sheen overlay */
		        linear-gradient(180deg,
		          rgba(255, 255, 255, 0.08) 0%,
		          transparent 15%,
		          transparent 85%,
		          rgba(0, 0, 0, 0.40) 100%),
		        /* Neon edge glow */
		        radial-gradient(ellipse at 10% 50%, rgba(0, 229, 255, 0.25) 0%, transparent 30%);
		    }

		    /* Cyberpunk glitch animation */
		    @keyframes cyberpunk-glitch {
		      0%, 90%, 100% {
		        border-color: rgba(255, 0, 255, 0.5);
		        box-shadow:
		          0 0 20px rgba(0, 255, 255, 0.4),
		          inset 1px 0 8px rgba(0, 229, 255, 0.20),
		          inset -1px 0 8px rgba(236, 72, 153, 0.15);
		      }
		      91%, 93%, 95% {
		        border-color: rgba(0, 255, 255, 0.8);
		        box-shadow:
		          0 0 30px rgba(0, 255, 255, 0.7),
		          0 0 50px rgba(255, 0, 255, 0.5),
		          inset 0 0 20px rgba(0, 255, 255, 0.3),
		          inset 1px 0 12px rgba(0, 229, 255, 0.35),
		          inset -1px 0 12px rgba(236, 72, 153, 0.25);
		      }
		      92%, 94% {
		        border-color: rgba(255, 0, 255, 0.7);
		        box-shadow:
		          0 0 25px rgba(255, 0, 255, 0.6),
		          inset 1px 0 10px rgba(236, 72, 153, 0.30);
		      }
		    }

		    /* Make door-window more visible through glass when doors are closed */
		    .elevator-screen.elevator-style-2 .door-window,
		    .elevator-screen.elevator-style-3 .door-window,
		    .elevator-screen.elevator-style-5 .door-window,
		    .elevator-screen.elevator-style-6 .door-window,
		    .elevator-screen.elevator-style-7 .door-window,
		    .elevator-screen.elevator-style-8 .door-window {
		      opacity: 0.85;
		      transition: opacity 1.8s cubic-bezier(0.34, 1.18, 0.42, 1);
		    }

		    /* Full opacity when doors open */
		    .doors-open .elevator-screen.elevator-style-2 .door-window,
		    .doors-open .elevator-screen.elevator-style-3 .door-window,
		    .doors-open .elevator-screen.elevator-style-5 .door-window,
		    .doors-open .elevator-screen.elevator-style-6 .door-window,
		    .doors-open .elevator-screen.elevator-style-7 .door-window,
		    .doors-open .elevator-screen.elevator-style-8 .door-window {
		      opacity: 1;
		    }

		    /* Subtle lighting flicker for nature elevator (style-7) - organic light movement */
		    .elevator-screen.elevator-style-7 .elevator-shaft>*:first-child::before {
		      animation: ceiling-light-pulse 4s ease-in-out infinite, nature-shimmer 6s ease-in-out infinite;
		    }

		    @keyframes nature-shimmer {
		      0%, 100% {
		        opacity: 1;
		      }
		      40%, 60% {
		        opacity: 0.88;
		      }
		      50% {
		        opacity: 0.95;
		      }
		    }

		    /* Pulsing glow for tech elevator (style-8) - data center aesthetic */
		    .elevator-screen.elevator-style-8 .elevator-shaft>*:first-child::before {
		      animation: ceiling-light-pulse 4s ease-in-out infinite, tech-pulse 3s ease-in-out infinite;
		    }

		    @keyframes tech-pulse {
		      0%, 100% {
		        opacity: 0.90;
		        filter: brightness(1);
		      }
		      50% {
		        opacity: 1;
		        filter: brightness(1.15);
		      }
		    }

		    /* Warm glow for luxury elevator (style-10) - elegant ambiance */
		    .elevator-screen.elevator-style-10 .elevator-shaft>*:first-child::before {
		      animation: ceiling-light-pulse 4s ease-in-out infinite, luxury-glow 5s ease-in-out infinite;
		    }

		    @keyframes luxury-glow {
		      0%, 100% {
		        opacity: 0.90;
		      }
		      50% {
		        opacity: 1;
		      }
		    }

		    /* ===== WORD WARM-UP SCREEN ===== */
		    .warmup-screen {
		      background:
		        radial-gradient(ellipse at 50% 0%, var(--accent-golden-pale) 0%, transparent 50%),
        radial-gradient(ellipse at 80% 100%, var(--accent-peach-pale) 0%, transparent 40%),
        linear-gradient(180deg, var(--bg-cream-warm) 0%, var(--accent-golden-pale) 100%);
      padding: clamp(0.75rem, 1.5vh, 1.5rem);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: clamp(0.75rem, 1.5vh, 1.5rem);
    }

    .warmup-header {
      text-align: center;
    }

    .warmup-icon {
      font-size: clamp(2rem, 5vh, 2.8rem);
      margin-bottom: var(--space-sm);
      animation: bounce 2s ease-in-out infinite;
      filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.1));
    }

    @keyframes bounce {

      0%,
      100% {
        transform: translateY(0);
      }

      50% {
        transform: translateY(-8px);
      }
    }

    .warmup-title {
      font-family: var(--font-display);
      font-size: clamp(1.25rem, 3vh, 1.5rem);
      font-weight: 600;
      color: var(--text-primary);
      margin: 0;
    }

    .warmup-subtitle {
      font-family: var(--font-reading);
      font-size: var(--text-base);
      color: var(--text-secondary);
      margin: var(--space-xs) 0 0;
    }

    .warmup-words {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: var(--space-md);
      width: 100%;
      max-width: 380px;
    }

    .warmup-word-card {
      position: relative;
      background:
        linear-gradient(180deg, #FFFFFF 0%, var(--bg-cream-cool) 100%);
      border-radius: var(--radius-xl);
      padding: clamp(0.75rem, 1.5vh, 1.5rem) clamp(0.5rem, 1vh, 1rem);
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: var(--space-sm);
      cursor: pointer;
      transition: all var(--anim-fast) var(--ease-out-soft);
      border: 3px solid var(--panel-silver);
      box-shadow:
        0 4px 0 var(--panel-silver-dark),
        var(--shadow-sm);
    }

    .warmup-word-card:hover {
      transform: translateY(-4px);
      box-shadow:
        0 6px 0 var(--panel-silver-dark),
        var(--shadow-md);
      border-color: var(--mrt-blue-pale);
    }

    .warmup-word-card:active {
      transform: translateY(2px) scale(0.98);
      box-shadow:
        0 2px 0 var(--panel-silver-dark),
        var(--shadow-xs);
    }

    .warmup-word-card.heard {
      border-color: var(--success-green);
      background:
        linear-gradient(180deg, var(--success-green-pale) 0%, var(--accent-mint-pale) 100%);
      box-shadow:
        0 4px 0 var(--accent-mint-soft),
        var(--shadow-mint);
    }

    .warmup-word-card.heard::after {
      content: 'âœ“';
      position: absolute;
      top: 8px;
      right: 8px;
      width: 20px;
      height: 20px;
      background: var(--success-green);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.95rem;
      font-weight: 900;
      line-height: 1;
      color: #FFFFFF;
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.25);
      box-shadow: var(--shadow-sm);
      pointer-events: none;
    }

    /* Keep the SW badge readable even after the card is marked heard. */
    .warmup-word-card.heard.sight-word::before {
      -webkit-text-stroke: 0.6px rgba(0, 0, 0, 0.45);
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.25);
    }

    .warmup-word-icon {
      font-size: clamp(1.5rem, 4vh, 2.2rem);
      filter: drop-shadow(0 1px 2px rgba(0, 0, 0, 0.1));
    }

    .warmup-word-text {
      font-family: var(--font-display);
      font-size: clamp(1rem, 2.5vh, 1.25rem);
      font-weight: 600;
      color: var(--text-primary);
      text-align: center;
    }

    .warmup-progress {
      width: 100%;
      max-width: 280px;
      height: 10px;
      background: rgba(255, 255, 255, 0.8);
      border-radius: var(--radius-full);
      overflow: hidden;
      box-shadow: var(--shadow-inner);
    }

    .warmup-progress-bar {
      height: 100%;
      background:
        linear-gradient(90deg, var(--success-green) 0%, var(--accent-mint) 100%);
      width: 0%;
      transition: width var(--anim-medium) var(--ease-out-soft);
      border-radius: var(--radius-full);
    }

    .warmup-continue-btn {
      background:
        linear-gradient(180deg, var(--success-green) 0%, #5BC06A 100%);
      color: var(--text-inverse);
      border: none;
      padding: var(--space-md) var(--space-xl);
      border-radius: var(--radius-full);
      font-family: var(--font-display);
      font-size: var(--text-lg);
      font-weight: 600;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: var(--space-sm);
      transition: all var(--anim-fast) var(--ease-out-soft);
      box-shadow:
        0 4px 0 rgba(70, 160, 90, 0.5),
        var(--shadow-mint);
      animation: warmup-pulse 2s ease-in-out infinite;
    }

    .warmup-continue-btn:hover {
      transform: translateY(-2px);
      box-shadow:
        0 6px 0 rgba(70, 160, 90, 0.4),
        0 4px 16px rgba(125, 213, 144, 0.4);
    }

    .warmup-continue-btn:active {
      transform: translateY(2px);
      box-shadow:
        0 2px 0 rgba(70, 160, 90, 0.5),
        var(--shadow-sm);
      animation: none;
    }

    .warmup-continue-btn .arrow {
      font-size: 1.4rem;
    }

    /* Phonics Focus Box - explicit instruction for digraphs/patterns */
    .phonics-focus-box {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: var(--space-sm);
      background: linear-gradient(135deg, var(--accent-lavender-pale) 0%, var(--accent-mint-pale) 100%);
      padding: var(--space-sm) var(--space-md);
      border-radius: var(--radius-lg);
      margin-bottom: var(--space-md);
      box-shadow: var(--shadow-sm);
      flex-wrap: wrap;
    }

    .phonics-label {
      font-family: var(--font-display);
      font-size: var(--text-sm);
      color: var(--text-secondary);
      font-weight: 600;
    }

    .phonics-pattern {
      font-family: var(--font-display);
      font-size: var(--text-2xl);
      font-weight: 700;
      color: var(--accent-lavender);
      background: white;
      padding: var(--space-2xs) var(--space-sm);
      border-radius: var(--radius-md);
      box-shadow: var(--shadow-sm);
      letter-spacing: 0.1em;
    }

    .phonics-example {
      font-size: var(--text-sm);
      color: var(--text-secondary);
      font-style: italic;
    }

    /* Sight Word Reminder */
    .sight-word-reminder {
      display: flex;
      align-items: center;
      gap: var(--space-sm);
      background: var(--accent-golden-pale);
      padding: var(--space-sm) var(--space-md);
      border-radius: var(--radius-lg);
      margin-top: var(--space-md);
      box-shadow: var(--shadow-xs);
    }

    .reminder-icon {
      font-size: 1.2rem;
    }

    .reminder-text {
      font-size: var(--text-sm);
      color: var(--text-secondary);
    }

    /* Sight word indicator on warmup cards */
    .warmup-word-card.sight-word::before {
      content: 'SW';
      position: absolute;
      top: -8px;
      right: -8px;
      font-size: 0.7rem;
      font-weight: 800;
      letter-spacing: 0.04em;
      color: var(--text-inverse);
      background: var(--accent-coral);
      padding: 4px 6px;
      border-radius: 999px;
      box-shadow: var(--shadow-sm);
      filter: none;
    }

    /* Digraph highlighting on warmup cards */
    .warmup-word-card.has-digraph .warmup-word-text {
      position: relative;
    }

    .digraph-highlight {
      color: var(--accent-lavender);
      font-weight: 700;
      text-decoration: underline;
      text-decoration-color: var(--accent-lavender-soft);
      text-decoration-thickness: 3px;
    }

    body.calm-mode .digraph-highlight {
      text-decoration: none;
    }

    @keyframes warmup-pulse {

      0%,
      100% {
        box-shadow:
          0 4px 0 rgba(70, 160, 90, 0.5),
          var(--shadow-mint);
      }

      50% {
        box-shadow:
          0 4px 0 rgba(70, 160, 90, 0.5),
          0 4px 20px rgba(125, 213, 144, 0.5);
      }
    }

	    /* ===== RESTAURANT SCREEN ===== */
	    .restaurant-screen {
	      --restaurant-scene-image: none;
	      background:
	        radial-gradient(ellipse at 50% 0%, var(--accent-golden-pale) 0%, transparent 50%),
	        var(--bg-cream-warm);
	      padding: clamp(0.75rem, 1.5vh, 1.5rem);
      padding-bottom: calc(clamp(0.75rem, 1.5vh, 1.5rem) + env(safe-area-inset-bottom, 0px));
      display: flex;
      flex-direction: column;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
	      gap: clamp(0.5rem, 1vh, 1rem);
	      position: relative;
	    }

	    /* Auto mode: hide manual buttons, keep a simple â€œGoing to Floor â€¦â€ label. */
	    .elevator-screen.elevator-auto-mode .floor-btn {
	      display: none;
	    }

	    .elevator-screen.elevator-auto-mode .panel-title {
	      font-size: 0.95rem;
	      border-bottom: none;
	      padding-bottom: 0;
	      margin-bottom: 0;
	    }

	    /* Scenic â€œfloorâ€ backdrop (set per passage via JS). */
	    .restaurant-screen::before {
	      content: '';
	      position: absolute;
	      top: 0;
	      left: 0;
	      right: 0;
	      height: clamp(320px, 46vh, 520px);
	      background-image: var(--restaurant-scene-image);
	      background-size: cover;
	      background-position: center;
	      opacity: 0.25;
	      filter: blur(2px) saturate(1.1) contrast(1.03);
	      transform: scale(1.03);
	      pointer-events: none;
	      z-index: 0;
	      mask-image: linear-gradient(to bottom, rgba(0, 0, 0, 1) 0%, rgba(0, 0, 0, 0.85) 55%, rgba(0, 0, 0, 0.25) 100%);
	      -webkit-mask-image: linear-gradient(to bottom, rgba(0, 0, 0, 1) 0%, rgba(0, 0, 0, 0.85) 55%, rgba(0, 0, 0, 0.25) 100%);
	    }

	    .restaurant-screen>* {
	      position: relative;
	      z-index: 1;
	    }

	    /* Calm mode: keep the scenic backdrop softer. */
	    body.calm-mode .restaurant-screen::before {
	      opacity: 0.16;
	      filter: blur(3px) saturate(0.95) contrast(1.02);
	    }

    /* Desktop: tighten vertical spacing so lesson cards sit higher. */
    @media (min-width: 900px) {
      .restaurant-screen {
        padding-top: 0.5rem;
        gap: 0.5rem;
      }

      .restaurant-header {
        padding-top: 2px;
        padding-bottom: 0;
      }

      .mrt-progress-bar {
        margin-top: 6px;
        margin-bottom: 10px;
        padding-top: 10px;
        padding-bottom: 10px;
      }
    }

    /* === THEMED ENVIRONMENTAL BACKGROUNDS === */
    /* Subtle ambiance that creates sense of place without distraction */

    /* Fruit Stand - Golden Orchard Glow */
    .theme-fruit .restaurant-screen {
      background:
        radial-gradient(ellipse at 50% -20%, rgba(255, 215, 77, 0.12) 0%, transparent 60%),
        radial-gradient(ellipse at -10% 50%, rgba(107, 203, 119, 0.08) 0%, transparent 50%),
        radial-gradient(ellipse at 110% 50%, rgba(255, 140, 66, 0.08) 0%, transparent 50%),
        var(--bg-cream-warm);
    }

    /* Drink Bar - Cool Refreshing Mist */
    .theme-drink .restaurant-screen {
      background:
        radial-gradient(ellipse at 50% -20%, rgba(72, 202, 228, 0.1) 0%, transparent 60%),
        radial-gradient(ellipse at -10% 80%, rgba(144, 224, 239, 0.06) 0%, transparent 50%),
        radial-gradient(ellipse at 110% 80%, rgba(0, 180, 216, 0.06) 0%, transparent 50%),
        var(--bg-cream-warm);
    }

    /* Bakery - Warm Cozy Hearth */
    .theme-bakery .restaurant-screen {
      background:
        radial-gradient(ellipse at 50% -20%, rgba(255, 212, 163, 0.15) 0%, transparent 60%),
        radial-gradient(ellipse at 0% 100%, rgba(201, 168, 124, 0.08) 0%, transparent 50%),
        radial-gradient(ellipse at 100% 100%, rgba(222, 184, 135, 0.08) 0%, transparent 50%),
        var(--bg-cream-warm);
    }

    /* Pizza Place - Tuscan Sunset Warmth */
    .theme-pizza .restaurant-screen {
      background:
        radial-gradient(ellipse at 50% -20%, rgba(255, 195, 160, 0.12) 0%, transparent 60%),
        radial-gradient(ellipse at -10% 50%, rgba(152, 216, 170, 0.07) 0%, transparent 50%),
        radial-gradient(ellipse at 110% 50%, rgba(255, 107, 107, 0.07) 0%, transparent 50%),
        var(--bg-cream-warm);
    }

    /* Ice Cream Shop - Pastel Candy Dreams */
    .theme-icecream .restaurant-screen {
      background:
        radial-gradient(ellipse at 50% -20%, rgba(255, 181, 232, 0.1) 0%, transparent 60%),
        radial-gradient(ellipse at -10% 80%, rgba(181, 222, 255, 0.08) 0%, transparent 50%),
        radial-gradient(ellipse at 110% 80%, rgba(220, 211, 255, 0.08) 0%, transparent 50%),
        var(--bg-cream-warm);
    }

    /* Fish Shop - Deep Ocean Depths */
    .theme-fishshop .restaurant-screen {
      background:
        radial-gradient(ellipse at 50% -20%, rgba(0, 180, 216, 0.1) 0%, transparent 60%),
        radial-gradient(ellipse at -10% 50%, rgba(32, 178, 170, 0.07) 0%, transparent 50%),
        radial-gradient(ellipse at 110% 50%, rgba(72, 202, 228, 0.07) 0%, transparent 50%),
        var(--bg-cream-warm);
    }

    /* Cheese Shop - Alpine Golden Glow */
    .theme-cheese .restaurant-screen {
      background:
        radial-gradient(ellipse at 50% -20%, rgba(255, 215, 0, 0.12) 0%, transparent 60%),
        radial-gradient(ellipse at -10% 80%, rgba(144, 238, 144, 0.08) 0%, transparent 50%),
        radial-gradient(ellipse at 110% 80%, rgba(255, 165, 0, 0.08) 0%, transparent 50%),
        var(--bg-cream-warm);
    }

    /* Noodle House - Asian Evening Lantern Glow */
    .theme-noodle .restaurant-screen {
      background:
        radial-gradient(ellipse at 50% -20%, rgba(255, 160, 122, 0.12) 0%, transparent 60%),
        radial-gradient(ellipse at -10% 50%, rgba(60, 179, 113, 0.07) 0%, transparent 50%),
        radial-gradient(ellipse at 110% 50%, rgba(255, 99, 71, 0.07) 0%, transparent 50%),
        var(--bg-cream-warm);
    }

    .restaurant-header {
      text-align: center;
      padding: clamp(0.25rem, 0.5vh, 0.75rem) 0;
    }

    .restaurant-icon {
      font-size: clamp(2rem, 5vh, 2.8rem);
      margin-bottom: var(--space-2xs);
      filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.1));
      animation: icon-float 3s ease-in-out infinite;
    }

    /* Restaurant hero image - HIDDEN to save space */
    .restaurant-hero {
      display: none;
    }

    /* Restaurant header - compact without hero */
    .restaurant-header {
      padding: 6px 16px 2px;
      text-align: center;
    }

	    .restaurant-name {
	      font-family: var(--font-display);
	      font-size: var(--text-lg);
	      font-weight: 700;
	      color: var(--text-primary);
	      margin: 0;
	    }

	    .lesson-floor-chip {
	      display: inline-flex;
	      align-items: center;
	      justify-content: center;
	      margin: 6px auto 0;
	      padding: 6px 12px;
	      border-radius: 999px;
	      font-family: var(--transit-font);
	      font-size: 0.78rem;
	      font-weight: 800;
	      letter-spacing: 0.08em;
	      text-transform: uppercase;
	      color: #455A64;
	      background: rgba(255, 255, 255, 0.72);
	      border: 1px solid rgba(69, 90, 100, 0.16);
	      box-shadow: 0 10px 24px rgba(0, 0, 0, 0.06);
	      width: fit-content;
	      backdrop-filter: blur(6px);
	    }

    /* ===== STORY SCENE ART (Food Adventure pilot stories) ===== */
    .story-scene-panel {
      width: 100%;
      max-width: 820px;
      margin: 8px auto 0;
      padding: 0 12px;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .story-scene-frame {
      position: relative;
      width: 100%;
      border-radius: 18px;
      overflow: hidden;
      border: 2px solid rgba(210, 180, 140, 0.35);
      box-shadow:
        0 10px 28px rgba(0, 0, 0, 0.12),
        0 2px 10px rgba(0, 0, 0, 0.06),
        inset 0 1px 0 rgba(255, 255, 255, 0.7);
      background: rgba(255, 255, 255, 0.65);
      aspect-ratio: 16 / 9;
    }

    .story-scene-frame img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
      transform: translateZ(0);
    }

    .story-scene-vignette {
      position: absolute;
      inset: 0;
      background:
        radial-gradient(circle at 40% 30%, rgba(255, 255, 255, 0.12) 0%, rgba(255, 255, 255, 0.0) 55%),
        linear-gradient(180deg, rgba(0, 0, 0, 0.00) 65%, rgba(0, 0, 0, 0.10) 100%);
      pointer-events: none;
    }

    .story-scene-caption {
      align-self: center;
      max-width: 760px;
      padding: 10px 14px;
      border-radius: 14px;
      background: rgba(255, 255, 255, 0.86);
      border: 1px solid rgba(69, 90, 100, 0.14);
      box-shadow: 0 6px 18px rgba(0, 0, 0, 0.08);
      font-family: var(--transit-font);
      font-size: 0.92rem;
      font-weight: 650;
      color: rgba(45, 45, 45, 0.92);
      text-align: center;
    }

    @media (max-width: 480px) {
      .story-scene-panel {
        padding: 0 10px;
      }
      .story-scene-frame {
        border-radius: 16px;
      }
    }

    /* ===== IMMERSIVE STORYBOOK MODE ===== */
    /* A magical reading experience that feels like stepping into a picture book */

    @import url('https://fonts.googleapis.com/css2?family=Crimson+Pro:ital,wght@0,400;0,500;0,600;1,400&family=Playfair+Display:wght@500;600;700&display=swap');

    :root {
      /* Storybook color palette - warm, golden-hour feeling */
      --story-cream: #FDF8F0;
      --story-cream-warm: #FAF0E4;
      --story-parchment: #F5EBD8;
      --story-gold: #D4A853;
      --story-gold-soft: #E8C97A;
      --story-gold-pale: #F5E6C4;
      --story-forest: #4A7C59;
      --story-forest-soft: #6A9B73;
      --story-rust: #C06C52;
      --story-rust-soft: #D89880;
      --story-ink: #2D2926;
      --story-ink-soft: #5A524D;

      /* Typography for storybook */
      --font-story-display: 'Playfair Display', 'Fredoka', serif;
      --font-story-body: 'Crimson Pro', 'Nunito', serif;
    }

    /* Full immersive storybook container */
    .storybook-mode #restaurantScreen {
      background:
        linear-gradient(135deg, var(--story-cream) 0%, var(--story-cream-warm) 50%, var(--story-parchment) 100%);
      position: relative;
      overflow-y: auto;
      overflow-x: hidden;
      -webkit-overflow-scrolling: touch;
    }

    /* Subtle paper texture overlay */
    .storybook-mode #restaurantScreen::before {
      content: '';
      position: fixed;
      inset: 0;
      background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.85' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)'/%3E%3C/svg%3E");
      opacity: 0.03;
      pointer-events: none;
      z-index: 0;
    }

    /* Hide standard header in storybook mode */
    .storybook-mode .restaurant-header {
      display: none;
    }

    /* Expanded scene panel for immersive experience */
    .storybook-mode .story-scene-panel {
      max-width: 100%;
      padding: 0;
      margin: 0;
      position: relative;
      z-index: 1;
    }

    .storybook-mode .story-scene-frame {
      border-radius: 0;
      border: none;
      aspect-ratio: 16 / 10;
      max-height: 45vh;
      box-shadow:
        0 8px 32px rgba(45, 41, 38, 0.15),
        inset 0 -40px 60px -30px rgba(253, 248, 240, 0.9);
    }

    .storybook-mode .story-scene-frame img {
      filter: saturate(1.05) contrast(1.02);
    }

    /* Golden frame accent at bottom of image */
    .storybook-mode .story-scene-frame::after {
      content: '';
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 4px;
      background: linear-gradient(90deg,
        transparent 0%,
        var(--story-gold-soft) 20%,
        var(--story-gold) 50%,
        var(--story-gold-soft) 80%,
        transparent 100%);
      opacity: 0.7;
    }

    /* Storybook reading section - the heart of the experience */
    .storybook-mode .reading-section {
      background:
        linear-gradient(180deg,
          rgba(253, 248, 240, 0.97) 0%,
          rgba(250, 240, 228, 0.95) 100%);
      border-radius: 24px 24px 0 0;
      margin-top: -20px;
      padding: clamp(24px, 5vw, 40px);
      padding-bottom: clamp(32px, 6vw, 48px);
      position: relative;
      z-index: 2;
      border: none;
      box-shadow:
        0 -8px 32px rgba(45, 41, 38, 0.08),
        inset 0 1px 0 rgba(255, 255, 255, 0.9);
    }

    /* Decorative corner flourishes */
    .storybook-mode .reading-section::before,
    .storybook-mode .reading-section::after {
      content: 'âœ¦';
      position: absolute;
      top: 16px;
      font-size: 14px;
      color: var(--story-gold);
      opacity: 0.5;
    }
    .storybook-mode .reading-section::before { left: 20px; }
    .storybook-mode .reading-section::after { right: 20px; }

    /* Beautiful storybook typography */
    .storybook-mode .sentence-display {
      font-family: var(--font-story-body);
      font-size: clamp(1.35rem, 4.5vw, 1.75rem);
      line-height: 1.85;
      letter-spacing: 0.01em;
      color: var(--story-ink);
      text-align: center;
      max-width: 680px;
      margin: 0 auto;
      padding: clamp(16px, 4vw, 32px) 0;
    }

    .storybook-mode .sentence-display .word {
      display: inline;
      padding: 2px 0;
      border-radius: 4px;
      transition: all 0.2s ease;
      cursor: pointer;
    }

    .storybook-mode .sentence-display .word:hover {
      background: var(--story-gold-pale);
    }

    .storybook-mode .sentence-display .word.highlighted {
      background: linear-gradient(135deg, var(--story-gold-soft) 0%, var(--story-gold) 100%);
      color: var(--story-ink);
      padding: 2px 4px;
      margin: 0 -2px;
      box-shadow: 0 2px 8px rgba(212, 168, 83, 0.3);
      animation: storybook-word-glow 0.4s ease;
    }

    @keyframes storybook-word-glow {
      0% { transform: scale(1); }
      50% { transform: scale(1.05); }
      100% { transform: scale(1); }
    }

    .storybook-mode .sentence-display .word.sight-word {
      color: var(--story-forest);
      font-weight: 500;
    }

    .storybook-mode .sentence-display .word.focus-word {
      color: var(--story-rust);
      font-weight: 600;
      border-bottom: 2px dashed var(--story-rust-soft);
    }

    /* Story chapter indicator */
    .storybook-chapter-indicator {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 12px;
      padding: 12px 0;
      margin-bottom: 8px;
    }

    .storybook-chapter-line {
      flex: 1;
      max-width: 60px;
      height: 1px;
      background: linear-gradient(90deg, transparent, var(--story-gold-soft), transparent);
    }

    .storybook-chapter-icon {
      font-size: 1.5rem;
      filter: drop-shadow(0 2px 4px rgba(212, 168, 83, 0.3));
    }

    /* Sight word focus card - storybook style */
    .storybook-mode .sight-word-focus {
      background: linear-gradient(135deg, var(--story-cream) 0%, var(--story-gold-pale) 100%);
      border: 2px solid var(--story-gold-soft);
      border-radius: 16px;
      padding: 12px 20px;
      margin: 16px auto;
      max-width: fit-content;
      box-shadow:
        0 4px 16px rgba(212, 168, 83, 0.2),
        inset 0 1px 0 rgba(255, 255, 255, 0.8);
    }

    .storybook-mode .sight-word-focus .focus-word {
      font-family: var(--font-story-display);
      font-size: 1.5rem;
      font-weight: 600;
      color: var(--story-rust);
      padding: 4px 12px;
      background: rgba(255, 255, 255, 0.7);
      border-radius: 8px;
      margin: 0 8px;
    }

    /* Audio controls - elegant storybook buttons */
    .storybook-mode .audio-controls {
      display: flex;
      justify-content: center;
      gap: 12px;
      margin-top: 20px;
      padding-top: 20px;
      border-top: 1px solid var(--story-gold-pale);
    }

    .storybook-mode .audio-btn {
      font-family: var(--font-story-body);
      font-size: 1rem;
      font-weight: 500;
      color: var(--story-ink-soft);
      background: linear-gradient(180deg, #FFFFFF 0%, var(--story-cream) 100%);
      border: 2px solid var(--story-gold-soft);
      border-radius: 999px;
      padding: 12px 24px;
      cursor: pointer;
      transition: all 0.25s ease;
      box-shadow: 0 4px 12px rgba(212, 168, 83, 0.15);
    }

    .storybook-mode .audio-btn:hover {
      background: linear-gradient(180deg, var(--story-gold-pale) 0%, var(--story-gold-soft) 100%);
      border-color: var(--story-gold);
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(212, 168, 83, 0.25);
    }

    .storybook-mode .audio-btn:active {
      transform: translateY(0);
    }

    /* Continue button - storybook style */
    .storybook-mode #continueBtn {
      font-family: var(--font-story-display);
      font-size: 1.1rem;
      font-weight: 600;
      color: #FFFFFF;
      background: linear-gradient(135deg, var(--story-forest) 0%, var(--story-forest-soft) 100%);
      border: none;
      border-radius: 999px;
      padding: 16px 40px;
      margin: 24px auto 0;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow:
        0 6px 20px rgba(74, 124, 89, 0.3),
        inset 0 1px 0 rgba(255, 255, 255, 0.2);
    }

    .storybook-mode #continueBtn:hover {
      transform: translateY(-3px) scale(1.02);
      box-shadow:
        0 10px 30px rgba(74, 124, 89, 0.35),
        inset 0 1px 0 rgba(255, 255, 255, 0.2);
    }

    /* Story choice menu - beautiful card layout */
    .storybook-mode #menuSection {
      background: transparent;
      padding: clamp(20px, 5vw, 40px);
    }

    .storybook-mode .menu-prompt {
      font-family: var(--font-story-display);
      font-size: clamp(1.4rem, 4vw, 1.8rem);
      font-weight: 600;
      color: var(--story-ink);
      text-align: center;
      margin-bottom: 8px;
    }

    .storybook-mode .menu-story-hint {
      font-family: var(--font-story-body);
      font-size: 1rem;
      font-style: italic;
      color: var(--story-ink-soft);
      text-align: center;
      margin-bottom: 24px;
    }

    .storybook-mode .menu-grid {
      display: flex;
      flex-direction: column;
      gap: 16px;
      max-width: 500px;
      margin: 0 auto;
    }

    .storybook-mode .menu-item {
      display: flex;
      align-items: center;
      gap: 16px;
      padding: 20px 24px;
      background:
        linear-gradient(135deg,
          rgba(255, 255, 255, 0.95) 0%,
          rgba(253, 248, 240, 0.9) 100%);
      border: 2px solid var(--story-gold-pale);
      border-radius: 16px;
      cursor: pointer;
      transition: all 0.3s ease;
      text-align: left;
      box-shadow: 0 4px 16px rgba(45, 41, 38, 0.06);
    }

    .storybook-mode .menu-item:hover {
      border-color: var(--story-gold);
      transform: translateX(8px);
      box-shadow:
        0 8px 24px rgba(212, 168, 83, 0.2),
        -4px 0 0 var(--story-gold);
    }

    .storybook-mode .menu-item.selected {
      border-color: var(--story-forest);
      background: linear-gradient(135deg, var(--story-cream) 0%, #E8F5E9 100%);
      box-shadow:
        0 8px 24px rgba(74, 124, 89, 0.2),
        -4px 0 0 var(--story-forest);
    }

    .storybook-mode .menu-item .item-icon {
      font-size: 2rem;
      flex-shrink: 0;
      width: 48px;
      height: 48px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: var(--story-gold-pale);
      border-radius: 12px;
    }

    .storybook-mode .menu-item .item-name {
      font-family: var(--font-story-display);
      font-size: 1.2rem;
      font-weight: 600;
      color: var(--story-ink);
      display: block;
    }

    .storybook-mode .menu-item .item-desc {
      font-family: var(--font-story-body);
      font-size: 0.95rem;
      color: var(--story-ink-soft);
      display: block;
      margin-top: 2px;
    }

    /* Question section - storybook style */
    .storybook-mode #questionSection {
      background:
        linear-gradient(180deg,
          rgba(253, 248, 240, 0.97) 0%,
          rgba(250, 240, 228, 0.95) 100%);
      border-radius: 24px;
      padding: clamp(24px, 5vw, 40px);
      margin: 16px;
      border: 2px solid var(--story-gold-pale);
      box-shadow: 0 8px 32px rgba(45, 41, 38, 0.08);
    }

    .storybook-mode .question-label {
      font-family: var(--font-story-display);
      font-size: 0.9rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      color: var(--story-gold);
      text-align: center;
      margin-bottom: 8px;
    }

    .storybook-mode .passage-display {
      font-family: var(--font-story-body);
      font-size: clamp(1.15rem, 3.5vw, 1.35rem);
      font-style: italic;
      color: var(--story-ink-soft);
      text-align: center;
      padding: 16px 24px;
      margin: 16px 0;
      background: rgba(255, 255, 255, 0.6);
      border-left: 3px solid var(--story-gold-soft);
      border-radius: 0 12px 12px 0;
    }

    .storybook-mode .question-text {
      font-family: var(--font-story-display);
      font-size: clamp(1.3rem, 4vw, 1.6rem);
      font-weight: 600;
      color: var(--story-ink);
      text-align: center;
      margin: 20px 0;
    }

    .storybook-mode .answer-grid {
      display: flex;
      flex-direction: column;
      gap: 12px;
      max-width: 400px;
      margin: 24px auto 0;
    }

    .storybook-mode .answer-btn {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 16px 20px;
      background: #FFFFFF;
      border: 2px solid var(--story-gold-pale);
      border-radius: 12px;
      cursor: pointer;
      transition: all 0.25s ease;
      text-align: left;
    }

    .storybook-mode .answer-btn:hover {
      border-color: var(--story-gold);
      background: var(--story-gold-pale);
      transform: scale(1.02);
    }

    .storybook-mode .answer-btn.correct {
      border-color: var(--story-forest);
      background: linear-gradient(135deg, #E8F5E9 0%, #C8E6C9 100%);
      animation: storybook-correct 0.5s ease;
    }

    .storybook-mode .answer-btn.incorrect {
      border-color: var(--story-rust);
      background: linear-gradient(135deg, #FFEBEE 0%, #FFCDD2 100%);
      animation: storybook-shake 0.4s ease;
    }

    @keyframes storybook-correct {
      0% { transform: scale(1); }
      30% { transform: scale(1.05); }
      100% { transform: scale(1); }
    }

    @keyframes storybook-shake {
      0%, 100% { transform: translateX(0); }
      20% { transform: translateX(-8px); }
      40% { transform: translateX(8px); }
      60% { transform: translateX(-4px); }
      80% { transform: translateX(4px); }
    }

    .storybook-mode .answer-btn .answer-icon {
      font-size: 1.5rem;
    }

    .storybook-mode .answer-btn .answer-text {
      font-family: var(--font-story-body);
      font-size: 1.15rem;
      color: var(--story-ink);
    }

    /* Page turn animation */
    @keyframes storybook-page-enter {
      0% {
        opacity: 0;
        transform: translateX(30px) rotateY(-5deg);
      }
      100% {
        opacity: 1;
        transform: translateX(0) rotateY(0);
      }
    }

    .storybook-mode .reading-section,
    .storybook-mode #menuSection,
    .storybook-mode #questionSection {
      animation: storybook-page-enter 0.5s ease-out;
    }

    /* Story ending celebration */
    .storybook-ending-card {
      text-align: center;
      padding: clamp(32px, 6vw, 48px);
      background:
        linear-gradient(135deg,
          var(--story-cream) 0%,
          var(--story-gold-pale) 50%,
          var(--story-cream-warm) 100%);
      border-radius: 24px;
      border: 3px solid var(--story-gold);
      margin: 24px;
      box-shadow:
        0 12px 40px rgba(212, 168, 83, 0.25),
        inset 0 1px 0 rgba(255, 255, 255, 0.9);
    }

    .storybook-ending-icon {
      font-size: 4rem;
      margin-bottom: 16px;
      animation: storybook-bounce 1s ease infinite;
    }

    @keyframes storybook-bounce {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-10px); }
    }

    .storybook-ending-title {
      font-family: var(--font-story-display);
      font-size: clamp(1.8rem, 5vw, 2.4rem);
      font-weight: 700;
      color: var(--story-ink);
      margin-bottom: 12px;
    }

    .storybook-ending-summary {
      font-family: var(--font-story-body);
      font-size: 1.15rem;
      color: var(--story-ink-soft);
      max-width: 400px;
      margin: 0 auto 24px;
      line-height: 1.6;
    }

    .storybook-ending-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      justify-content: center;
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       ITERATION 1: Scene Transitions, Chapter Headers, Progress, Ambient Effects
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

    /* Ambient magical floating particles */
    .storybook-mode #restaurantScreen::after {
      content: '';
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: 100;
      background-image:
        radial-gradient(2px 2px at 10% 20%, var(--story-gold-soft) 50%, transparent 100%),
        radial-gradient(2px 2px at 80% 30%, var(--story-gold) 50%, transparent 100%),
        radial-gradient(1.5px 1.5px at 30% 70%, var(--story-gold-soft) 50%, transparent 100%),
        radial-gradient(1px 1px at 60% 50%, var(--story-gold) 50%, transparent 100%),
        radial-gradient(2px 2px at 90% 80%, var(--story-gold-soft) 50%, transparent 100%),
        radial-gradient(1.5px 1.5px at 15% 90%, var(--story-gold) 50%, transparent 100%);
      background-size: 200px 200px;
      animation: storybook-sparkle-drift 20s linear infinite;
      opacity: 0.4;
    }

    @keyframes storybook-sparkle-drift {
      0% { transform: translateY(0) translateX(0); opacity: 0.4; }
      50% { opacity: 0.6; }
      100% { transform: translateY(-100px) translateX(20px); opacity: 0.4; }
    }

    /* Beautiful chapter header with decorative lines */
    .storybook-chapter-header {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
      padding: 16px 24px;
      margin-bottom: 20px;
      animation: storybook-chapter-reveal 0.8s ease-out;
    }

    .storybook-chapter-header .chapter-ornament {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 16px;
      width: 100%;
    }

    .storybook-chapter-header .ornament-line {
      flex: 1;
      max-width: 80px;
      height: 2px;
      background: linear-gradient(90deg,
        transparent,
        var(--story-gold-soft) 30%,
        var(--story-gold) 50%,
        var(--story-gold-soft) 70%,
        transparent);
    }

    .storybook-chapter-header .ornament-icon {
      font-size: 1.2rem;
      color: var(--story-gold);
      filter: drop-shadow(0 2px 4px rgba(212, 168, 83, 0.4));
    }

    .storybook-chapter-header .chapter-label {
      font-family: var(--font-story-display);
      font-size: clamp(0.85rem, 2.5vw, 1rem);
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.2em;
      color: var(--story-ink-soft);
    }

    .storybook-chapter-header .chapter-title {
      font-family: var(--font-story-display);
      font-size: clamp(1.4rem, 4vw, 1.8rem);
      font-weight: 700;
      color: var(--story-ink);
      text-align: center;
      line-height: 1.3;
    }

    @keyframes storybook-chapter-reveal {
      0% {
        opacity: 0;
        transform: translateY(-15px);
      }
      100% {
        opacity: 1;
        transform: translateY(0);
      }
    }

    /* Reading progress indicator */
    .storybook-progress-bar {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      height: 4px;
      background: var(--story-cream);
      z-index: 200;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    }

    .storybook-progress-fill {
      height: 100%;
      background: linear-gradient(90deg,
        var(--story-gold) 0%,
        var(--story-forest) 100%);
      transition: width 0.5s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow: 2px 0 8px var(--story-gold);
    }

    .storybook-progress-chapter {
      position: fixed;
      top: 8px;
      right: 16px;
      font-family: var(--font-story-body);
      font-size: 0.75rem;
      color: var(--story-ink-soft);
      background: rgba(253, 248, 240, 0.95);
      padding: 4px 12px;
      border-radius: 12px;
      z-index: 201;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      border: 1px solid var(--story-gold-pale);
    }

    /* Enhanced scene image transitions */
    .storybook-mode .story-scene-frame {
      transition: opacity 0.6s ease, transform 0.6s ease;
    }

    .storybook-mode .story-scene-frame.scene-transitioning {
      opacity: 0.3;
      transform: scale(1.02);
    }

    .storybook-mode .story-scene-frame img {
      transition: filter 0.6s ease, transform 0.6s ease;
    }

    /* Staggered text reveal animation */
    @keyframes storybook-word-reveal {
      0% {
        opacity: 0;
        transform: translateY(8px);
      }
      100% {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .storybook-mode .sentence-display.revealing .word {
      opacity: 0;
      animation: storybook-word-reveal 0.4s ease forwards;
    }

    /* Each word gets a staggered delay - set via inline style */
    .storybook-mode .sentence-display.revealing .word:nth-child(1) { animation-delay: 0.05s; }
    .storybook-mode .sentence-display.revealing .word:nth-child(2) { animation-delay: 0.1s; }
    .storybook-mode .sentence-display.revealing .word:nth-child(3) { animation-delay: 0.15s; }
    .storybook-mode .sentence-display.revealing .word:nth-child(4) { animation-delay: 0.2s; }
    .storybook-mode .sentence-display.revealing .word:nth-child(5) { animation-delay: 0.25s; }
    .storybook-mode .sentence-display.revealing .word:nth-child(6) { animation-delay: 0.3s; }
    .storybook-mode .sentence-display.revealing .word:nth-child(7) { animation-delay: 0.35s; }
    .storybook-mode .sentence-display.revealing .word:nth-child(8) { animation-delay: 0.4s; }
    .storybook-mode .sentence-display.revealing .word:nth-child(9) { animation-delay: 0.45s; }
    .storybook-mode .sentence-display.revealing .word:nth-child(10) { animation-delay: 0.5s; }
    .storybook-mode .sentence-display.revealing .word:nth-child(n+11) { animation-delay: 0.55s; }

    /* Menu items entrance animation */
    @keyframes storybook-choice-enter {
      0% {
        opacity: 0;
        transform: translateX(-20px);
      }
      100% {
        opacity: 1;
        transform: translateX(0);
      }
    }

    .storybook-mode .menu-item {
      opacity: 0;
      animation: storybook-choice-enter 0.5s ease forwards;
    }

    .storybook-mode .menu-item:nth-child(1) { animation-delay: 0.1s; }
    .storybook-mode .menu-item:nth-child(2) { animation-delay: 0.2s; }
    .storybook-mode .menu-item:nth-child(3) { animation-delay: 0.3s; }
    .storybook-mode .menu-item:nth-child(4) { animation-delay: 0.4s; }

    /* Reading tip callout with subtle animation */
    .storybook-reading-tip {
      display: flex;
      align-items: flex-start;
      gap: 12px;
      padding: 12px 16px;
      margin: 16px 0;
      background: linear-gradient(135deg, var(--story-gold-pale) 0%, var(--story-cream) 100%);
      border-left: 3px solid var(--story-gold);
      border-radius: 0 12px 12px 0;
      animation: storybook-tip-pulse 3s ease infinite;
    }

    .storybook-reading-tip .tip-icon {
      font-size: 1.2rem;
      flex-shrink: 0;
    }

    .storybook-reading-tip .tip-text {
      font-family: var(--font-story-body);
      font-size: 0.95rem;
      font-style: italic;
      color: var(--story-ink-soft);
      line-height: 1.5;
    }

    @keyframes storybook-tip-pulse {
      0%, 100% { box-shadow: 0 2px 8px rgba(212, 168, 83, 0.15); }
      50% { box-shadow: 0 2px 16px rgba(212, 168, 83, 0.3); }
    }

    /* Correct answer celebration confetti burst */
    @keyframes storybook-confetti {
      0% {
        transform: scale(1);
        box-shadow:
          0 0 0 0 rgba(74, 124, 89, 0.5),
          0 0 0 0 rgba(212, 168, 83, 0.5);
      }
      50% {
        box-shadow:
          0 0 0 15px rgba(74, 124, 89, 0),
          0 0 0 25px rgba(212, 168, 83, 0);
      }
      100% {
        transform: scale(1);
        box-shadow:
          0 0 0 0 rgba(74, 124, 89, 0),
          0 0 0 0 rgba(212, 168, 83, 0);
      }
    }

    .storybook-mode .answer-btn.correct {
      animation: storybook-correct 0.5s ease, storybook-confetti 0.8s ease;
    }

    /* Mobile optimizations for storybook */
    @media (max-width: 600px) {
      .storybook-mode .story-scene-frame {
        max-height: 30vh;
      }

      .storybook-mode .reading-section {
        border-radius: 20px 20px 0 0;
        padding: 20px 16px 28px;
        padding-bottom: calc(28px + env(safe-area-inset-bottom, 20px));
      }

      .storybook-mode .menu-item {
        padding: 16px 18px;
      }

      .storybook-mode .menu-item .item-icon {
        width: 40px;
        height: 40px;
        font-size: 1.6rem;
      }

      /* Ensure continue button is always visible on mobile */
      .storybook-mode #continueBtn {
        margin-bottom: env(safe-area-inset-bottom, 16px);
      }

      /* Add bottom padding to scrollable container */
      .storybook-mode #restaurantScreen {
        padding-bottom: 24px;
      }

      /* Smaller progress indicator on mobile */
      .storybook-progress-chapter {
        font-size: 0.65rem;
        padding: 3px 10px;
        top: 6px;
        right: 12px;
      }

      /* Reduce sparkle intensity on mobile for performance */
      .storybook-mode #restaurantScreen::after {
        opacity: 0.25;
        animation-duration: 30s;
      }

      /* Chapter header adjustments */
      .storybook-chapter-header {
        padding: 12px 16px;
        margin-bottom: 16px;
      }
    }

    /* Reduced motion preference */
    @media (prefers-reduced-motion: reduce) {
      .storybook-mode #restaurantScreen::after {
        animation: none;
        opacity: 0.2;
      }

      .storybook-mode .sentence-display.revealing .word {
        animation: none;
        opacity: 1;
      }

      .storybook-mode .menu-item {
        animation: none;
        opacity: 1;
      }

      .storybook-progress-fill {
        transition: none;
      }
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       ITERATION 2: Micro-interactions, Sound Hooks, Enhanced Celebrations
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

    /* Floating home button - subtle and elegant */
    .storybook-home-btn {
      position: fixed;
      top: 16px;
      left: 16px;
      width: 44px;
      height: 44px;
      border-radius: 50%;
      background: rgba(253, 248, 240, 0.95);
      border: 2px solid var(--story-gold-soft);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
      cursor: pointer;
      z-index: 202;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.2rem;
      transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
      backdrop-filter: blur(8px);
    }

    .storybook-home-btn:hover {
      transform: scale(1.1);
      border-color: var(--story-gold);
      box-shadow: 0 6px 20px rgba(212, 168, 83, 0.25);
    }

    .storybook-home-btn:active {
      transform: scale(0.95);
    }

    /* Enhanced continue button with pulse effect */
    .storybook-mode #continueBtn {
      position: relative;
      overflow: hidden;
    }

    .storybook-mode #continueBtn::before {
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(90deg,
        transparent,
        rgba(255, 255, 255, 0.3),
        transparent);
      transform: translateX(-100%);
      animation: storybook-shimmer 2.5s ease infinite;
    }

    @keyframes storybook-shimmer {
      0% { transform: translateX(-100%); }
      50%, 100% { transform: translateX(100%); }
    }

    /* Choice cards - enhanced hover with 3D lift */
    .storybook-mode .menu-item {
      transform-style: preserve-3d;
      perspective: 1000px;
    }

    .storybook-mode .menu-item:hover {
      transform: translateX(8px) translateY(-2px) rotateY(-2deg);
      box-shadow:
        0 12px 32px rgba(212, 168, 83, 0.2),
        -6px 0 0 var(--story-gold);
    }

    .storybook-mode .menu-item:active {
      transform: translateX(8px) translateY(0) rotateY(0);
      transition-duration: 0.1s;
    }

    /* Icon bounce on choice hover */
    .storybook-mode .menu-item:hover .item-icon {
      animation: storybook-icon-bounce 0.5s ease;
    }

    @keyframes storybook-icon-bounce {
      0%, 100% { transform: scale(1); }
      30% { transform: scale(1.2); }
      50% { transform: scale(0.9); }
      70% { transform: scale(1.1); }
    }

    /* Question answer hover states - more inviting */
    .storybook-mode .answer-btn {
      position: relative;
      overflow: hidden;
    }

    .storybook-mode .answer-btn::after {
      content: '';
      position: absolute;
      left: 0;
      top: 0;
      width: 4px;
      height: 100%;
      background: var(--story-gold);
      transform: scaleY(0);
      transform-origin: top;
      transition: transform 0.3s ease;
    }

    .storybook-mode .answer-btn:hover::after {
      transform: scaleY(1);
    }

    /* Enhanced correct answer celebration */
    .storybook-mode .answer-btn.correct::before {
      content: 'âœ“';
      position: absolute;
      right: 16px;
      font-size: 1.5rem;
      color: var(--story-forest);
      animation: storybook-checkmark 0.5s ease forwards;
    }

    @keyframes storybook-checkmark {
      0% {
        opacity: 0;
        transform: scale(0) rotate(-45deg);
      }
      50% {
        transform: scale(1.3) rotate(0);
      }
      100% {
        opacity: 1;
        transform: scale(1) rotate(0);
      }
    }

    /* Star burst on correct answer */
    .storybook-mode .answer-btn.correct {
      position: relative;
    }

    .storybook-mode .answer-btn.correct .answer-icon {
      animation: storybook-star-spin 0.6s ease;
    }

    @keyframes storybook-star-spin {
      0% { transform: rotate(0) scale(1); }
      50% { transform: rotate(180deg) scale(1.3); }
      100% { transform: rotate(360deg) scale(1); }
    }

    /* Enhanced incorrect shake with red flash */
    .storybook-mode .answer-btn.incorrect {
      animation: storybook-shake 0.4s ease, storybook-red-flash 0.4s ease;
    }

    @keyframes storybook-red-flash {
      0%, 100% { background: linear-gradient(135deg, #FFEBEE 0%, #FFCDD2 100%); }
      50% { background: linear-gradient(135deg, #FFCDD2 0%, #EF9A9A 100%); }
    }

    /* Dramatic ending celebration overlay */
    .storybook-ending-celebration {
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: 300;
      overflow: hidden;
    }

    .storybook-ending-celebration.active {
      animation: storybook-celebration-fade 3s ease forwards;
    }

    @keyframes storybook-celebration-fade {
      0% { opacity: 1; }
      70% { opacity: 1; }
      100% { opacity: 0; }
    }

    /* Confetti particles for ending */
    .storybook-confetti-particle {
      position: absolute;
      width: 10px;
      height: 10px;
      animation: storybook-confetti-fall 3s ease-out forwards;
    }

    @keyframes storybook-confetti-fall {
      0% {
        transform: translateY(-20px) rotate(0) scale(0);
        opacity: 0;
      }
      10% {
        opacity: 1;
        transform: translateY(0) rotate(0) scale(1);
      }
      100% {
        transform: translateY(100vh) rotate(720deg) scale(0.5);
        opacity: 0;
      }
    }

    /* Ending card enhanced styling */
    .storybook-ending-card {
      animation: storybook-ending-entrance 0.8s cubic-bezier(0.34, 1.56, 0.64, 1);
    }

    @keyframes storybook-ending-entrance {
      0% {
        opacity: 0;
        transform: translateY(40px) scale(0.9);
      }
      100% {
        opacity: 1;
        transform: translateY(0) scale(1);
      }
    }

    /* Ending icon with glow pulse */
    .storybook-ending-icon {
      position: relative;
    }

    .storybook-ending-icon::after {
      content: '';
      position: absolute;
      inset: -10px;
      border-radius: 50%;
      background: radial-gradient(circle, var(--story-gold-soft) 0%, transparent 70%);
      animation: storybook-glow-pulse 2s ease infinite;
      z-index: -1;
    }

    @keyframes storybook-glow-pulse {
      0%, 100% { transform: scale(1); opacity: 0.5; }
      50% { transform: scale(1.2); opacity: 0.8; }
    }

    /* Sound effect data attributes for future integration */
    [data-sound="page-turn"] { --sound-trigger: 'page-turn'; }
    [data-sound="choice-select"] { --sound-trigger: 'choice-select'; }
    [data-sound="correct"] { --sound-trigger: 'correct'; }
    [data-sound="incorrect"] { --sound-trigger: 'incorrect'; }
    [data-sound="ending"] { --sound-trigger: 'ending'; }
    [data-sound="magic"] { --sound-trigger: 'magic'; }

    /* Word tap ripple effect */
    .storybook-mode .sentence-display .word {
      position: relative;
      overflow: hidden;
    }

    .storybook-mode .sentence-display .word::after {
      content: '';
      position: absolute;
      inset: 0;
      background: radial-gradient(circle, var(--story-gold-soft) 0%, transparent 70%);
      transform: scale(0);
      opacity: 0;
      border-radius: 4px;
    }

    .storybook-mode .sentence-display .word:active::after {
      animation: storybook-word-ripple 0.4s ease;
    }

    @keyframes storybook-word-ripple {
      0% {
        transform: scale(0);
        opacity: 0.8;
      }
      100% {
        transform: scale(2);
        opacity: 0;
      }
    }

    /* Mobile home button positioning */
    @media (max-width: 600px) {
      .storybook-home-btn {
        width: 40px;
        height: 40px;
        top: 12px;
        left: 12px;
        font-size: 1rem;
      }
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       ITERATION 3: Ken Burns, Drop Caps, Enhanced Typography, Parallax
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

    /* Ken Burns effect on scene images - gentle pan and zoom */
    .storybook-mode .story-scene-frame img {
      animation: storybook-ken-burns 15s ease-in-out infinite alternate;
      transform-origin: center center;
    }

    @keyframes storybook-ken-burns {
      0% {
        transform: scale(1) translate(0, 0);
      }
      100% {
        transform: scale(1.08) translate(-2%, -1%);
      }
    }

    /* Drop cap for chapter-starting paragraphs */
    .storybook-drop-cap {
      font-family: var(--font-story-display);
      font-size: clamp(3rem, 10vw, 4.5rem);
      font-weight: 700;
      float: left;
      line-height: 0.8;
      margin-right: 8px;
      margin-top: 4px;
      color: var(--story-rust);
      text-shadow: 2px 2px 0 var(--story-gold-pale);
    }

    .storybook-drop-cap::after {
      content: '';
      display: block;
      clear: both;
    }

    /* Enhanced sight word focus - glowing underline */
    .storybook-mode .sentence-display .word.sight-word {
      position: relative;
      color: var(--story-forest);
      font-weight: 600;
    }

    .storybook-mode .sentence-display .word.sight-word::before {
      content: '';
      position: absolute;
      bottom: -2px;
      left: 0;
      right: 0;
      height: 3px;
      background: linear-gradient(90deg,
        transparent,
        var(--story-forest-soft) 20%,
        var(--story-forest) 50%,
        var(--story-forest-soft) 80%,
        transparent);
      border-radius: 2px;
      animation: storybook-sight-word-pulse 2s ease infinite;
    }

    @keyframes storybook-sight-word-pulse {
      0%, 100% { opacity: 0.6; transform: scaleX(0.9); }
      50% { opacity: 1; transform: scaleX(1); }
    }

    /* Focus word badge - more prominent */
    .storybook-mode .sentence-display .word.focus-word {
      background: linear-gradient(135deg, var(--story-rust-soft) 0%, var(--story-rust) 100%);
      color: #FFFFFF;
      padding: 3px 8px;
      margin: 0 2px;
      border-radius: 6px;
      font-weight: 600;
      box-shadow: 0 2px 8px rgba(192, 108, 82, 0.3);
      animation: storybook-focus-word-glow 3s ease infinite;
    }

    @keyframes storybook-focus-word-glow {
      0%, 100% { box-shadow: 0 2px 8px rgba(192, 108, 82, 0.3); }
      50% { box-shadow: 0 4px 16px rgba(192, 108, 82, 0.5); }
    }

    /* Parallax depth container */
    .storybook-mode .reading-section {
      transform-style: preserve-3d;
      perspective: 1000px;
    }

    .storybook-mode .sentence-display {
      transform: translateZ(20px);
    }

    .storybook-mode .reading-section::before,
    .storybook-mode .reading-section::after {
      transform: translateZ(10px);
    }

    /* Story scene with vignette effect */
    .storybook-mode .story-scene-frame::before {
      content: '';
      position: absolute;
      inset: 0;
      background: radial-gradient(ellipse at center,
        transparent 60%,
        rgba(45, 41, 38, 0.15) 100%);
      pointer-events: none;
      z-index: 2;
    }

    /* Mood-based scene overlays */
    .storybook-scene-mood-warm::after {
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(180deg,
        rgba(255, 200, 100, 0.1) 0%,
        transparent 50%,
        rgba(255, 150, 50, 0.08) 100%);
      pointer-events: none;
      z-index: 1;
    }

    .storybook-scene-mood-magic::after {
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(180deg,
        rgba(212, 168, 83, 0.15) 0%,
        transparent 50%,
        rgba(180, 130, 200, 0.1) 100%);
      pointer-events: none;
      z-index: 1;
      animation: storybook-magic-shimmer 4s ease infinite;
    }

    @keyframes storybook-magic-shimmer {
      0%, 100% { opacity: 0.8; }
      50% { opacity: 1; }
    }

    .storybook-scene-mood-sunset::after {
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(180deg,
        rgba(255, 180, 120, 0.12) 0%,
        transparent 40%,
        rgba(255, 100, 80, 0.1) 100%);
      pointer-events: none;
      z-index: 1;
    }

    /* Decorative quote marks for story text */
    .storybook-quote-open,
    .storybook-quote-close {
      font-family: var(--font-story-display);
      font-size: 2rem;
      color: var(--story-gold);
      opacity: 0.4;
      line-height: 0.5;
      vertical-align: middle;
    }

    .storybook-quote-open {
      margin-right: 4px;
    }

    .storybook-quote-close {
      margin-left: 4px;
    }

    /* Enhanced reading tip with icon */
    .storybook-reading-tip {
      position: relative;
    }

    .storybook-reading-tip::before {
      content: '';
      position: absolute;
      left: -8px;
      top: 50%;
      transform: translateY(-50%);
      width: 16px;
      height: 16px;
      background: var(--story-gold);
      border-radius: 50%;
      box-shadow: 0 2px 8px rgba(212, 168, 83, 0.4);
    }

    /* Story title flourish */
    .storybook-story-title {
      font-family: var(--font-story-display);
      font-size: clamp(1.6rem, 5vw, 2.2rem);
      font-weight: 700;
      text-align: center;
      color: var(--story-ink);
      margin-bottom: 24px;
      position: relative;
      padding-bottom: 16px;
    }

    .storybook-story-title::after {
      content: '~';
      position: absolute;
      bottom: 0;
      left: 50%;
      transform: translateX(-50%);
      font-size: 1.5rem;
      color: var(--story-gold);
    }

    /* Scroll-triggered fade-in for content */
    .storybook-fade-in {
      opacity: 0;
      transform: translateY(20px);
      animation: storybook-scroll-reveal 0.6s ease forwards;
    }

    @keyframes storybook-scroll-reveal {
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    /* Text shadow for better readability over images */
    .storybook-mode .sentence-display {
      text-shadow: 0 1px 2px rgba(253, 248, 240, 0.8);
    }

    /* Page curl effect hint at bottom */
    .storybook-page-curl {
      position: absolute;
      bottom: 0;
      right: 0;
      width: 60px;
      height: 60px;
      background: linear-gradient(135deg,
        transparent 50%,
        rgba(212, 168, 83, 0.1) 50%,
        rgba(212, 168, 83, 0.2) 100%);
      clip-path: polygon(100% 0, 100% 100%, 0 100%);
      pointer-events: none;
      opacity: 0.6;
    }

    /* Mobile adjustments for iteration 3 */
    @media (max-width: 600px) {
      .storybook-drop-cap {
        font-size: clamp(2.5rem, 8vw, 3.5rem);
        margin-right: 6px;
      }

      .storybook-mode .story-scene-frame img {
        animation-duration: 20s; /* Slower on mobile for performance */
      }

      .storybook-story-title {
        font-size: clamp(1.4rem, 4.5vw, 1.8rem);
      }
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       ITERATION 4: Advanced Animations, Floating Elements, Celebrations
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

    /* Floating decorative leaves/petals */
    .storybook-floating-elements {
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: 50;
      overflow: hidden;
    }

    .storybook-floating-element {
      position: absolute;
      font-size: 1.5rem;
      opacity: 0;
      animation: storybook-float-down 12s ease-in-out infinite;
    }

    .storybook-floating-element:nth-child(1) { left: 5%; animation-delay: 0s; }
    .storybook-floating-element:nth-child(2) { left: 20%; animation-delay: 2s; }
    .storybook-floating-element:nth-child(3) { left: 40%; animation-delay: 4s; }
    .storybook-floating-element:nth-child(4) { left: 60%; animation-delay: 6s; }
    .storybook-floating-element:nth-child(5) { left: 80%; animation-delay: 8s; }
    .storybook-floating-element:nth-child(6) { left: 95%; animation-delay: 10s; }

    @keyframes storybook-float-down {
      0% {
        transform: translateY(-20px) rotate(0deg) scale(0.8);
        opacity: 0;
      }
      10% {
        opacity: 0.7;
      }
      50% {
        transform: translateY(50vh) rotate(180deg) scale(1);
        opacity: 0.5;
      }
      100% {
        transform: translateY(100vh) rotate(360deg) scale(0.6);
        opacity: 0;
      }
    }

    /* Typewriter effect for dramatic text */
    .storybook-typewriter .word {
      opacity: 0;
      animation: storybook-type-word 0.1s ease forwards;
    }

    @keyframes storybook-type-word {
      to { opacity: 1; }
    }

    /* Interactive word tooltip */
    .storybook-word-tooltip {
      position: absolute;
      bottom: calc(100% + 8px);
      left: 50%;
      transform: translateX(-50%) scale(0.9);
      background: var(--story-ink);
      color: var(--story-cream);
      padding: 8px 14px;
      border-radius: 8px;
      font-family: var(--font-story-body);
      font-size: 0.85rem;
      white-space: nowrap;
      opacity: 0;
      visibility: hidden;
      transition: all 0.25s cubic-bezier(0.34, 1.56, 0.64, 1);
      z-index: 100;
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);
    }

    .storybook-word-tooltip::after {
      content: '';
      position: absolute;
      top: 100%;
      left: 50%;
      transform: translateX(-50%);
      border: 6px solid transparent;
      border-top-color: var(--story-ink);
    }

    .storybook-mode .sentence-display .word:hover .storybook-word-tooltip,
    .storybook-mode .sentence-display .word:focus .storybook-word-tooltip {
      opacity: 1;
      visibility: visible;
      transform: translateX(-50%) scale(1);
    }

    /* Chapter milestone mini-celebration */
    .storybook-milestone {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(253, 248, 240, 0.98);
      padding: 24px 40px;
      border-radius: 20px;
      border: 3px solid var(--story-gold);
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.2);
      z-index: 400;
      text-align: center;
      animation: storybook-milestone-pop 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
    }

    .storybook-milestone-icon {
      font-size: 3rem;
      margin-bottom: 12px;
      animation: storybook-bounce 1s ease infinite;
    }

    .storybook-milestone-text {
      font-family: var(--font-story-display);
      font-size: 1.2rem;
      font-weight: 600;
      color: var(--story-ink);
    }

    @keyframes storybook-milestone-pop {
      0% {
        opacity: 0;
        transform: translate(-50%, -50%) scale(0.5);
      }
      70% {
        transform: translate(-50%, -50%) scale(1.1);
      }
      100% {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1);
      }
    }

    /* Page transition overlay */
    .storybook-page-transition {
      position: fixed;
      inset: 0;
      background: var(--story-cream);
      z-index: 500;
      pointer-events: none;
      opacity: 0;
    }

    .storybook-page-transition.active {
      animation: storybook-page-wipe 0.6s ease;
    }

    @keyframes storybook-page-wipe {
      0% {
        opacity: 0;
        transform: translateX(-100%);
      }
      40%, 60% {
        opacity: 1;
        transform: translateX(0);
      }
      100% {
        opacity: 0;
        transform: translateX(100%);
      }
    }

    /* Book spine shadow effect */
    .storybook-mode .reading-section {
      box-shadow:
        0 4px 20px rgba(139, 90, 43, 0.12),
        inset 2px 0 8px rgba(0, 0, 0, 0.03),
        inset -2px 0 8px rgba(0, 0, 0, 0.03);
    }

    /* Animated border for chapter cards */
    .storybook-chapter-header {
      position: relative;
    }

    .storybook-chapter-header::before {
      content: '';
      position: absolute;
      inset: -2px;
      border-radius: 16px;
      padding: 2px;
      background: linear-gradient(90deg,
        transparent,
        var(--story-gold-soft) 25%,
        var(--story-gold) 50%,
        var(--story-gold-soft) 75%,
        transparent);
      background-size: 200% 100%;
      animation: storybook-border-shimmer 3s linear infinite;
      -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
      mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
      -webkit-mask-composite: xor;
      mask-composite: exclude;
      opacity: 0.6;
    }

    @keyframes storybook-border-shimmer {
      0% { background-position: 200% 0; }
      100% { background-position: -200% 0; }
    }

    /* Enhanced question section entry */
    .storybook-mode #questionSection {
      animation:
        storybook-page-enter 0.5s ease-out,
        storybook-question-glow 2s ease 0.5s infinite;
    }

    @keyframes storybook-question-glow {
      0%, 100% {
        box-shadow: 0 8px 32px rgba(45, 41, 38, 0.08);
      }
      50% {
        box-shadow:
          0 8px 32px rgba(45, 41, 38, 0.08),
          0 0 40px rgba(212, 168, 83, 0.15);
      }
    }

    /* Success message popup */
    .storybook-success-popup {
      position: fixed;
      top: 20%;
      left: 50%;
      transform: translateX(-50%) translateY(-20px);
      background: linear-gradient(135deg, var(--story-forest) 0%, var(--story-forest-soft) 100%);
      color: #FFFFFF;
      padding: 16px 32px;
      border-radius: 16px;
      font-family: var(--font-story-display);
      font-size: 1.1rem;
      font-weight: 600;
      box-shadow: 0 8px 32px rgba(74, 124, 89, 0.4);
      z-index: 350;
      opacity: 0;
      animation: storybook-success-show 2s ease forwards;
    }

    @keyframes storybook-success-show {
      0% {
        opacity: 0;
        transform: translateX(-50%) translateY(-20px) scale(0.9);
      }
      20%, 80% {
        opacity: 1;
        transform: translateX(-50%) translateY(0) scale(1);
      }
      100% {
        opacity: 0;
        transform: translateX(-50%) translateY(-20px) scale(0.9);
      }
    }

    /* Reading streak indicator */
    .storybook-streak {
      display: flex;
      align-items: center;
      gap: 6px;
      position: fixed;
      bottom: 16px;
      right: 16px;
      background: rgba(253, 248, 240, 0.95);
      padding: 8px 14px;
      border-radius: 20px;
      font-family: var(--font-story-body);
      font-size: 0.85rem;
      color: var(--story-ink-soft);
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);
      z-index: 100;
      border: 1px solid var(--story-gold-pale);
    }

    .storybook-streak-icon {
      font-size: 1rem;
    }

    .storybook-streak-count {
      font-weight: 600;
      color: var(--story-forest);
    }

    /* Mobile adjustments for iteration 4 */
    @media (max-width: 600px) {
      .storybook-floating-element {
        font-size: 1.2rem;
      }

      .storybook-milestone {
        padding: 20px 28px;
        margin: 0 16px;
        width: calc(100% - 32px);
        max-width: 300px;
      }

      .storybook-streak {
        bottom: 12px;
        right: 12px;
        font-size: 0.75rem;
        padding: 6px 12px;
      }

      .storybook-success-popup {
        font-size: 1rem;
        padding: 14px 24px;
        max-width: calc(100% - 32px);
      }
    }

    /* Disable floating elements on reduced motion */
    @media (prefers-reduced-motion: reduce) {
      .storybook-floating-element {
        display: none;
      }

      .storybook-chapter-header::before {
        animation: none;
      }

      .storybook-page-transition.active {
        animation: none;
      }
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       ITERATION 5: Accessibility, Performance, Dark Mode, Final Polish
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

    /* GPU acceleration for smoother animations */
    .storybook-mode .story-scene-frame,
    .storybook-mode .menu-item,
    .storybook-mode .answer-btn,
    .storybook-mode #continueBtn,
    .storybook-floating-element {
      will-change: transform;
      backface-visibility: hidden;
    }

    /* Accessibility: Focus visible states */
    .storybook-mode .menu-item:focus-visible,
    .storybook-mode .answer-btn:focus-visible,
    .storybook-mode #continueBtn:focus-visible,
    .storybook-home-btn:focus-visible {
      outline: 3px solid var(--story-gold);
      outline-offset: 3px;
      box-shadow: 0 0 0 6px rgba(212, 168, 83, 0.3);
    }

    /* Accessibility: High contrast mode */
    @media (prefers-contrast: high) {
      .storybook-mode .sentence-display {
        color: #000000;
        text-shadow: none;
      }

      .storybook-mode .menu-item,
      .storybook-mode .answer-btn {
        border-width: 3px;
        border-color: #000000;
      }

      .storybook-mode #continueBtn {
        background: #006400;
        color: #FFFFFF;
      }
    }

    /* Accessibility: Screen reader only content */
    .storybook-sr-only {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }

    /* Dark mode support */
    @media (prefers-color-scheme: dark) {
      .storybook-mode {
        --story-cream: #1A1815;
        --story-cream-warm: #221F1A;
        --story-parchment: #2A2520;
        --story-ink: #F5EBD8;
        --story-ink-soft: #C8BEB0;
      }

      .storybook-mode #restaurantScreen {
        background: linear-gradient(135deg, #1A1815 0%, #221F1A 50%, #2A2520 100%);
      }

      .storybook-mode .reading-section {
        background: linear-gradient(180deg, rgba(26, 24, 21, 0.97) 0%, rgba(34, 31, 26, 0.95) 100%);
      }

      .storybook-mode .menu-item {
        background: linear-gradient(135deg, rgba(42, 37, 32, 0.95) 0%, rgba(26, 24, 21, 0.9) 100%);
        border-color: var(--story-gold-soft);
      }

      .storybook-mode .answer-btn {
        background: #2A2520;
        border-color: var(--story-gold-soft);
      }

      .storybook-mode #questionSection {
        background: linear-gradient(180deg, rgba(26, 24, 21, 0.97) 0%, rgba(34, 31, 26, 0.95) 100%);
        border-color: var(--story-gold-soft);
      }

      .storybook-home-btn,
      .storybook-progress-chapter,
      .storybook-streak {
        background: rgba(42, 37, 32, 0.95);
        border-color: var(--story-gold-soft);
        color: var(--story-ink);
      }

      .storybook-ending-card {
        background: linear-gradient(135deg, #2A2520 0%, #3A3530 50%, #2A2520 100%);
      }
    }

    /* Print stylesheet for stories */
    @media print {
      .storybook-home-btn,
      .storybook-progress-bar,
      .storybook-progress-chapter,
      .storybook-floating-elements,
      .storybook-streak,
      #continueBtn,
      .audio-controls {
        display: none !important;
      }

      .storybook-mode .story-scene-frame img {
        animation: none;
        transform: none;
      }

      .storybook-mode .reading-section {
        background: #FFFFFF;
        box-shadow: none;
        border: 1px solid #DDD;
      }

      .storybook-mode .sentence-display {
        font-size: 14pt;
        color: #000000;
        text-shadow: none;
      }
    }

    /* Final polish: Smooth scroll behavior */
    .storybook-mode #restaurantScreen {
      scroll-behavior: smooth;
    }

    /* Final polish: Touch action for mobile */
    .storybook-mode .menu-item,
    .storybook-mode .answer-btn,
    .storybook-mode #continueBtn {
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
    }

    /* Final polish: Selection color */
    .storybook-mode ::selection {
      background: var(--story-gold-soft);
      color: var(--story-ink);
    }

    /* Final polish: Subtle text anti-aliasing */
    .storybook-mode {
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    /* Final polish: Better button active states */
    .storybook-mode .menu-item:active,
    .storybook-mode .answer-btn:active {
      transform: scale(0.98);
      transition-duration: 0.1s;
    }

    /* Final polish: Better menu prompt styling */
    .storybook-mode .menu-prompt {
      position: relative;
      padding-bottom: 12px;
      margin-bottom: 16px;
    }

    .storybook-mode .menu-prompt::after {
      content: '';
      position: absolute;
      bottom: 0;
      left: 50%;
      transform: translateX(-50%);
      width: 60px;
      height: 2px;
      background: linear-gradient(90deg, transparent, var(--story-gold) 50%, transparent);
    }

    /* Mobile performance: Reduce repaints */
    @media (max-width: 600px) {
      .storybook-mode .story-scene-frame,
      .storybook-mode .reading-section {
        contain: layout paint;
      }
    }

    /* ===== READING SECTION ===== */
    /* The heart of the app - optimized for focus and readability */
    .reading-section {
      background: linear-gradient(180deg, rgba(255, 255, 255, 0.92) 0%, rgba(253, 248, 243, 0.88) 100%);
      border-radius: 20px;
      padding: 0;
      box-shadow:
        0 4px 20px rgba(139, 90, 43, 0.12),
        0 2px 8px rgba(0, 0, 0, 0.06),
        inset 0 1px 0 rgba(255, 255, 255, 0.9);
      display: flex;
      flex-direction: column;
      position: relative;
      overflow: visible;
      /* Warm book-like border */
      border: 2px solid rgba(210, 180, 140, 0.4);
      backdrop-filter: blur(10px) saturate(1.05);
      -webkit-backdrop-filter: blur(10px) saturate(1.05);
      /* Ensure proper flex behavior - don't shrink, grow to fit content */
      flex-shrink: 0;
    }

    /* Reading section header bar - now uses MRT line colors */
    .reading-section::before {
      content: 'Reading Passage';
      position: relative;
      display: block;
      width: 100%;
      padding: 10px 16px;
      background: linear-gradient(135deg, #8FBC8F 0%, #6B9B6B 100%);
      font-family: var(--font-display);
      font-size: 0.95rem;
      font-weight: 700;
      color: #FFFFFF;
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
      letter-spacing: 0.03em;
      border-bottom: 2px solid rgba(0, 0, 0, 0.1);
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    /* MRT Line Indicator - shows which line/stop you're on */
    .mrt-line-indicator {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px 12px;
      background: rgba(255, 255, 255, 0.95);
      border-radius: 20px;
      font-family: var(--transit-font), 'Outfit', sans-serif;
      font-size: 0.7rem;
      font-weight: 700;
      letter-spacing: 0.03em;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      margin: 8px auto 4px;
      width: fit-content;
      border: 2px solid rgba(0, 0, 0, 0.08);
    }

    .mrt-line-indicator .line-dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      flex-shrink: 0;
    }

    .mrt-line-indicator .line-name {
      color: #37474F;
      text-transform: uppercase;
    }

    .mrt-line-indicator .stop-info {
      color: #78909C;
      font-weight: 600;
    }

    /* Line colors for indicator */
    .mrt-line-indicator.line-red .line-dot {
      background: var(--taipei-red);
      box-shadow: 0 0 6px rgba(227, 0, 44, 0.4);
    }

    .mrt-line-indicator.line-blue .line-dot {
      background: var(--taipei-blue);
      box-shadow: 0 0 6px rgba(0, 112, 189, 0.4);
    }

    .mrt-line-indicator.line-green .line-dot {
      background: var(--taipei-green);
      box-shadow: 0 0 6px rgba(0, 134, 89, 0.4);
    }

    .mrt-line-indicator.line-orange .line-dot {
      background: var(--taipei-orange);
      box-shadow: 0 0 6px rgba(248, 182, 28, 0.4);
    }

    .mrt-line-indicator.line-red {
      border-color: rgba(227, 0, 44, 0.2);
    }

    .mrt-line-indicator.line-blue {
      border-color: rgba(0, 112, 189, 0.2);
    }

    .mrt-line-indicator.line-green {
      border-color: rgba(0, 134, 89, 0.2);
    }

    .mrt-line-indicator.line-orange {
      border-color: rgba(248, 182, 28, 0.2);
    }

    /* Inner content padding */
    .reading-section>*:not(.reading-section::before) {
      padding-left: clamp(0.75rem, 2vw, 1.25rem);
      padding-right: clamp(0.75rem, 2vw, 1.25rem);
    }

    /* Bottom decorative accent */
    .reading-section::after {
      content: '';
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 4px;
      background: linear-gradient(90deg, #8FBC8F, #6B9B6B, #8FBC8F);
      opacity: 0.6;
    }

    /* === THEMED READING CARD ACCENTS === */
    /* Very subtle color hints on reading cards to reinforce station theme */

    /* Fruit Stand - Warm golden border hint */
    .theme-fruit .reading-section {
      border-color: rgba(255, 215, 77, 0.25);
      box-shadow:
        0 4px 20px rgba(255, 140, 66, 0.08),
        0 2px 8px rgba(0, 0, 0, 0.06),
        inset 0 1px 0 rgba(255, 255, 255, 0.9);
    }

    .theme-fruit .reading-section::after {
      background: linear-gradient(90deg, rgba(107, 203, 119, 0.5), rgba(255, 215, 77, 0.6), rgba(107, 203, 119, 0.5));
    }

    /* Drink Bar - Cool blue tint */
    .theme-drink .reading-section {
      border-color: rgba(72, 202, 228, 0.2);
      box-shadow:
        0 4px 20px rgba(0, 180, 216, 0.08),
        0 2px 8px rgba(0, 0, 0, 0.06),
        inset 0 1px 0 rgba(255, 255, 255, 0.9);
    }

    .theme-drink .reading-section::after {
      background: linear-gradient(90deg, rgba(72, 202, 228, 0.5), rgba(144, 224, 239, 0.6), rgba(72, 202, 228, 0.5));
    }

    /* Bakery - Warm bread crust tones */
    .theme-bakery .reading-section {
      border-color: rgba(222, 184, 135, 0.35);
      box-shadow:
        0 4px 20px rgba(201, 168, 124, 0.1),
        0 2px 8px rgba(0, 0, 0, 0.06),
        inset 0 1px 0 rgba(255, 255, 255, 0.9);
    }

    .theme-bakery .reading-section::after {
      background: linear-gradient(90deg, rgba(201, 168, 124, 0.6), rgba(222, 184, 135, 0.7), rgba(201, 168, 124, 0.6));
    }

    /* Pizza Place - Tuscan herb garden */
    .theme-pizza .reading-section {
      border-color: rgba(255, 195, 160, 0.25);
      box-shadow:
        0 4px 20px rgba(255, 107, 107, 0.08),
        0 2px 8px rgba(0, 0, 0, 0.06),
        inset 0 1px 0 rgba(255, 255, 255, 0.9);
    }

    .theme-pizza .reading-section::after {
      background: linear-gradient(90deg, rgba(152, 216, 170, 0.5), rgba(255, 195, 160, 0.6), rgba(152, 216, 170, 0.5));
    }

    /* Ice Cream Shop - Pastel sweetness */
    .theme-icecream .reading-section {
      border-color: rgba(255, 181, 232, 0.25);
      box-shadow:
        0 4px 20px rgba(220, 211, 255, 0.1),
        0 2px 8px rgba(0, 0, 0, 0.06),
        inset 0 1px 0 rgba(255, 255, 255, 0.9);
    }

    .theme-icecream .reading-section::after {
      background: linear-gradient(90deg, rgba(181, 222, 255, 0.5), rgba(255, 181, 232, 0.6), rgba(181, 222, 255, 0.5));
    }

    /* Fish Shop - Ocean depths */
    .theme-fishshop .reading-section {
      border-color: rgba(0, 180, 216, 0.25);
      box-shadow:
        0 4px 20px rgba(32, 178, 170, 0.1),
        0 2px 8px rgba(0, 0, 0, 0.06),
        inset 0 1px 0 rgba(255, 255, 255, 0.9);
    }

    .theme-fishshop .reading-section::after {
      background: linear-gradient(90deg, rgba(32, 178, 170, 0.5), rgba(72, 202, 228, 0.6), rgba(32, 178, 170, 0.5));
    }

    /* Cheese Shop - Alpine gold */
    .theme-cheese .reading-section {
      border-color: rgba(255, 215, 0, 0.25);
      box-shadow:
        0 4px 20px rgba(255, 165, 0, 0.08),
        0 2px 8px rgba(0, 0, 0, 0.06),
        inset 0 1px 0 rgba(255, 255, 255, 0.9);
    }

    .theme-cheese .reading-section::after {
      background: linear-gradient(90deg, rgba(144, 238, 144, 0.5), rgba(255, 215, 0, 0.6), rgba(144, 238, 144, 0.5));
    }

    /* Noodle House - Lantern warmth */
    .theme-noodle .reading-section {
      border-color: rgba(255, 160, 122, 0.25);
      box-shadow:
        0 4px 20px rgba(255, 99, 71, 0.08),
        0 2px 8px rgba(0, 0, 0, 0.06),
        inset 0 1px 0 rgba(255, 255, 255, 0.9);
    }

    .theme-noodle .reading-section::after {
      background: linear-gradient(90deg, rgba(60, 179, 113, 0.5), rgba(255, 160, 122, 0.6), rgba(60, 179, 113, 0.5));
    }

    .sentence-image {
      font-size: 3.5rem;
      text-align: center;
      margin-bottom: var(--space-md);
      filter: drop-shadow(0 2px 6px rgba(0, 0, 0, 0.1));
    }

    .sentence-display {
      font-family: var(--font-reading);
      font-size: clamp(1.35rem, 3.2vh, 1.6rem);
      font-weight: 600;
      line-height: 1.7;
      letter-spacing: 0.03em;
      color: #2D3436;
      text-align: center;
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      justify-content: center;
      gap: 0.4em;
      padding: clamp(1rem, 2vh, 1.5rem) clamp(1rem, 3vw, 1.5rem);
      margin: 0 0 var(--space-sm);
      /* Warm cream background for better readability */
      background: linear-gradient(180deg, rgba(255, 252, 247, 0.8) 0%, rgba(255, 248, 240, 0.9) 100%);
      min-height: 80px;
    }

    .word {
      padding: 0.15em 0.25em;
      border-radius: var(--radius-sm);
      cursor: pointer;
      transition: all var(--anim-fast) var(--ease-out-soft);
      position: relative;
      /* Improve tap target */
      margin: 0.05em 0;
    }

    .word:hover {
      background: var(--mrt-blue-whisper);
      box-shadow: 0 0 0 2px var(--mrt-blue-pale);
    }

    .word:active {
      transform: scale(0.95);
    }

    .word.highlighted {
      background: var(--accent-golden);
      transform: scale(1.08);
      box-shadow: var(--shadow-golden);
      border-radius: var(--radius-sm);
    }

    /* When highlighted, hide all other visual indicators for cleaner focus */
    .word.highlighted.sight-word::after,
    .word.highlighted.focus-word::after {
      display: none;
    }

    .word.highlighted.focus-word {
      background: var(--accent-golden);
      box-shadow: var(--shadow-golden);
    }

    body.calm-mode .word.highlighted {
      transform: none;
      box-shadow: none;
    }

    .word.tap-heard {
      animation: word-pulse 0.4s var(--ease-out-soft);
    }

    body.calm-mode .word.tap-heard {
      animation: none;
    }

    .gate-nudge {
      animation: gate-nudge 0.7s ease-in-out 2;
    }

    @keyframes gate-nudge {
      0% {
        transform: scale(1);
        box-shadow: none;
      }

      35% {
        transform: scale(1.08);
        box-shadow: 0 0 0 3px var(--accent-golden-soft), 0 0 18px var(--accent-golden-soft);
      }

      100% {
        transform: scale(1);
        box-shadow: none;
      }
    }

    body.calm-mode .gate-nudge {
      animation: gate-glow 0.7s ease-in-out 2;
    }

    @keyframes gate-glow {
      0% {
        box-shadow: none;
      }

      35% {
        box-shadow: 0 0 0 3px var(--accent-golden-soft);
      }

      100% {
        box-shadow: none;
      }
    }

    .attention-nudge {
      animation: attention-glow 0.7s ease-in-out 2;
    }

    @keyframes attention-glow {
      0% {
        box-shadow: none;
      }

      35% {
        box-shadow: 0 0 0 3px var(--mrt-blue-whisper), 0 0 18px var(--mrt-blue-whisper);
      }

      100% {
        box-shadow: none;
      }
    }

    @keyframes word-pulse {
      0% {
        transform: scale(1);
        background: var(--accent-golden);
        box-shadow: var(--shadow-golden);
      }

      50% {
        transform: scale(1.12);
        box-shadow: 0 0 12px var(--accent-golden);
      }

      100% {
        transform: scale(1);
        background: transparent;
        box-shadow: none;
      }
    }

    /* ===== SIGHT WORD STYLING ===== */
    /* Educational approach: Keep words looking natural (same size/color as passage)
       Use subtle underline only - mimics real reading where sight words don't look different */
    .word.sight-word {
      position: relative;
    }

    /* Subtle dotted underline for general sight words - very gentle cue */
    .word.sight-word::after {
      content: '';
      position: absolute;
      bottom: 1px;
      left: 5%;
      right: 5%;
      height: 2px;
      background: transparent;
      border-bottom: 1.5px dotted var(--accent-lavender-soft);
      opacity: 0.6;
    }

    body.calm-mode .word.sight-word::after {
      opacity: 0.3;
    }

    /* Focus sight word - slightly more visible underline, but NO size/color/weight change
       This teaches recognition of the word itself, not a visual style */
    .word.focus-word {
      /* Keep same size, color, and weight as other words */
      position: relative;
    }

    .word.focus-word::after {
      content: '';
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 3px;
      background: linear-gradient(90deg, var(--accent-mint) 0%, var(--accent-lavender-soft) 100%);
      border-radius: var(--radius-full);
      opacity: 0.7;
      border-bottom: none;
    }

	    /* Calm mode: Even more subtle */
	    body.calm-mode .word.focus-word::after {
	      opacity: 0.4;
	      height: 2px;
	    }

	    /* If a sight word must be tapped to continue, make the cue more obvious. */
	    .word.focus-word.gate-required::after {
	      height: 5px;
	      opacity: 0.95;
	    }

	    .word.focus-word.gate-required {
	      background: rgba(129, 199, 132, 0.14);
	      border-radius: 8px;
	    }

    /* Digraph word styling - highlights the digraph pattern */
    .word.digraph-word {
      position: relative;
    }

    .word.digraph-word::before {
      content: attr(data-digraph);
      position: absolute;
      bottom: -16px;
      left: 50%;
      transform: translateX(-50%);
      font-size: var(--text-xs);
      font-weight: 700;
      color: var(--accent-coral);
      background: var(--accent-coral-pale);
      padding: 2px 6px;
      border-radius: var(--radius-full);
      white-space: nowrap;
    }

    /* Calm mode: Hide digraph labels to reduce visual clutter */
    body.calm-mode .word.digraph-word::before {
      display: none;
    }

    /* Audio controls - Prominent and centered */
    .audio-controls {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: var(--space-lg);
      margin-top: var(--space-md);
      padding: var(--space-md) var(--space-sm);
      background: linear-gradient(180deg, rgba(255, 255, 255, 0.6) 0%, rgba(255, 248, 240, 0.8) 100%);
      border-radius: 16px;
    }

    .audio-btn {
      min-width: var(--touch-min);
      min-height: 58px;
      padding: var(--space-md) var(--space-xl);
      /* Bold coral/salmon - highly visible and inviting */
      background: linear-gradient(180deg, #FF8A7A 0%, #E86A5A 100%);
      border: 3px solid #D85A4A;
      border-radius: 16px;
      font-family: var(--font-display);
      font-size: var(--text-lg);
      font-weight: 700;
      color: #FFFFFF;
      cursor: pointer;
      transition: all var(--anim-fast) var(--ease-out-soft);
      display: flex;
      align-items: center;
      justify-content: center;
      gap: var(--space-sm);
      /* Strong 3D button effect */
      box-shadow:
        0 4px 0 #C04A3A,
        0 6px 12px rgba(232, 106, 90, 0.4),
        inset 0 1px 0 rgba(255, 255, 255, 0.3);
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
      /* Gentle attention animation */
      animation: read-btn-pulse 2.5s ease-in-out infinite;
    }

    @keyframes read-btn-pulse {

      0%,
      100% {
        transform: scale(1);
      }

      50% {
        transform: scale(1.02);
      }
    }

    .audio-btn:hover {
      background: linear-gradient(180deg, #FF9A8A 0%, #F07A6A 100%);
      border-color: #E86A5A;
      color: #FFFFFF;
      transform: translateY(-3px) scale(1.03);
      box-shadow:
        0 6px 0 #C04A3A,
        0 10px 24px rgba(232, 106, 90, 0.5),
        inset 0 1px 0 rgba(255, 255, 255, 0.4);
      animation: none;
    }

    .audio-btn:active {
      transform: translateY(2px) scale(0.98);
      box-shadow:
        0 2px 0 #C04A3A,
        0 3px 8px rgba(232, 106, 90, 0.3);
    }

    .audio-btn .icon {
      font-size: 1.4rem;
      filter: drop-shadow(0 1px 1px rgba(0, 0, 0, 0.2));
    }

    .audio-btn.tip-btn {
      /* Golden hint button - secondary but still visible */
      background: linear-gradient(180deg, #FFD54F 0%, #FFCA28 100%);
      border: 3px solid #FFB300;
      color: #5D4037;
      box-shadow:
        0 4px 0 #E6A000,
        0 6px 12px rgba(255, 193, 7, 0.35),
        inset 0 1px 0 rgba(255, 255, 255, 0.4);
      text-shadow: none;
      animation: none;
    }

    .audio-btn.tip-btn:hover {
      background: linear-gradient(180deg, #FFE082 0%, #FFD54F 100%);
      border-color: #FFCA28;
      color: #4E342E;
      transform: translateY(-2px);
      box-shadow:
        0 5px 0 #E6A000,
        0 8px 16px rgba(255, 193, 7, 0.45);
    }

    /* Reading Tip Box - Educational scaffolding */
    .reading-tip-box {
      display: flex;
      align-items: flex-start;
      gap: var(--space-sm);
      background: linear-gradient(135deg, var(--accent-golden-pale) 0%, var(--accent-peach-pale) 100%);
      padding: var(--space-md);
      border-radius: var(--radius-lg);
      margin-top: var(--space-md);
      box-shadow: var(--shadow-sm);
      animation: tip-appear 0.3s ease-out;
    }

    .passage-box {
      text-align: left;
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.92) 0%, rgba(238, 246, 250, 0.9) 100%);
      border: 2px solid rgba(138, 174, 200, 0.35);
      border-radius: var(--radius-lg);
      box-shadow: var(--shadow-xs);
      overflow: hidden;
      backdrop-filter: blur(10px) saturate(1.05);
      -webkit-backdrop-filter: blur(10px) saturate(1.05);
    }

    .passage-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: var(--space-sm);
      padding: var(--space-sm) var(--space-md);
      background: linear-gradient(135deg, var(--mrt-blue-whisper) 0%, var(--bg-soft-blue) 100%);
      border-bottom: 1px solid rgba(0, 0, 0, 0.05);
    }

    .passage-title {
      font-family: var(--font-display);
      font-size: var(--text-base);
      font-weight: 700;
      color: var(--text-secondary);
      flex: 1;
    }

    .passage-icon {
      font-size: 1.2rem;
      flex: 0 0 auto;
    }

    .passage-read-btn {
      width: auto;
      height: auto;
      min-width: 64px;
      min-height: 34px;
      padding: 7px 14px;
      border-radius: 999px;
      font-family: var(--font-display);
      font-size: 0.95rem;
      font-weight: 800;
      letter-spacing: 0.01em;
      background: linear-gradient(180deg, #FF8A7A 0%, #E86A5A 100%);
      border: 2px solid #D85A4A;
      color: #FFFFFF;
      box-shadow:
        0 3px 0 #C04A3A,
        0 6px 12px rgba(232, 106, 90, 0.35);
      backdrop-filter: none;
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
    }

    .passage-read-btn:hover {
      background: linear-gradient(180deg, #FF9A8A 0%, #F07A6A 100%);
      border-color: #E86A5A;
      transform: translateY(-1px);
      box-shadow:
        0 4px 0 #C04A3A,
        0 8px 16px rgba(232, 106, 90, 0.42);
    }

    .passage-read-btn:active {
      transform: translateY(1px);
      box-shadow:
        0 2px 0 #C04A3A,
        0 4px 10px rgba(232, 106, 90, 0.3);
    }

    .passage-body {
      padding: var(--space-md);
      font-family: var(--font-reading);
      font-size: var(--text-lg);
      color: var(--text-primary);
      line-height: 1.8;
      max-height: 280px;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
      display: block;
      text-align: left;
    }

    /* Passage word highlighting */
    .passage-word {
      padding: 0.15em 0.3em;
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.15s ease-out;
      position: relative;
      display: inline-block;
    }

    .passage-word:hover {
      background: rgba(255, 193, 7, 0.25);
    }

    .passage-word.highlighted {
      background: linear-gradient(135deg, #FFD54F 0%, #FFB300 100%);
      color: #5D4037;
      transform: scale(1.12);
      box-shadow: 0 3px 8px rgba(255, 179, 0, 0.4), 0 0 0 2px rgba(255, 213, 79, 0.5);
      border-radius: 8px;
      font-weight: 600;
      z-index: 2;
    }

    body.calm-mode .passage-word.highlighted {
      transform: none;
      box-shadow: 0 2px 4px rgba(255, 179, 0, 0.3);
    }

    /* Passage sentence containers - for full passage display */
    .passage-sentence {
      display: inline;
      padding: 2px 4px;
      border-radius: 4px;
      transition: background-color 0.2s ease;
    }

    /* Key sentence highlighting - subtle hint without giving away the answer */
    .passage-sentence.key-sentence {
      background: linear-gradient(135deg, rgba(144, 238, 144, 0.2) 0%, rgba(152, 251, 152, 0.25) 100%);
      border-radius: 6px;
      padding: 3px 6px;
      margin: 2px 0;
      display: inline;
      box-shadow: inset 0 0 0 1px rgba(60, 179, 113, 0.15);
    }

    /* Subtle indicator for key sentence - small leaf/hint icon */
    .passage-sentence.key-sentence::before {
      content: '';
      display: none;
    }

    /* Hide the hint icon on very small screens to save space */
    @media (max-width: 420px) {
      .passage-sentence.key-sentence::before {
        display: none;
      }

      .passage-body {
        max-height: 220px;
        font-size: var(--text-md);
        padding: var(--space-sm);
      }
    }

    /* ===== EVIDENCE-BASED ANSWERING ===== */
    /* Evidence tapping is optional support (not a gate). */

    .passage-word.evidence-selected {
      background: linear-gradient(135deg, #81C784 0%, #4CAF50 100%);
      color: white;
      transform: scale(1.08);
      box-shadow: 0 2px 8px rgba(76, 175, 80, 0.4);
      border-radius: 6px;
      transition: all 0.2s ease;
    }

    .passage-word.evidence-selectable {
      cursor: pointer;
      position: relative;
    }

    .passage-word.evidence-selectable::after {
      content: '';
      position: absolute;
      bottom: -2px;
      left: 0;
      right: 0;
      height: 2px;
      background: rgba(76, 175, 80, 0.4);
      border-radius: 1px;
    }

    /* Evidence prompt banner */
    .evidence-prompt {
      display: none;
      align-items: center;
      justify-content: center;
      gap: 8px;
      padding: 12px 20px;
      margin-bottom: 12px;
      background: linear-gradient(135deg, #E8F5E9 0%, #C8E6C9 100%);
      border: 2px dashed #4CAF50;
      border-radius: 12px;
      font-family: var(--font-display);
      font-size: 0.95rem;
      color: #2E7D32;
      animation: pulse-gentle 2s ease-in-out infinite;
    }

    .evidence-prompt.active {
      display: flex;
    }

    .evidence-prompt.satisfied {
      background: linear-gradient(135deg, #C8E6C9 0%, #A5D6A7 100%);
      border-style: solid;
      animation: none;
    }

    @keyframes pulse-gentle {

      0%,
      100% {
        opacity: 1;
        transform: scale(1);
      }

      50% {
        opacity: 0.85;
        transform: scale(1.01);
      }
    }

    .evidence-icon {
      font-size: 1.3em;
    }

    /* ===== 3-LEVEL HINT LADDER ===== */
    .hint-ladder {
      display: none;
      flex-direction: column;
      gap: 8px;
      margin-top: 12px;
      padding: 12px;
      background: linear-gradient(135deg, #FFF8E1 0%, #FFECB3 100%);
      border-radius: 12px;
      border: 1px solid rgba(255, 193, 7, 0.3);
    }

    .hint-ladder.active {
      display: flex;
    }

    .hint-ladder-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
    }

    .hint-ladder-title {
      display: flex;
      align-items: center;
      gap: 6px;
      font-family: var(--font-display);
      font-size: 0.9rem;
      font-weight: 600;
      color: #F57F17;
    }

    .hint-level {
      display: none;
      padding: 10px 14px;
      background: white;
      border-radius: 10px;
      font-family: var(--font-reading);
      font-size: 0.95rem;
      color: var(--text-primary);
      border-left: 4px solid #FFC107;
      animation: hint-appear 0.4s ease-out;
    }

    .hint-level.active {
      display: block;
    }

    .hint-level.level-1 {
      border-left-color: #4CAF50;
    }

    .hint-level.level-2 {
      border-left-color: #FF9800;
    }

    .hint-level.level-3 {
      border-left-color: #F44336;
    }

    @keyframes hint-appear {
      from {
        opacity: 0;
        transform: translateY(-8px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .hint-btn {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 8px 14px;
      background: linear-gradient(135deg, #FFF8E1 0%, #FFE082 100%);
      border: 2px solid #FFB300;
      border-radius: 20px;
      font-family: var(--font-display);
      font-size: 0.85rem;
      font-weight: 600;
      color: #E65100;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .hint-btn:hover:not(:disabled) {
      background: linear-gradient(135deg, #FFE082 0%, #FFD54F 100%);
      transform: scale(1.05);
    }

    .hint-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }

    .hint-counter {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      min-width: 18px;
      height: 18px;
      padding: 0 5px;
      background: #FF9800;
      color: white;
      border-radius: 9px;
      font-size: 0.7rem;
      font-weight: 700;
    }

    /* Wrong answer explanation */
    .error-explanation {
      display: none;
      padding: 14px 18px;
      margin-top: 12px;
      background: linear-gradient(135deg, #FFEBEE 0%, #FFCDD2 100%);
      border-radius: 12px;
      border-left: 4px solid #EF5350;
      font-family: var(--font-reading);
      font-size: 0.95rem;
      color: #C62828;
      animation: error-appear 0.4s ease-out;
    }

    .error-explanation.active {
      display: block;
    }

    @keyframes error-appear {
      from {
        opacity: 0;
        transform: translateX(-10px);
      }

      to {
        opacity: 1;
        transform: translateX(0);
      }
    }

    .error-explanation-title {
      font-family: var(--font-display);
      font-weight: 600;
      margin-bottom: 6px;
    }

    /* Evidence check indicator */
    .evidence-check {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      margin-left: 8px;
      padding: 4px 10px;
      background: #E8F5E9;
      border-radius: 12px;
      font-size: 0.8rem;
      color: #2E7D32;
    }

    .evidence-check.correct {
      background: #C8E6C9;
    }

    .evidence-check.incorrect {
      background: #FFCDD2;
      color: #C62828;
    }

    @keyframes tip-appear {
      from {
        opacity: 0;
        transform: translateY(-10px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .tip-icon {
      font-size: 1.4rem;
      flex-shrink: 0;
    }

    .tip-text {
      font-size: var(--text-sm);
      color: var(--text-secondary);
      line-height: 1.5;
      white-space: pre-wrap;
    }

	    /* Sight Word Focus - compact inline design */
	    .sight-word-focus {
	      display: inline-flex;
	      align-items: center;
	      gap: 8px;
      background: var(--accent-mint-pale);
      padding: 6px 14px;
      border-radius: 20px;
      margin-top: var(--space-xs);
      box-shadow: var(--shadow-xs);
    }

	    .focus-label {
	      font-size: 0.8rem;
	      color: var(--text-secondary);
	      font-weight: 600;
	    }

	    .sight-word-focus .focus-word {
	      font-family: var(--font-display);
	      font-size: 1.1rem;
	      font-weight: 700;
	      color: #2E7D32;
	      background: white;
	      padding: 4px 12px;
	      border-radius: 12px;
	      box-shadow: var(--shadow-sm);
	      cursor: pointer;
	      user-select: none;
	      transition: transform 0.15s ease, box-shadow 0.15s ease;
	    }

	    .sight-word-focus .focus-word:hover {
	      transform: scale(1.05);
	      box-shadow: 0 3px 8px rgba(46, 125, 50, 0.25);
	    }

	    .sight-word-focus .focus-word:active {
	      transform: scale(0.97);
	    }

	    .focus-action {
	      font-size: 0.75rem;
	      color: var(--text-tertiary);
	      font-style: italic;
	    }

	    /* Sight-word gate: lightweight, contextual prompt (shown only when needed). */
	    .sight-word-gate-row {
	      display: flex;
	      align-items: center;
	      justify-content: center;
	      gap: 10px;
	      margin-top: 8px;
	      min-height: 0;
	    }

	    .sight-word-gate-text {
	      max-width: min(520px, 92vw);
	      padding: 8px 12px;
	      border-radius: 14px;
	      background: rgba(255, 255, 255, 0.86);
	      border: 1px solid rgba(0, 0, 0, 0.06);
	      box-shadow: var(--shadow-xs);
	      font-size: 0.95rem;
	      font-weight: 700;
	      color: var(--text-secondary);
	      text-align: center;
	    }

	    body.calm-mode .sight-word-gate-text {
	      background: rgba(255, 255, 255, 0.78);
	      font-weight: 600;
	    }

	    .sight-word-skip-btn {
	      padding: 8px 12px;
	      border-radius: 999px;
	      border: 1px solid rgba(0, 0, 0, 0.12);
	      background: rgba(255, 255, 255, 0.75);
	      color: var(--text-secondary);
	      font-family: var(--font-display);
	      font-weight: 700;
	      cursor: pointer;
	      transition: transform 0.15s ease, box-shadow 0.15s ease, background 0.15s ease;
	    }

	    .sight-word-skip-btn:hover {
	      background: rgba(255, 255, 255, 0.92);
	      box-shadow: var(--shadow-xs);
	    }

	    .sight-word-skip-btn:active {
	      transform: scale(0.98);
	    }

	    /* Gated state - slightly more prominent */
	    .sight-word-focus.gated {
	      background: linear-gradient(135deg, #E8F5E9 0%, #C8E6C9 100%);
	      border: 2px solid #81C784;
    }

	    .sight-word-focus.gated .focus-word {
	      animation: pulse-word 1.5s ease-in-out infinite;
	    }

	    .sight-word-focus.gated .focus-action {
	      color: #1B5E20;
	      font-style: normal;
	      font-weight: 700;
	    }

    @keyframes pulse-word {

      0%,
      100% {
        box-shadow: 0 2px 6px rgba(46, 125, 50, 0.2);
      }

      50% {
        box-shadow: 0 2px 12px rgba(46, 125, 50, 0.4);
      }
    }

    /* Mobile: compact sight-word chip */
	    @media (max-width: 420px) {
	      .sight-word-focus {
	        gap: 6px;
	        padding: 5px 10px;
	      }

      .focus-label {
        font-size: 0.75rem;
      }

	      .sight-word-focus .focus-word {
	        font-size: 1rem;
	        padding: 3px 10px;
	      }

      .focus-action {
        font-size: 0.7rem;
      }

      /* Extra small screens: more compact sentence display */
      .sentence-display {
        padding: var(--space-xs) var(--space-sm);
        font-size: 1.1rem;
        line-height: 1.6;
        min-height: auto;
      }
    }

    /* ===== MENU/ORDERING ===== */
    .menu-section {
      display: flex;
      flex-direction: column;
      gap: var(--space-md);
    }

    .menu-prompt {
      font-family: var(--font-display);
      font-size: var(--text-xl);
      font-weight: 600;
      color: var(--text-primary);
      text-align: center;
    }

    .menu-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(130px, 1fr));
      gap: var(--space-md);
    }

    .menu-item {
      min-height: var(--touch-min);
      padding: var(--space-md);
      background:
        linear-gradient(180deg, #FFFFFF 0%, var(--bg-cream-cool) 100%);
      border: 3px solid var(--panel-silver);
      border-radius: var(--radius-xl);
      cursor: pointer;
      transition: all var(--anim-fast) var(--ease-out-soft);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: var(--space-xs);
      box-shadow:
        0 4px 0 var(--panel-silver-dark),
        var(--shadow-sm);
    }

    .menu-item:hover:not(:disabled):not(.wrong) {
      border-color: var(--mrt-blue);
      transform: translateY(-3px) scale(1.02);
      box-shadow:
        0 6px 0 var(--panel-silver-dark),
        var(--shadow-md);
    }

    .menu-item:active:not(:disabled):not(.wrong) {
      transform: translateY(2px);
      box-shadow:
        0 2px 0 var(--panel-silver-dark),
        var(--shadow-xs);
    }

    .menu-item.selected {
      border-color: var(--success-green);
      background:
        linear-gradient(135deg, var(--success-green-pale) 0%, var(--accent-mint-pale) 100%);
      box-shadow:
        0 4px 0 var(--accent-mint-soft),
        var(--shadow-mint);
    }

    .menu-item.wrong {
      opacity: 0.45;
      cursor: not-allowed;
      border-color: var(--panel-silver);
      filter: grayscale(30%);
    }

    .menu-item .item-icon {
      font-size: 2.4rem;
      filter: drop-shadow(0 1px 2px rgba(0, 0, 0, 0.1));
    }

    .menu-item .item-name {
      font-family: var(--font-display);
      font-size: var(--text-lg);
      font-weight: 600;
      color: var(--text-primary);
    }

    .menu-item .item-desc {
      font-family: var(--font-reading);
      font-size: var(--text-sm);
      color: var(--text-secondary);
      font-weight: 400;
      margin-top: 2px;
    }

    /* ===== QUESTION SCREEN ===== */
    .question-section {
      text-align: center;
      padding: var(--space-lg) var(--space-md);
      background: linear-gradient(180deg, rgba(255, 248, 240, 0.9) 0%, rgba(255, 244, 232, 0.88) 100%);
      border-radius: 20px;
      border: 2px solid rgba(255, 183, 77, 0.3);
      box-shadow:
        0 4px 16px rgba(255, 152, 0, 0.1),
        inset 0 1px 0 rgba(255, 255, 255, 0.8);
      backdrop-filter: blur(10px) saturate(1.05);
      -webkit-backdrop-filter: blur(10px) saturate(1.05);
    }

    /* === THEMED QUESTION CARD ACCENTS === */
    /* Subtle theming to match the station environment */

    .theme-fruit .question-section {
      border-color: rgba(255, 215, 77, 0.3);
      box-shadow:
        0 4px 16px rgba(255, 140, 66, 0.1),
        inset 0 1px 0 rgba(255, 255, 255, 0.8);
    }

    .theme-drink .question-section {
      border-color: rgba(72, 202, 228, 0.3);
      box-shadow:
        0 4px 16px rgba(0, 180, 216, 0.1),
        inset 0 1px 0 rgba(255, 255, 255, 0.8);
    }

    .theme-bakery .question-section {
      border-color: rgba(222, 184, 135, 0.4);
      box-shadow:
        0 4px 16px rgba(201, 168, 124, 0.12),
        inset 0 1px 0 rgba(255, 255, 255, 0.8);
    }

    .theme-pizza .question-section {
      border-color: rgba(255, 195, 160, 0.3);
      box-shadow:
        0 4px 16px rgba(255, 107, 107, 0.1),
        inset 0 1px 0 rgba(255, 255, 255, 0.8);
    }

    .theme-icecream .question-section {
      border-color: rgba(255, 181, 232, 0.3);
      box-shadow:
        0 4px 16px rgba(220, 211, 255, 0.12),
        inset 0 1px 0 rgba(255, 255, 255, 0.8);
    }

    .theme-fishshop .question-section {
      border-color: rgba(0, 180, 216, 0.3);
      box-shadow:
        0 4px 16px rgba(32, 178, 170, 0.12),
        inset 0 1px 0 rgba(255, 255, 255, 0.8);
    }

    .theme-cheese .question-section {
      border-color: rgba(255, 215, 0, 0.3);
      box-shadow:
        0 4px 16px rgba(255, 165, 0, 0.1),
        inset 0 1px 0 rgba(255, 255, 255, 0.8);
    }

    .theme-noodle .question-section {
      border-color: rgba(255, 160, 122, 0.3);
      box-shadow:
        0 4px 16px rgba(255, 99, 71, 0.1),
        inset 0 1px 0 rgba(255, 255, 255, 0.8);
    }

    /* Question Text - Bold and clear */
    .question-text {
      font-family: var(--font-display);
      font-size: clamp(1.3rem, 3.5vh, 1.7rem);
      font-weight: 700;
      color: #2D3436;
      margin-bottom: var(--space-md);
      line-height: 1.4;
      padding: 0 var(--space-sm);
    }

    .question-hint {
      font-family: var(--font-reading);
      font-size: var(--text-base);
      color: #5D4037;
      font-style: italic;
      margin-bottom: var(--space-lg);
      padding: 10px 16px;
      background: linear-gradient(135deg, #FFF8E1 0%, #FFECB3 100%);
      border-radius: 12px;
      display: inline-block;
      border: 2px solid rgba(255, 193, 7, 0.4);
      box-shadow: 0 2px 8px rgba(255, 193, 7, 0.15);
    }

    /* Bonus phonics question */
    .bonus-question {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: var(--space-sm);
      margin-bottom: var(--space-md);
      padding: var(--space-sm) var(--space-md);
      background: linear-gradient(135deg, var(--accent-golden-pale) 0%, var(--accent-mint-pale) 100%);
      border-radius: var(--radius-lg);
      font-size: var(--text-sm);
      color: var(--text-secondary);
    }

    .bonus-icon {
      font-size: 1.2rem;
    }

    .bonus-text {
      font-style: italic;
    }

    /* Success feedback */
    .success-feedback {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: var(--space-sm);
      margin-top: var(--space-md);
      padding: var(--space-md);
      background: linear-gradient(135deg, var(--success-green-pale) 0%, var(--accent-mint-pale) 100%);
      border-radius: var(--radius-lg);
      animation: feedback-appear 0.5s ease-out;
    }

    @keyframes feedback-appear {
      from {
        opacity: 0;
        transform: scale(0.9);
      }

      to {
        opacity: 1;
        transform: scale(1);
      }
    }

    .success-icon {
      font-size: 1.5rem;
    }

    .success-text {
      font-family: var(--font-display);
      font-size: var(--text-base);
      font-weight: 600;
      color: #2D7D68;
    }

    .answer-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: var(--space-md);
      max-width: 560px;
      margin: 0 auto;
    }

    /* Fallback for narrow screens - 2 columns */
    @media screen and (max-width: 500px) {
      .answer-grid {
        grid-template-columns: repeat(2, 1fr);
      }
    }

    .answer-btn {
      min-height: var(--touch-lg);
      padding: var(--space-md);
      background: linear-gradient(180deg, #FFFFFF 0%, #FFF8F2 100%);
      border: 3px solid #E0D4C8;
      border-radius: 16px;
      cursor: pointer;
      transition: all var(--anim-fast) var(--ease-out-soft);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: var(--space-sm);
      box-shadow:
        0 4px 0 #C8BDB0,
        0 6px 12px rgba(139, 90, 43, 0.1);
    }

    .answer-btn:hover:not(:disabled):not(.wrong) {
      border-color: #64B5F6;
      background: linear-gradient(180deg, #FFFFFF 0%, #E3F2FD 100%);
      transform: translateY(-4px) scale(1.03);
      box-shadow:
        0 6px 0 #42A5F5,
        0 10px 20px rgba(33, 150, 243, 0.2);
    }

    .answer-btn:active:not(:disabled):not(.wrong) {
      transform: translateY(2px) scale(0.98);
      box-shadow:
        0 2px 0 #C8BDB0,
        0 3px 6px rgba(139, 90, 43, 0.1);
    }

    .answer-btn.correct {
      border-color: var(--success-green);
      background:
        linear-gradient(135deg, var(--success-green-pale) 0%, var(--accent-mint-pale) 100%);
      animation: correct-celebrate 0.6s var(--ease-bounce);
      box-shadow:
        0 4px 0 var(--success-green-soft),
        var(--shadow-mint);
    }

    @keyframes correct-celebrate {
      0% {
        transform: scale(1);
      }

      30% {
        transform: scale(1.08) rotate(-2deg);
      }

      60% {
        transform: scale(1.08) rotate(2deg);
      }

      100% {
        transform: scale(1) rotate(0deg);
      }
    }

    .answer-btn.wrong {
      opacity: 0.45;
      cursor: not-allowed;
      pointer-events: none;
      filter: grayscale(30%);
    }

    .answer-btn .answer-icon {
      font-size: 2.8rem;
      filter: drop-shadow(0 1px 2px rgba(0, 0, 0, 0.1));
    }

    .answer-btn .answer-text {
      font-family: var(--font-display);
      font-size: var(--text-lg);
      font-weight: 600;
      color: var(--text-primary);
    }

    .answer-btn .answer-desc {
      font-family: var(--font-reading);
      font-size: var(--text-sm);
      color: var(--text-secondary);
      font-weight: 400;
    }

    /* Enhanced answer button states */
    .answer-btn--selected {
      border-color: var(--mrt-blue);
      border-width: 4px;
      background: linear-gradient(180deg, #E3F2FD 0%, #BBDEFB 100%);
      transform: scale(1.02);
    }

    .answer-btn--disabled {
      opacity: 0.4;
      cursor: not-allowed;
      pointer-events: none;
    }

    .answer-btn.correct::before {
      content: 'âœ“';
      position: absolute;
      top: 8px;
      right: 8px;
      font-size: 2rem;
      color: var(--success-green);
      animation: checkmark-pop 0.4s var(--ease-bounce);
    }

    .answer-btn.wrong::before {
      content: 'âœ—';
      position: absolute;
      top: 8px;
      right: 8px;
      font-size: 2rem;
      color: #E53935;
      animation: shake 0.5s ease-in-out;
    }

    @keyframes checkmark-pop {
      0% {
        transform: scale(0) rotate(-45deg);
        opacity: 0;
      }
      50% {
        transform: scale(1.3) rotate(10deg);
      }
      100% {
        transform: scale(1) rotate(0deg);
        opacity: 1;
      }
    }

    @keyframes shake {
      0%, 100% { transform: translateX(0); }
      10%, 30%, 50%, 70%, 90% { transform: translateX(-8px); }
      20%, 40%, 60%, 80% { transform: translateX(8px); }
    }

    /* ===== QUESTION PROGRESS INDICATOR ===== */
    .question-progress {
      display: flex;
      justify-content: center;
      margin-bottom: var(--space-md);
      padding: var(--space-sm) 0;
    }

    .progress-dots {
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .progress-dot {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: rgba(0, 0, 0, 0.15);
      transition: all 0.3s var(--ease-gentle);
    }

    .progress-dot.active {
      background: var(--mrt-blue);
      width: 16px;
      height: 16px;
      box-shadow: 0 0 8px rgba(74, 144, 194, 0.4);
    }

    .progress-dot.completed {
      background: var(--success-green);
    }

    /* ===== QUESTION TYPE BADGE ===== */
    .question-type-badge {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 14px;
      background: linear-gradient(135deg, var(--mrt-blue-pale) 0%, var(--mrt-blue-whisper) 100%);
      border: 2px solid var(--mrt-blue-soft);
      border-radius: 20px;
      margin-bottom: var(--space-md);
      font-family: var(--font-display);
      font-size: var(--text-sm);
      font-weight: 600;
      color: var(--mrt-blue-deep);
      box-shadow: 0 2px 8px rgba(74, 144, 194, 0.15);
    }

    .question-type-badge .badge-icon {
      font-size: 1.1rem;
    }

    .question-type-badge.type-comprehension {
      background: linear-gradient(135deg, #E8F5E9 0%, #C8E6C9 100%);
      border-color: #81C784;
      color: #388E3C;
    }

    .question-type-badge.type-comprehension .badge-icon::before {
      content: 'ðŸ“–';
    }

    .question-type-badge.type-sightWord {
      background: linear-gradient(135deg, #FFF3E0 0%, #FFE0B2 100%);
      border-color: #FFB74D;
      color: #F57C00;
    }

    .question-type-badge.type-sightWord .badge-icon::before {
      content: 'ðŸ‘ï¸';
    }

    /* ===== PASSAGE STATES ===== */
    .question-passage--hidden {
      opacity: 0.3;
      filter: blur(4px);
      transition: all 0.4s ease;
    }

    .question-passage--revealed {
      opacity: 1;
      filter: blur(0);
      animation: reveal-pulse 0.6s ease;
    }

    @keyframes reveal-pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.02); }
      100% { transform: scale(1); }
    }

    /* ===== HINT BOX ===== */
    .hint-box {
      display: flex;
      gap: var(--space-sm);
      align-items: flex-start;
      margin: var(--space-md) auto;
      padding: var(--space-md);
      max-width: 500px;
      background: linear-gradient(135deg, #FFF9C4 0%, #FFF59D 100%);
      border: 3px solid #FFD54F;
      border-radius: var(--radius-lg);
      box-shadow: 0 4px 12px rgba(255, 213, 79, 0.3);
      animation: hint-appear 0.4s var(--ease-bounce);
    }

    @keyframes hint-appear {
      0% {
        transform: translateY(-20px) scale(0.9);
        opacity: 0;
      }
      100% {
        transform: translateY(0) scale(1);
        opacity: 1;
      }
    }

    .hint-box-icon {
      font-size: 2rem;
      flex-shrink: 0;
    }

    .hint-box-content {
      flex: 1;
    }

    .hint-box-title {
      font-family: var(--font-display);
      font-size: var(--text-md);
      font-weight: 700;
      color: #F57F17;
      margin-bottom: 4px;
    }

    .hint-box-text {
      font-family: var(--font-reading);
      font-size: var(--text-md);
      color: var(--text-primary);
      line-height: 1.5;
    }

    /* ===== SUCCESS FEEDBACK ENHANCED ===== */
    .success-feedback {
      flex-direction: column;
      gap: var(--space-sm);
      padding: var(--space-md);
      background: linear-gradient(135deg, var(--success-green-pale) 0%, var(--accent-mint-pale) 100%);
      border: 3px solid var(--success-green);
      border-radius: var(--radius-lg);
      box-shadow: 0 4px 16px rgba(76, 175, 80, 0.3);
      animation: success-appear 0.6s var(--ease-bounce);
    }

    @keyframes success-appear {
      0% {
        transform: scale(0.8) translateY(-20px);
        opacity: 0;
      }
      50% {
        transform: scale(1.05);
      }
      100% {
        transform: scale(1) translateY(0);
        opacity: 1;
      }
    }

    .success-icon {
      font-size: 3rem;
      color: var(--success-green);
      animation: success-icon-spin 0.6s ease;
    }

    @keyframes success-icon-spin {
      0% {
        transform: rotate(-180deg) scale(0);
      }
      100% {
        transform: rotate(0deg) scale(1);
      }
    }

    .success-text {
      font-family: var(--font-display);
      font-size: var(--text-lg);
      font-weight: 700;
      color: var(--success-green-deep);
    }

    /* ===== CELEBRATION CONTAINER ===== */
    .celebration-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 9999;
      overflow: hidden;
    }

    .confetti {
      position: absolute;
      width: 10px;
      height: 10px;
      animation: confetti-fall 3s linear forwards;
    }

    @keyframes confetti-fall {
      0% {
        transform: translateY(-100vh) rotate(0deg);
        opacity: 1;
      }
      100% {
        transform: translateY(100vh) rotate(720deg);
        opacity: 0;
      }
    }

    .star-burst {
      position: absolute;
      font-size: 2rem;
      animation: star-burst 1.5s ease-out forwards;
    }

    @keyframes star-burst {
      0% {
        transform: translate(0, 0) scale(0);
        opacity: 1;
      }
      50% {
        opacity: 1;
      }
      100% {
        transform: translate(var(--dx), var(--dy)) scale(1);
        opacity: 0;
      }
    }

	    /* ===== MENU STORY ===== */
	    .menu-story {
	      font-family: var(--font-reading);
	      font-size: var(--text-lg);
	      color: var(--text-primary);
	      text-align: center;
	      margin-bottom: var(--space-md);
	      padding: var(--space-md);
	      background:
	        linear-gradient(135deg, var(--accent-golden-pale) 0%, var(--accent-peach-pale) 100%);
	      border-radius: var(--radius-lg);
	      line-height: 1.6;
	      box-shadow: var(--shadow-sm);
	      border: 1px solid rgba(249, 213, 110, 0.3);
	    }

	    .menu-story .menu-story-kicker {
	      font-family: var(--font-display);
	      font-size: var(--text-xs);
	      font-weight: 700;
	      text-transform: uppercase;
	      letter-spacing: 0.14em;
	      color: rgba(74, 63, 53, 0.85);
	      margin-bottom: 6px;
	    }

	    .menu-story .menu-story-subtitle {
	      font-size: var(--text-sm);
	      color: rgba(74, 63, 53, 0.85);
	      margin-bottom: 10px;
	    }

	    .menu-story .menu-story-body {
	      font-size: var(--text-lg);
	      color: var(--text-primary);
	    }

	    .menu-story .menu-story-list {
	      margin: 10px auto 0;
	      padding-left: 1.2em;
	      width: fit-content;
	      text-align: left;
	    }

	    .menu-story .menu-story-quote {
	      margin-top: 12px;
	      padding: 10px 12px;
	      background: rgba(255, 255, 255, 0.5);
	      border: 1px dashed rgba(0, 0, 0, 0.18);
	      border-radius: 12px;
	      font-size: var(--text-sm);
	      color: rgba(74, 63, 53, 0.9);
	      text-align: left;
	    }

	    /* ===== REWARD SCREEN ===== */
	    .reward-screen {
	      background:
	        radial-gradient(ellipse at 50% 30%, var(--accent-golden-soft) 0%, transparent 50%),
	        radial-gradient(ellipse at 30% 80%, var(--accent-mint-pale) 0%, transparent 40%),
        radial-gradient(ellipse at 70% 80%, var(--accent-coral-pale) 0%, transparent 40%),
        linear-gradient(180deg, var(--accent-golden-pale) 0%, var(--bg-cream-warm) 100%);
      align-items: center;
      justify-content: center;
      text-align: center;
      padding: var(--space-xl);
    }

    .reward-celebration {
      font-size: 4.5rem;
      margin-bottom: var(--space-lg);
      animation: celebration-bounce 1.2s var(--ease-gentle) infinite;
      filter: drop-shadow(0 4px 8px rgba(0, 0, 0, 0.1));
    }

    @keyframes celebration-bounce {

      0%,
      100% {
        transform: scale(1) rotate(0deg);
      }

      25% {
        transform: scale(1.08) rotate(-4deg);
      }

      75% {
        transform: scale(1.08) rotate(4deg);
      }
    }

    .reward-title {
      font-family: var(--font-display);
      font-size: var(--text-3xl);
      font-weight: 600;
      color: var(--text-primary);
      margin-bottom: var(--space-sm);
    }

    .reward-message {
      font-size: var(--text-lg);
      color: var(--text-secondary);
      margin-bottom: var(--space-xl);
    }

    .reward-story-meta {
      width: min(720px, 92vw);
      margin: -12px auto var(--space-lg);
      padding: 12px 14px;
      border-radius: 16px;
      background: rgba(255, 255, 255, 0.72);
      border: 1px solid rgba(69, 90, 100, 0.14);
      box-shadow: 0 10px 24px rgba(0, 0, 0, 0.08);
      font-family: var(--transit-font);
      font-weight: 650;
      color: rgba(45, 45, 45, 0.92);
      line-height: 1.35;
      white-space: pre-line;
    }

    .reward-actions {
      display: flex;
      flex-direction: column;
      gap: 10px;
      width: min(420px, 92vw);
      margin: 0 auto;
    }

    .sticker-earned {
      font-size: 3.5rem;
      padding: var(--space-lg);
      background:
        linear-gradient(180deg, #FFFFFF 0%, var(--bg-cream-warm) 100%);
      border-radius: var(--radius-2xl);
      box-shadow:
        var(--shadow-xl),
        0 0 0 4px var(--accent-golden-soft),
        0 0 30px rgba(249, 213, 110, 0.3);
      margin-bottom: var(--space-xl);
      animation: sticker-appear 0.6s var(--ease-bounce);
      position: relative;
    }

    /* Sparkle effect around sticker */
    .sticker-earned::before,
    .sticker-earned::after {
      content: '';
      position: absolute;
      width: 12px;
      height: 12px;
      background: var(--accent-golden);
      border-radius: 50%;
      animation: sparkle 1.5s ease-in-out infinite;
    }

    .sticker-earned::before {
      top: -8px;
      right: -8px;
      animation-delay: 0s;
    }

    .sticker-earned::after {
      bottom: -8px;
      left: -8px;
      animation-delay: 0.75s;
    }

    @keyframes sparkle {

      0%,
      100% {
        transform: scale(0.5);
        opacity: 0.3;
      }

      50% {
        transform: scale(1);
        opacity: 1;
      }
    }

    @keyframes sticker-appear {
      0% {
        transform: scale(0) rotate(-180deg);
        opacity: 0;
      }

      60% {
        transform: scale(1.15) rotate(10deg);
      }

      100% {
        transform: scale(1) rotate(0deg);
        opacity: 1;
      }
    }

    /* ===== PARENT SETTINGS MODAL ===== */
    .modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(40, 40, 40, 0.5);
      backdrop-filter: blur(4px);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      opacity: 0;
      visibility: hidden;
      transition: all var(--anim-fast) var(--ease-gentle);
    }

    .modal-overlay.active {
      opacity: 1;
      visibility: visible;
    }

    .modal-content {
      background: var(--bg-cream-warm);
      border-radius: var(--radius-2xl);
      padding: var(--space-xl);
      max-width: 420px;
      width: 90%;
      max-height: 80vh;
      overflow-y: auto;
      box-shadow: var(--shadow-xl);
      border: 1px solid rgba(255, 255, 255, 0.5);
      transform: translateY(20px);
      transition: transform var(--anim-medium) var(--ease-out-soft);
    }

    .modal-overlay.active .modal-content {
      transform: translateY(0);
    }

    /* Confirm modal should always be above other overlays. */
    #confirmModal {
      z-index: 1100;
    }

    .modal-title {
      font-family: var(--font-display);
      font-size: var(--text-2xl);
      font-weight: 600;
      color: var(--text-primary);
      margin-bottom: var(--space-lg);
      text-align: center;
    }

    .setting-group {
      margin-bottom: var(--space-lg);
      padding: var(--space-md);
      background: rgba(255, 255, 255, 0.6);
      border-radius: var(--radius-lg);
    }

    .setting-label {
      font-weight: 600;
      color: var(--text-secondary);
      margin-bottom: var(--space-sm);
      display: block;
      font-size: var(--text-sm);
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .setting-toggle {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: var(--space-md);
      background:
        linear-gradient(180deg, var(--bg-soft-blue) 0%, var(--mrt-blue-whisper) 100%);
      border-radius: var(--radius-lg);
      box-shadow: var(--shadow-inner);
    }

    .toggle-switch {
      width: 56px;
      height: 32px;
      background: var(--panel-silver);
      border-radius: var(--radius-full);
      position: relative;
      cursor: pointer;
      transition: all var(--anim-fast) var(--ease-out-soft);
      box-shadow: var(--shadow-inner);
    }

    .toggle-switch.active {
      background: var(--success-green);
      box-shadow:
        var(--shadow-inner),
        0 0 8px rgba(125, 213, 144, 0.4);
    }

    .toggle-switch::after {
      content: '';
      position: absolute;
      width: 26px;
      height: 26px;
      background:
        linear-gradient(180deg, #FFFFFF 0%, #F5F5F5 100%);
      border-radius: 50%;
      top: 3px;
      left: 3px;
      transition: transform var(--anim-fast) var(--ease-out-soft);
      box-shadow:
        0 2px 4px rgba(0, 0, 0, 0.15),
        0 1px 2px rgba(0, 0, 0, 0.1);
    }

    .toggle-switch.active::after {
      transform: translateX(26px);
    }

    .modal-close {
      width: 100%;
      min-height: 56px;
      background:
        linear-gradient(135deg, var(--mrt-blue) 0%, var(--mrt-blue-soft) 100%);
      color: var(--text-inverse);
      border: none;
      border-radius: var(--radius-xl);
      font-family: var(--font-display);
      font-size: var(--text-lg);
      font-weight: 600;
      cursor: pointer;
      margin-top: var(--space-lg);
      transition: all var(--anim-fast) var(--ease-out-soft);
      box-shadow:
        0 4px 0 rgba(50, 100, 140, 0.35),
        var(--shadow-blue);
    }

    .modal-close:hover {
      transform: translateY(-2px);
      box-shadow:
        0 6px 0 rgba(50, 100, 140, 0.3),
        0 4px 16px rgba(74, 144, 194, 0.35);
    }

    .modal-close:active {
      transform: translateY(2px);
      box-shadow:
        0 2px 0 rgba(50, 100, 140, 0.35),
        var(--shadow-sm);
    }

    /* In-app confirm dialog content */
    .confirm-message {
      color: var(--text-secondary);
      font-size: var(--text-base);
      line-height: 1.35;
      margin: 0 0 var(--space-lg);
      text-align: center;
    }

    .confirm-actions {
      display: flex;
      gap: 10px;
      justify-content: center;
      align-items: center;
      flex-wrap: wrap;
    }

    .confirm-actions .modal-action-btn {
      min-width: 120px;
      min-height: 44px;
    }

    /* Reset button styling */
    .reset-btn {
      width: 100%;
      min-height: 48px;
      background:
        linear-gradient(180deg, var(--accent-coral-pale) 0%, var(--error-pale) 100%);
      color: #A54545;
      border: 2px solid var(--accent-coral-soft);
      border-radius: var(--radius-lg);
      font-family: var(--font-display);
      font-size: var(--text-base);
      font-weight: 600;
      cursor: pointer;
      margin-top: var(--space-sm);
      transition: all var(--anim-fast) var(--ease-out-soft);
    }

    .reset-btn:hover {
      background:
        linear-gradient(180deg, var(--accent-coral-soft) 0%, var(--accent-coral-pale) 100%);
      border-color: var(--accent-coral);
    }

    /* ===== CLOUD SAVE (FIREBASE) UI ===== */
    .modal-action-btn {
      border: none;
      border-radius: 999px;
      padding: 8px 12px;
      font-family: var(--font-display);
      font-weight: 800;
      font-size: 0.95rem;
      cursor: pointer;
      background:
        linear-gradient(135deg, var(--mrt-blue) 0%, var(--mrt-blue-soft) 100%);
      color: var(--text-inverse);
      box-shadow:
        0 3px 0 rgba(50, 100, 140, 0.25),
        var(--shadow-sm);
      transition: transform var(--anim-fast) var(--ease-out-soft), box-shadow var(--anim-fast) var(--ease-out-soft), opacity var(--anim-fast) var(--ease-out-soft);
      white-space: nowrap;
    }

    .modal-action-btn:hover {
      transform: translateY(-1px);
      box-shadow:
        0 4px 0 rgba(50, 100, 140, 0.22),
        var(--shadow-md);
    }

    .modal-action-btn:active {
      transform: translateY(1px);
      box-shadow:
        0 2px 0 rgba(50, 100, 140, 0.28),
        var(--shadow-sm);
    }

    .modal-action-btn.secondary {
      background:
        linear-gradient(180deg, rgba(255, 255, 255, 0.95) 0%, rgba(245, 245, 245, 0.95) 100%);
      color: var(--text-primary);
      border: 1px solid rgba(0, 0, 0, 0.08);
      box-shadow: var(--shadow-sm);
    }

    .modal-action-btn.danger {
      background:
        linear-gradient(135deg, var(--accent-coral) 0%, var(--accent-coral-soft) 100%);
      box-shadow:
        0 3px 0 rgba(200, 100, 90, 0.25),
        var(--shadow-sm);
    }

    .modal-action-btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      transform: none;
    }

    .modal-input {
      width: 100%;
      min-height: 44px;
      padding: 10px 12px;
      border-radius: var(--radius-lg);
      border: 1px solid rgba(0, 0, 0, 0.08);
      background: rgba(255, 255, 255, 0.95);
      font-family: var(--font-display);
      font-size: 1rem;
      outline: none;
      box-shadow: var(--shadow-inner);
    }

    .modal-input:focus {
      border-color: rgba(74, 144, 194, 0.55);
      box-shadow:
        var(--shadow-inner),
        0 0 0 3px rgba(74, 144, 194, 0.18);
    }

    .profiles-list {
      display: flex;
      flex-direction: column;
      gap: var(--space-sm);
    }

    .profile-select-row {
      cursor: pointer;
      transition:
        transform var(--anim-fast) var(--ease-out-soft),
        box-shadow var(--anim-fast) var(--ease-out-soft),
        border-color var(--anim-fast) var(--ease-out-soft);
    }

    .profile-select-row:hover {
      transform: translateY(-1px);
      box-shadow: var(--shadow-md);
      border-color: rgba(74, 144, 194, 0.35);
    }

    .profile-select-row:active {
      transform: translateY(0);
    }

    .profile-select-row:focus-visible {
      outline: 3px solid rgba(74, 144, 194, 0.25);
      outline-offset: 2px;
    }

    .profile-select-row.is-active {
      cursor: default;
      opacity: 0.9;
    }

    .profile-select-row.is-active:hover {
      transform: none;
      box-shadow: var(--shadow-sm);
      border-color: rgba(0, 0, 0, 0.06);
    }

    .profile-select-status {
      font-family: var(--font-display);
      font-size: 0.75rem;
      font-weight: 900;
      letter-spacing: 0.05em;
      text-transform: uppercase;
      color: rgba(74, 144, 194, 0.95);
      background: rgba(74, 144, 194, 0.14);
      border: 1px solid rgba(74, 144, 194, 0.22);
      padding: 6px 10px;
      border-radius: 999px;
      user-select: none;
    }

    .profile-card {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: var(--space-sm);
      padding: var(--space-md);
      border-radius: var(--radius-lg);
      background:
        linear-gradient(180deg, rgba(255, 255, 255, 0.9) 0%, rgba(248, 245, 240, 0.9) 100%);
      box-shadow: var(--shadow-sm);
      border: 1px solid rgba(0, 0, 0, 0.06);
    }

    .profile-left {
      display: flex;
      align-items: center;
      gap: var(--space-sm);
      min-width: 0;
    }

    .avatar-chip {
      width: 40px;
      height: 40px;
      border-radius: 12px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 22px;
      background: rgba(255, 255, 255, 0.7);
      box-shadow: var(--shadow-inner);
      flex: 0 0 auto;
    }

    .profile-text {
      min-width: 0;
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .profile-name {
      font-family: var(--font-display);
      font-weight: 900;
      color: var(--text-primary);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .profile-meta {
      font-size: 0.85rem;
      color: var(--text-secondary);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .welcome-profile-card {
      width: min(560px, 100%);
      margin-top: clamp(0.9rem, 2vh, 1.2rem);
      background: rgba(255, 255, 255, 0.78);
      backdrop-filter: blur(8px);
    }

    .welcome-profile-card .profile-meta {
      white-space: normal;
    }

    .welcome-profile-actions {
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
      justify-content: flex-end;
    }

    @media (max-width: 420px) {
      .welcome-profile-actions {
        width: 100%;
        justify-content: stretch;
      }

      .welcome-profile-actions .modal-action-btn {
        flex: 1 1 100%;
        justify-content: center;
      }
    }

    .avatar-picker {
      display: grid;
      grid-template-columns: repeat(8, 1fr);
      gap: 8px;
      margin-top: var(--space-sm);
    }

    @media (max-width: 420px) {
      .avatar-picker {
        grid-template-columns: repeat(6, 1fr);
      }
    }

    .avatar-option {
      min-width: 38px;
      height: 38px;
      border-radius: 12px;
      border: 1px solid rgba(0, 0, 0, 0.06);
      background: rgba(255, 255, 255, 0.8);
      cursor: pointer;
      box-shadow: var(--shadow-sm);
      font-size: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: transform var(--anim-fast) var(--ease-out-soft), box-shadow var(--anim-fast) var(--ease-out-soft);
      user-select: none;
    }

    .avatar-option:hover {
      transform: translateY(-1px);
      box-shadow: var(--shadow-md);
    }

    .avatar-option.selected {
      outline: 3px solid rgba(74, 144, 194, 0.45);
      background: rgba(232, 243, 250, 0.95);
    }

    .cloud-pill {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 4px 10px;
      border-radius: 999px;
      font-size: 0.85rem;
      font-weight: 900;
      background: rgba(232, 243, 250, 0.95);
      color: rgba(58, 125, 176, 1);
      border: 1px solid rgba(74, 144, 194, 0.25);
    }

    /* ===== RECOMMENDATION CARD (MAP CONTINUE) ===== */
    .mrt-recommendation {
      width: 100%;
      max-width: 560px;
      margin: 10px auto 12px;
      padding: 0 6px;
    }

    .recommendation-card {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 14px;
      padding: 14px 16px;
      border-radius: 18px;
      background:
        linear-gradient(180deg, rgba(255, 255, 255, 0.92) 0%, rgba(248, 245, 240, 0.92) 100%);
      border: 1px solid rgba(0, 0, 0, 0.06);
      box-shadow:
        0 8px 22px rgba(0, 0, 0, 0.10),
        0 3px 10px rgba(0, 0, 0, 0.06);
    }

    .recommendation-text {
      min-width: 0;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .recommendation-title {
      font-family: var(--font-display);
      font-weight: 900;
      font-size: 1.05rem;
      color: var(--text-primary);
      line-height: 1.15;
    }

    .recommendation-reason {
      font-size: 0.92rem;
      color: var(--text-secondary);
      line-height: 1.25;
    }

    .recommendation-actions {
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
      justify-content: flex-end;
      flex: 0 0 auto;
    }

    .recommendation-actions .modal-action-btn {
      padding: 10px 16px;
      font-size: 1rem;
      min-height: 44px;
    }

    @media (max-width: 420px) {
      .recommendation-card {
        flex-direction: column;
        align-items: stretch;
      }

      .recommendation-actions {
        justify-content: stretch;
      }

      .recommendation-actions .modal-action-btn {
        width: 100%;
      }
    }

    /* ===== RESPONSIVE ===== */
    @media (max-width: 768px) {
      body {
        padding: var(--space-sm);
      }

      .app-container {
        border-radius: var(--radius-xl);
        max-height: none;
        height: 100%;
      }

      .app-container::before,
      .app-container::after {
        display: none;
      }

      .header-title {
        font-size: var(--text-lg);
      }

      /* Mobile: the MRT progress bar already shows the station name. */
      .restaurant-header {
        display: none;
      }

      .header {
        padding: 10px 12px;
      }

      .header-controls {
        gap: 6px;
        flex-wrap: nowrap;
      }

      /* Mobile: keep the header compact (Settings + Audio is enough). */
      #skillsBtn {
        display: none;
      }

      /* Mobile: adjust buddy position and size */
      .buddy-container {
        top: 8px;
        right: 8px;
      }

      .buddy-character {
        width: 44px;
        height: 54px;
      }

      .buddy-cup {
        width: 36px;
        height: 40px;
      }

      .buddy-lid {
        top: 8px;
        width: 40px;
        height: 16px;
      }

      .buddy-straw {
        width: 7px;
        height: 20px;
      }

      .buddy-face {
        top: 24px;
        width: 28px;
      }

      .buddy-eye {
        width: 6px;
        height: 7px;
      }

      .buddy-menu {
        top: 65px;
        right: 8px;
        min-width: 140px;
      }

      .buddy-menu-item {
        padding: 12px 14px;
        font-size: 0.95rem;
      }

      .control-btn.control-text-btn {
        height: 38px;
        min-height: 38px;
        padding: 0 10px;
        font-size: 0.9rem;
      }

      /* Progress bar row is useful, but reduce its footprint on mobile. */
      .progress-container {
        padding: 8px 12px;
        gap: 10px;
      }

      .progress-label {
        display: none;
      }

      .sticker-count {
        font-size: 1rem;
        padding: 4px 10px;
      }

      .elevator-screen {
        flex-direction: column;
      }

      .elevator-panel {
        width: 100%;
        flex-direction: row;
        flex-wrap: nowrap;
        justify-content: center;
        gap: var(--space-xs);
      }

      .floor-btn {
        width: auto;
        min-width: 70px;
        flex: 1;
        max-width: 100px;
        min-height: 60px;
        padding: var(--space-xs);
      }

      .floor-btn .floor-num {
        font-size: var(--text-xl);
      }

      .floor-btn .floor-name {
        font-size: var(--text-xs);
      }

      .sentence-display {
        font-size: var(--text-xl);
      }

      .station-btn {
        min-width: 240px;
      }

      /* MRT Network Map - Tablet */
      .mrt-network-svg {
        max-width: 420px;
      }

      .mrt-station-label {
        font-size: 10px;
      }

      .mrt-map-legend {
        gap: 6px 12px;
        padding: 10px 14px;
      }

      .mrt-legend-item {
        font-size: 10px;
      }
    }

    @media (max-width: 500px) {
      .sentence-display {
        font-size: var(--text-lg);
      }

      .welcome-title {
        font-size: var(--text-2xl);
      }

      .answer-grid {
        grid-template-columns: 1fr;
      }

      /* Mobile: reduce vertical whitespace above lesson cards */
      .mrt-progress-bar {
        padding: 8px 12px;
        margin: 8px auto 12px;
      }

      .mrt-progress-mini-track {
        padding: 10px 6px 8px;
      }

      .mrt-progress-mini-train svg {
        width: 18px;
        height: 18px;
      }

      .reading-section {
        padding: 0;
        /* Fix mobile overlap: allow content to scroll if needed */
        overflow-y: auto;
        overflow-x: hidden;
        max-height: none;
        /* Ensure proper vertical stacking */
        gap: var(--space-sm);
      }

      .reading-section::before,
      .reading-section::after {
        display: none;
      }

      .question-section {
        padding: var(--space-md) var(--space-sm);
      }

      /* Mobile: Compact sentence display to leave room for sight word focus */
      .reading-section .sentence-display {
        padding: var(--space-sm) var(--space-md);
        min-height: auto;
        flex-shrink: 0;
      }

      /* Mobile: Sight word focus box stays below passage, not overlapping */
      .reading-section .sight-word-focus {
        position: relative;
        flex-shrink: 0;
        margin-top: var(--space-sm);
        margin-bottom: var(--space-sm);
        padding: var(--space-sm);
        background: var(--accent-mint-pale);
        border-radius: var(--radius-md);
        z-index: 1;
      }

      /* Mobile: Audio controls at bottom */
      .reading-section .audio-controls {
        flex-shrink: 0;
        padding-bottom: var(--space-xs);
      }

      /* MRT Network Map - Mobile - Pannable/Scrollable */
      .mrt-map {
        padding: 0;
        overflow: auto;
        -webkit-overflow-scrolling: touch;
        touch-action: pan-x pan-y;
        /* iOS/Safari: overflow scrolling is more reliable when this is not a flex container */
        display: block;
        min-width: 0;
        min-height: 0;
        /* Hide scrollbars but allow scrolling */
        scrollbar-width: none;
        -ms-overflow-style: none;
      }

      .mrt-map::-webkit-scrollbar {
        display: none;
      }

      /* Map scroll container - larger than viewport */
      .mrt-map-scroll-container {
        min-width: 560px;
        min-height: 760px;
        /* Shrink-wrap so scrollLeft=0 truly shows the left edge */
        display: inline-flex;
        flex-direction: column;
        align-items: center;
        justify-content: flex-start;
        padding: 1rem;
        gap: 0.5rem;
      }

      .mrt-network-svg {
        max-width: none;
        width: clamp(560px, 160vw, 720px);
        height: auto;
        flex-shrink: 0;
      }

      /* Pan hint indicator */
      .mrt-pan-hint {
        position: absolute;
        top: 8px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0, 0, 0, 0.7);
        color: white;
        padding: 6px 14px;
        border-radius: 20px;
        font-size: 11px;
        font-weight: 500;
        display: flex;
        align-items: center;
        gap: 6px;
        z-index: 10;
        opacity: 1;
        transition: opacity 0.5s ease;
        pointer-events: none;
      }

      .mrt-pan-hint.hidden {
        opacity: 0;
      }

      .mrt-pan-hint-icon {
        animation: pan-hint-swipe 1.5s ease-in-out infinite;
      }

      @keyframes pan-hint-swipe {

        0%,
        100% {
          transform: translateX(0);
        }

        50% {
          transform: translateX(6px);
        }
      }

      .mrt-line-path {
        stroke-width: 8;
      }

      .mrt-station-circle {
        stroke-width: 3;
      }

      .mrt-station-label {
        font-size: 12px;
        letter-spacing: 0.04em;
        text-shadow:
          0 1px 0 rgba(255, 255, 255, 0.95),
          0 -1px 0 rgba(255, 255, 255, 0.95),
          1px 0 0 rgba(255, 255, 255, 0.95),
          -1px 0 0 rgba(255, 255, 255, 0.95);
      }

      .mrt-hub-label {
        font-size: 9px;
        text-shadow:
          0 1px 0 rgba(255, 255, 255, 0.95),
          0 -1px 0 rgba(255, 255, 255, 0.95),
          1px 0 0 rgba(255, 255, 255, 0.95),
          -1px 0 0 rgba(255, 255, 255, 0.95);
      }

      .mrt-station-emoji {
        font-size: 16px;
      }

      .mrt-map-legend {
        gap: 4px 10px;
        padding: 8px 12px;
        margin-top: 8px;
        max-width: 340px;
      }

      .mrt-legend-item {
        font-size: 9px;
        gap: 4px;
      }

      .mrt-legend-line {
        width: 18px;
        height: 5px;
      }

      .mrt-legend-level {
        font-size: 7px;
        padding: 1px 4px;
      }
    }

    /* ===== iPAD PRO & LARGER TABLETS (850-1200px) ===== */
    /* iPad Pro 11" (834x1194), iPad Air (820x1180), iPad 10th gen (820x1180) */
    @media screen and (min-width: 850px) and (max-width: 1200px) {
      body {
        padding: 16px;
        font-size: 19px;
      }

      .app-container {
        max-width: 920px;
        max-height: 96vh;
        border-radius: var(--radius-2xl);
      }

      /* Header */
      .header {
        padding: 14px 20px;
      }

      .header-title {
        font-size: 1.15rem;
      }

      .control-btn {
        width: 48px;
        height: 48px;
        font-size: 1.4rem;
      }

      /* Welcome screen */
      .station-sign-hero {
        padding: 1.6rem 3.4rem;
        margin-bottom: 1.75rem;
      }

      .station-sign-hero .station-name-zh {
        font-size: 2.25rem;
      }

      .station-sign-hero .station-name-en {
        font-size: 1.35rem;
        letter-spacing: 0.15em;
      }

      .board-btn {
        padding: 20px 48px;
        font-size: 1.32rem;
        gap: 16px;
      }

      .mrt-train-scene {
        height: clamp(200px, 32vh, 280px);
      }

      /* MRT Map */
      .mrt-map {
        padding: 1.75rem 1.5rem;
      }

      .station-btn {
        min-height: 88px;
        padding: 18px 24px 18px 100px;
        margin-bottom: 20px;
        border-radius: 20px;
      }

      .station-btn::before {
        width: 30px;
        height: 30px;
        left: 28px;
        border-width: 7px;
      }

      .station-icon,
      .station-icon-img {
        width: 60px;
        height: 60px;
        font-size: 2.4rem;
        left: 85px;
      }

      .station-name {
        font-size: 1.2rem;
      }

      .station-desc {
        font-size: 0.95rem;
      }

      /* Lesson screen */
      .sentence-display {
        font-size: 1.6rem !important;
        line-height: 1.85;
        padding: 24px 28px;
      }

      .answer-btn {
        padding: 20px 28px;
        font-size: 1.2rem;
        border-radius: 18px;
        min-height: 68px;
      }

      .answer-grid {
        gap: 16px;
        padding: 18px 24px;
      }

      .reading-nav .big-btn {
        padding: 16px 32px;
        font-size: 1.1rem;
        min-height: 60px;
      }

      /* Progress bar */
      .mrt-progress-bar {
        padding: 14px 24px;
        margin: 14px auto 18px;
      }

      .mrt-progress-stop {
        width: 16px;
        height: 16px;
      }

      .mrt-progress-train svg {
        width: 32px;
        height: 32px;
      }

      /* Modals */
      .modal-content {
        max-width: 540px;
        padding: 32px;
      }

      .modal-title {
        font-size: 1.5rem;
      }

      .modal-action-btn {
        padding: 16px 28px;
        font-size: 1.1rem;
        min-height: 56px;
      }
    }

    /* ===== DESKTOP (1200px+) ===== */
    @media screen and (min-width: 1200px) {
      body {
        padding: 24px;
        font-size: 20px;
      }

      .app-container {
        max-width: 1000px;
        max-height: 94vh;
        border-radius: var(--radius-2xl);
        box-shadow:
          0 20px 60px rgba(60, 60, 60, 0.12),
          0 10px 30px rgba(60, 60, 60, 0.06),
          0 0 0 1px rgba(255, 255, 255, 0.5);
      }

      /* Welcome screen */
      .station-sign-hero {
        padding: 1.75rem 4rem;
        margin-bottom: 2.05rem;
      }

      .station-sign-hero .station-name-zh {
        font-size: 2.5rem;
      }

      .station-sign-hero .station-name-en {
        font-size: 1.45rem;
      }

      .board-btn {
        padding: 22px 56px;
        font-size: 1.38rem;
      }

      .mrt-train-scene {
        height: clamp(220px, 35vh, 320px);
      }

      .floating-food {
        font-size: clamp(2rem, 3vw, 2.5rem);
      }

      /* MRT Map - 2 column layout for larger screens */
      .mrt-map {
        padding: 2rem;
      }

      .station-list {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 16px;
      }

      .station-btn {
        min-height: 90px;
        margin-bottom: 0;
      }

      /* Lesson screen */
      .sentence-display {
        font-size: 1.75rem !important;
        padding: 28px 32px;
      }

      .answer-btn {
        padding: 22px 32px;
        font-size: 1.25rem;
        min-height: 72px;
      }

      .reading-nav .big-btn {
        padding: 18px 36px;
        font-size: 1.15rem;
      }

      /* Progress bar */
      .mrt-progress-bar {
        padding: 16px 28px;
      }

      .mrt-progress-stop {
        width: 18px;
        height: 18px;
      }

      /* Modals */
      .modal-content {
        max-width: 600px;
        padding: 36px;
      }

      .modal-title {
        font-size: 1.6rem;
      }
    }

    /* ===== ULTRAWIDE / LARGE DESKTOP (1600px+) ===== */
    @media screen and (min-width: 1600px) {
      .app-container {
        max-width: 1100px;
      }

      .station-list {
        gap: 20px;
      }
    }

    /* Landscape orientation */
    @media (orientation: landscape) and (max-height: 500px) {
      .elevator-screen {
        flex-direction: row;
      }

      .elevator-panel {
        width: 150px;
      }
    }
  </style>
</head>

<body>
  <!-- Bubble Tea Buddy - Kawaii companion for immersive screens -->
  <div class="buddy-container" id="buddyContainer">
    <div class="buddy-character" id="buddyCharacter" role="button" aria-label="Open menu" tabindex="0">
      <!-- Straw -->
      <div class="buddy-straw"></div>
      <!-- Dome lid -->
      <div class="buddy-lid"></div>
      <!-- Cup body -->
      <div class="buddy-cup">
        <!-- Milk tea fill -->
        <div class="buddy-tea">
          <!-- Boba pearls -->
          <div class="buddy-boba"></div>
          <div class="buddy-boba"></div>
          <div class="buddy-boba"></div>
          <div class="buddy-boba"></div>
          <div class="buddy-boba"></div>
          <div class="buddy-boba"></div>
          <div class="buddy-boba"></div>
          <div class="buddy-boba"></div>
        </div>
        <!-- Cute face -->
        <div class="buddy-face">
          <div class="buddy-eye left"></div>
          <div class="buddy-eye right"></div>
          <div class="buddy-blush left"></div>
          <div class="buddy-blush right"></div>
          <div class="buddy-smile"></div>
        </div>
      </div>
    </div>
  </div>

  <!-- Buddy Menu Overlay -->
  <div class="buddy-menu-overlay" id="buddyMenuOverlay"></div>

  <!-- Buddy Menu -->
  <nav class="buddy-menu" id="buddyMenu" aria-label="Navigation menu">
    <button class="buddy-menu-item" id="buddyMenuHome" type="button">
      <span class="menu-icon">ðŸ </span>
      <span class="menu-label">Map</span>
    </button>
    <div class="buddy-menu-divider"></div>
    <button class="buddy-menu-item" id="buddyMenuSkills" type="button">
      <span class="menu-icon">â­</span>
      <span class="menu-label">Skills</span>
    </button>
    <div class="buddy-menu-divider"></div>
    <button class="buddy-menu-item" id="buddyMenuAudio" type="button">
      <span class="menu-icon">ðŸ”Š</span>
      <span class="menu-label">Audio</span>
    </button>
    <div class="buddy-menu-divider"></div>
    <button class="buddy-menu-item" id="buddyMenuSettings" type="button">
      <span class="menu-icon">âš™ï¸</span>
      <span class="menu-label">Settings</span>
    </button>
  </nav>

  <div class="app-container">
    <!-- Header -->
    <header class="header">
      <div class="header-title">
        <button class="control-btn" id="homeBtn" type="button" title="Back to map" aria-label="Back to map">ðŸ </button>
        <button class="header-home" id="homeTitleBtn" type="button" title="Home">
          <span>MRT Food Adventure</span>
        </button>
      </div>
      <div class="header-controls">
        <button class="control-btn control-text-btn" id="skillsBtn" title="Skills">Skills</button>
        <button class="control-btn control-text-btn" id="soundToggle" title="Audio">Audio</button>
        <button class="control-btn control-text-btn" id="settingsBtn" title="Settings">Settings</button>
      </div>
    </header>

    <!-- Progress Bar -->
    <div class="progress-container">
      <span class="progress-label">Today's Progress</span>
      <div class="progress-bar">
        <div class="progress-fill" id="progressFill" style="width: 0%"></div>
      </div>
      <div class="sticker-count">
        <span>Stickers</span>
        <span id="stickerCount">0</span>
      </div>
    </div>

    <!-- Main Content Area -->
    <main class="main-content">

      <!-- Welcome Screen - Taipei MRT Platform -->
      <section class="screen welcome-screen active" id="welcomeScreen">

        <!-- Taipei Skyline Background -->
        <div class="welcome-skyline"></div>

        <!-- Vignette Effect -->
        <div class="welcome-vignette"></div>

        <!-- Ambient Light Particles -->
        <div class="ambient-particles">
          <div class="particle"></div>
          <div class="particle"></div>
          <div class="particle"></div>
          <div class="particle"></div>
          <div class="particle"></div>
          <div class="particle"></div>
          <div class="particle"></div>
          <div class="particle"></div>
        </div>

        <!-- Floating Food Emojis - Upper scenery area only -->
        <!-- Left side - upper half -->
        <div class="floating-food" style="--delay: 0s; --x: 5%; --y: 8%;">ðŸœ</div>
        <div class="floating-food" style="--delay: 2.5s; --x: 8%; --y: 22%;">ðŸ§‹</div>
        <div class="floating-food" style="--delay: 1.2s; --x: 3%; --y: 38%;">ðŸ¥¡</div>
        <!-- Right side - upper half -->
        <div class="floating-food" style="--delay: 0.8s; --x: 92%; --y: 6%;">ðŸ¥Ÿ</div>
        <div class="floating-food" style="--delay: 1.8s; --x: 95%; --y: 20%;">ðŸ±</div>
        <div class="floating-food" style="--delay: 3.2s; --x: 88%; --y: 35%;">ðŸ™</div>
        <!-- Top scattered - moved tea bowl left -->
        <div class="floating-food" style="--delay: 2.1s; --x: 18%; --y: 4%;">ðŸµ</div>
        <div class="floating-food" style="--delay: 4.2s; --x: 78%; --y: 5%;">ðŸ¡</div>
        <!-- Mid-upper area -->
        <div class="floating-food" style="--delay: 3.5s; --x: 12%; --y: 15%;">ðŸ¥®</div>
        <div class="floating-food" style="--delay: 1.5s; --x: 85%; --y: 12%;">ðŸ¢</div>


        <!-- MRT Platform -->
        <div class="mrt-platform">
          <!-- Welcome Content - Simplified & Cohesive -->
          <div class="welcome-content">
            <!-- Main Station Sign - The Hero Element -->
            <div class="station-sign station-sign-hero">
              <div class="station-name-zh">æ·é‹ç¾Žé£Ÿå†’éšª</div>
              <div class="station-name-en">MRT Food Adventure</div>
            </div>

            <!-- Integrated User + Action Bar -->
            <div class="welcome-action-bar">
              <div class="welcome-user-chip" id="welcomeProfileCard">
                <span class="user-avatar" id="welcomeProfileAvatar">ðŸ§’</span>
                <span class="user-name" id="welcomeProfileName">Isaiah</span>
                <button class="user-switch-btn" id="welcomeSwitchUserBtn" type="button"
                  aria-label="Switch user">â–¾</button>
              </div>
              <button class="board-btn" onclick="goToScreen('mrtScreen')">
                <span class="board-btn-icon">ðŸš‡</span>
                <span class="board-btn-text">Board the Train</span>
              </button>
            </div>

            <!-- Welcome Message removed (was confusing / redundant) -->
          </div>

          <!-- MRT Train Scene - Bottom -->
          <div class="mrt-train-scene" id="mrtTrainScene">
            <!-- Station Ceiling with Lights -->
            <div class="station-ceiling">
              <div class="ceiling-light"></div>
              <div class="ceiling-light"></div>
              <div class="ceiling-light"></div>
            </div>

            <!-- Light Beams from Ceiling -->
            <div class="light-beam"></div>
            <div class="light-beam"></div>
            <div class="light-beam"></div>

            <!-- Full Platform Glass Wall Barrier -->
            <div class="platform-glass-wall" id="platformGlassWall">
              <div class="glass-top-rail"></div>
            </div>

            <!-- Platform Screen Doors (start closed) -->
            <div class="platform-doors" id="platformDoors">
              <div class="door-pillar"></div>
              <div class="door-frame">
                <div class="door-panel left"></div>
                <div class="door-panel right"></div>
              </div>
              <div class="door-pillar"></div>
              <div class="door-frame">
                <div class="door-panel left"></div>
                <div class="door-panel right"></div>
              </div>
              <div class="door-pillar"></div>
              <div class="door-frame">
                <div class="door-panel left"></div>
                <div class="door-panel right"></div>
              </div>
              <div class="door-pillar"></div>
            </div>

            <!-- Realistic MRT Train -->
            <div class="mrt-train" id="welcomeTrain">
              <!-- Head Car -->
              <div class="train-head" style="--stripe-color: var(--line-blue);">
                <div class="train-roof"></div>
                <div class="train-ac-unit"></div>
                <div class="head-body">
                  <div class="head-stripe"></div>
                  <div class="head-windshield"></div>
                  <div class="head-display">
                    <span class="head-display-text">ç¾Žé£Ÿå°ˆè»Š</span>
                  </div>
                  <div class="head-windows">
                    <div class="head-window"></div>
                    <div class="head-window"></div>
                  </div>
	                  <div class="head-lights">
	                    <div class="headlight"></div>
	                    <div class="headlight"></div>
	                  </div>
	                  <div class="interior-glow"></div>
	                </div>
	                <div class="train-bogies">
	                  <div class="bogie"></div>
	                  <div class="bogie"></div>
	                </div>
              </div>

              <div class="train-connector"></div>

              <!-- Car 1 - Brown Line -->
              <div class="train-car-mrt" style="--stripe-color: var(--line-brown);">
                <div class="train-roof"></div>
                <div class="train-ac-unit" style="left: 35%;"></div>
                <div class="car-body-mrt">
                  <div class="car-stripe"></div>
	                  <div class="car-windows">
	                    <div class="car-window"></div>
	                    <div class="car-window"></div>
	                    <div class="car-window"></div>
	                  </div>
	                  <div class="interior-glow"></div>
	                </div>
	                <div class="train-bogies">
	                  <div class="bogie"></div>
	                  <div class="bogie"></div>
	                </div>
              </div>

              <div class="train-connector"></div>

              <!-- Car 2 - Red Line style -->
              <div class="train-car-mrt" style="--stripe-color: var(--line-red);">
                <div class="train-roof"></div>
                <div class="train-ac-unit" style="left: 35%;"></div>
                <div class="car-body-mrt">
                  <div class="car-stripe"></div>
	                  <div class="car-windows">
	                    <div class="car-window"></div>
	                    <div class="car-window"></div>
	                    <div class="car-window"></div>
	                  </div>
	                  <div class="interior-glow"></div>
	                </div>
	                <div class="train-bogies">
	                  <div class="bogie"></div>
	                  <div class="bogie"></div>
	                </div>
              </div>

              <div class="train-connector"></div>

              <!-- Car 3 - Green Line style -->
              <div class="train-car-mrt" style="--stripe-color: var(--line-green);">
                <div class="train-roof"></div>
                <div class="train-ac-unit" style="left: 35%;"></div>
                <div class="car-body-mrt">
                  <div class="car-stripe"></div>
	                  <div class="car-windows">
	                    <div class="car-window"></div>
	                    <div class="car-window"></div>
	                    <div class="car-window"></div>
	                  </div>
	                  <div class="interior-glow"></div>
	                </div>
	                <div class="train-bogies">
	                  <div class="bogie"></div>
	                  <div class="bogie"></div>
	                </div>
              </div>

              <div class="train-connector"></div>

              <!-- Car 4 - Orange Line style -->
              <div class="train-car-mrt" style="--stripe-color: var(--line-orange);">
                <div class="train-roof"></div>
                <div class="train-ac-unit" style="left: 35%;"></div>
                <div class="car-body-mrt">
                  <div class="car-stripe"></div>
	                  <div class="car-windows">
	                    <div class="car-window"></div>
	                    <div class="car-window"></div>
	                    <div class="car-window"></div>
	                  </div>
	                  <div class="interior-glow"></div>
	                </div>
	                <div class="train-bogies">
	                  <div class="bogie"></div>
	                  <div class="bogie"></div>
	                </div>
              </div>

              <div class="train-connector"></div>

              <!-- Car 5 - Purple Line style -->
              <div class="train-car-mrt" style="--stripe-color: var(--line-purple);">
                <div class="train-roof"></div>
                <div class="train-ac-unit" style="left: 35%;"></div>
                <div class="car-body-mrt">
                  <div class="car-stripe"></div>
	                  <div class="car-windows">
	                    <div class="car-window"></div>
	                    <div class="car-window"></div>
	                    <div class="car-window"></div>
	                  </div>
	                  <div class="interior-glow"></div>
	                </div>
	                <div class="train-bogies">
	                  <div class="bogie"></div>
	                  <div class="bogie"></div>
	                </div>
              </div>

              <div class="train-connector"></div>

              <!-- Car 6 - Yellow Line style -->
              <div class="train-car-mrt" style="--stripe-color: var(--line-yellow);">
                <div class="train-roof"></div>
                <div class="train-ac-unit" style="left: 35%;"></div>
                <div class="car-body-mrt">
                  <div class="car-stripe"></div>
	                  <div class="car-windows">
	                    <div class="car-window"></div>
	                    <div class="car-window"></div>
	                    <div class="car-window"></div>
	                  </div>
	                  <div class="interior-glow"></div>
	                </div>
	                <div class="train-bogies">
	                  <div class="bogie"></div>
	                  <div class="bogie"></div>
	                </div>
              </div>
            </div>

            <!-- Platform Elements -->
            <div class="platform-tactile"></div>
            <div class="platform-safety-line"></div>
            <div class="platform-floor"></div>

            <!-- Platform Warning Lights (blink when train arriving) -->
            <div class="platform-warning-lights">
              <div class="warning-light"></div>
              <div class="warning-light"></div>
              <div class="warning-light"></div>
              <div class="warning-light"></div>
              <div class="warning-light"></div>
              <div class="warning-light"></div>
              <div class="warning-light"></div>
              <div class="warning-light"></div>
            </div>

            <!-- Door Opening Whoosh Effect -->
            <div class="door-whoosh"></div>
          </div>
        </div>
      </section>

      <!-- MRT Map Screen - Authentic Taipei MRT Network -->
      <section class="screen mrt-screen" id="mrtScreen">
        <h2 class="mrt-title"
          style="font-family: var(--transit-font); text-transform: uppercase; letter-spacing: 0.08em; font-weight: 800;">
          ðŸš‡ Taipei MRT Network</h2>
        <p class="welcome-subtitle"
          style="margin: -4px auto 8px; text-align: center; color: #546E7A; font-size: 0.85rem; font-family: var(--transit-font); font-weight: 600;">
          Tap a station to start your food adventure!</p>
        <div class="mrt-recommendation" id="mrtRecommendation" style="display: none;">
          <div class="recommendation-card">
            <div class="recommendation-text">
              <div class="recommendation-title" id="recommendationTitle">Next up</div>
              <div class="recommendation-reason" id="recommendationReason"></div>
            </div>
            <div class="recommendation-actions">
              <button class="modal-action-btn" id="recommendationContinueBtn" type="button">Continue</button>
              <button class="modal-action-btn secondary" id="recommendationAltBtn" type="button"
                style="display: none;">Story next</button>
            </div>
          </div>
        </div>
        <div class="mrt-map" id="mrtMap">
          <!-- SVG Network Map generated dynamically -->
        </div>
      </section>

      <!-- Skills Screen -->
      <section class="screen mrt-screen" id="skillsScreen">
        <h2 class="mrt-title">Skill Practice</h2>
        <p class="welcome-subtitle" style="margin: 0 auto var(--space-md); text-align: center;">
          Practice phonics, vocabulary, and comprehension.
        </p>
        <div
          style="display: flex; gap: 10px; justify-content: center; flex-wrap: wrap; margin-bottom: var(--space-md);">
          <button class="control-btn skills-filter-btn" id="skillsFilterAll" title="All Levels">All</button>
          <button class="control-btn skills-filter-btn" id="skillsFilter1" title="Level 1">Level 1</button>
          <button class="control-btn skills-filter-btn" id="skillsFilter2" title="Level 2">Level 2</button>
          <button class="control-btn skills-filter-btn" id="skillsFilter3" title="Level 3">Level 3</button>
          <button class="control-btn skills-filter-btn" id="skillsFilter4" title="Level 4">Level 4</button>
        </div>
        <div id="skillsList" class="mrt-map" style="padding-top: 0;">
          <!-- Skills generated dynamically -->
	        </div>
	        <div style="text-align: center; margin-top: var(--space-md);">
	          <button class="big-btn secondary" onclick="goHome()" type="button">
	            <span>Back to Map</span>
	          </button>
	        </div>
	      </section>

      <!-- MRT Ride Animation - Train Window Experience -->
      <section class="screen mrt-ride-screen" id="mrtRideScreen">

        <!-- Scenery Container (what you see through the window) -->
        <div class="scenery-container">

          <!-- Sky Layer (furthest back) -->
          <div class="sky-layer">
            <div class="celestial-body"></div>
          </div>

          <!-- Floating Clouds -->
          <div class="cloud-layer">
            <div class="cloud cloud-1"></div>
            <div class="cloud cloud-2"></div>
            <div class="cloud cloud-3"></div>
            <div class="cloud cloud-1" style="left: 110%;"></div>
            <div class="cloud cloud-2" style="left: 140%;"></div>
          </div>

          <!-- Distant Mountains (parallax layer 1 - slowest) -->
          <div class="mountains-layer">
            <div class="mountain mountain-1"></div>
            <div class="mountain mountain-2"></div>
            <div class="mountain mountain-3"></div>
            <div class="mountain mountain-4"></div>
            <div class="mountain mountain-5"></div>
            <div class="mountain mountain-6"></div>
            <div class="mountain mountain-7"></div>
          </div>

          <!-- Rolling Hills (parallax layer 2) -->
          <div class="hills-layer">
            <div class="hill hill-1"></div>
            <div class="hill hill-2"></div>
            <div class="hill hill-3"></div>
            <div class="hill hill-4"></div>
            <div class="hill hill-5"></div>
            <div class="hill hill-6"></div>
            <div class="hill hill-7"></div>
          </div>

          <!-- Trees (parallax layer 3 - fastest) -->
          <div class="trees-layer">
            <div class="trees-strip">
              <div class="tree tree-1"></div>
              <div class="tree tree-2"></div>
              <div class="tree tree-3"></div>
              <div class="tree tree-4"></div>
              <div class="tree tree-5"></div>
              <div class="tree tree-6"></div>
              <div class="tree tree-7"></div>
              <div class="tree tree-8"></div>
              <div class="tree tree-9"></div>
              <div class="tree tree-10"></div>
              <div class="tree tree-11"></div>
              <div class="tree tree-12"></div>
              <div class="tree tree-13"></div>
              <div class="tree tree-14"></div>
            </div>
            <div class="trees-strip" aria-hidden="true">
              <div class="tree tree-1"></div>
              <div class="tree tree-2"></div>
              <div class="tree tree-3"></div>
              <div class="tree tree-4"></div>
              <div class="tree tree-5"></div>
              <div class="tree tree-6"></div>
              <div class="tree tree-7"></div>
              <div class="tree tree-8"></div>
              <div class="tree tree-9"></div>
              <div class="tree tree-10"></div>
              <div class="tree tree-11"></div>
              <div class="tree tree-12"></div>
              <div class="tree tree-13"></div>
              <div class="tree tree-14"></div>
            </div>
          </div>

          <!-- Ground Layer -->
          <div class="ground-layer"></div>

          <!-- Train Tracks -->
          <div class="train-track"></div>
          <div class="track-ties"></div>

          <!-- Themed Floating Elements -->
          <div class="themed-floaters" id="themedFloaters">
          </div>

          <!-- Magical Sparkles -->
          <div class="sparkle-layer">
            <div class="sparkle sparkle-1"></div>
            <div class="sparkle sparkle-2"></div>
            <div class="sparkle sparkle-3"></div>
            <div class="sparkle sparkle-4"></div>
            <div class="sparkle sparkle-5"></div>
            <div class="sparkle sparkle-6"></div>
            <div class="sparkle sparkle-7"></div>
            <div class="sparkle sparkle-8"></div>
          </div>

          <!-- Taipei Animated Elements -->
          <div class="taipei-bird taipei-bird-1" aria-hidden="true"></div>
          <div class="taipei-bird taipei-bird-2" aria-hidden="true"></div>
          <div class="taipei-bird taipei-bird-3" aria-hidden="true"></div>
          <div class="taipei-balloon" aria-hidden="true"></div>
          <div class="taipei-lantern taipei-lantern-1" aria-hidden="true"></div>
          <div class="taipei-lantern taipei-lantern-2" aria-hidden="true"></div>
          <div class="taipei-lantern taipei-lantern-3" aria-hidden="true"></div>

        </div>

        <!-- Taiwan MRT Train (welcome-style, recolored per line) -->
        <div class="mrt-train" id="mrtTrain" aria-hidden="true">
          <!-- Head Car -->
          <div class="train-head">
            <div class="train-roof"></div>
            <div class="train-ac-unit"></div>
            <div class="head-body">
              <div class="head-stripe"></div>
              <div class="head-windshield"></div>
              <div class="head-display">
                <span class="head-display-text">ç¾Žé£Ÿå°ˆè»Š</span>
              </div>
              <div class="head-windows">
                <div class="head-window"></div>
                <div class="head-window"></div>
              </div>
              <div class="head-lights">
                <div class="headlight"></div>
                <div class="headlight"></div>
              </div>
              <div class="interior-glow"></div>
            </div>
            <div class="train-bogies">
              <div class="bogie"></div>
              <div class="bogie"></div>
            </div>
          </div>

          <div class="train-connector"></div>

          <!-- Car 1 -->
          <div class="train-car-mrt">
            <div class="train-roof"></div>
            <div class="train-ac-unit" style="left: 35%;"></div>
            <div class="car-body-mrt">
              <div class="car-stripe"></div>
              <div class="car-windows">
                <div class="car-window"></div>
                <div class="car-window"></div>
                <div class="car-window"></div>
              </div>
              <div class="interior-glow"></div>
            </div>
            <div class="train-bogies">
              <div class="bogie"></div>
              <div class="bogie"></div>
            </div>
          </div>

          <div class="train-connector"></div>

          <!-- Car 2 -->
          <div class="train-car-mrt">
            <div class="train-roof"></div>
            <div class="train-ac-unit" style="left: 35%;"></div>
            <div class="car-body-mrt">
              <div class="car-stripe"></div>
              <div class="car-windows">
                <div class="car-window"></div>
                <div class="car-window"></div>
                <div class="car-window"></div>
              </div>
              <div class="interior-glow"></div>
            </div>
            <div class="train-bogies">
              <div class="bogie"></div>
              <div class="bogie"></div>
            </div>
          </div>

          <div class="train-connector"></div>

          <!-- Car 3 -->
          <div class="train-car-mrt">
            <div class="train-roof"></div>
            <div class="train-ac-unit" style="left: 35%;"></div>
            <div class="car-body-mrt">
              <div class="car-stripe"></div>
              <div class="car-windows">
                <div class="car-window"></div>
                <div class="car-window"></div>
                <div class="car-window"></div>
              </div>
              <div class="interior-glow"></div>
            </div>
            <div class="train-bogies">
              <div class="bogie"></div>
              <div class="bogie"></div>
            </div>
          </div>

          <div class="train-connector"></div>

          <!-- Car 4 -->
          <div class="train-car-mrt">
            <div class="train-roof"></div>
            <div class="train-ac-unit" style="left: 35%;"></div>
            <div class="car-body-mrt">
              <div class="car-stripe"></div>
              <div class="car-windows">
                <div class="car-window"></div>
                <div class="car-window"></div>
                <div class="car-window"></div>
              </div>
              <div class="interior-glow"></div>
            </div>
            <div class="train-bogies">
              <div class="bogie"></div>
              <div class="bogie"></div>
            </div>
          </div>
        </div>

        <!-- LED Destination Display -->
        <div class="destination-display">
          <div class="display-label">Next Stop</div>
          <div class="display-destination">
            <span class="display-icon" id="rideIcon" style="display: none;"></span>
            <span class="display-name" id="destinationName">Fruit Stand</span>
          </div>
        </div>

        <!-- Train Window Frame (on top of everything) -->
        <div class="train-window-frame">
          <div class="window-rivet top-left"></div>
          <div class="window-rivet top-right"></div>
          <div class="window-rivet bottom-left"></div>
          <div class="window-rivet bottom-right"></div>
        </div>
      </section>

      <!-- Elevator Screen -->
      <section class="screen elevator-screen" id="elevatorScreen">
        <div class="elevator-shaft" id="elevatorShaft">
          <div class="floor-display" id="floorDisplay">1</div>
          <div class="elevator-doors" id="elevatorDoors">
            <div class="door door-left"></div>
            <div class="door door-right"></div>
            <div class="door-window" id="doorWindow"></div>
          </div>
        </div>
        <div class="elevator-panel">
          <div class="panel-title">Pick a Floor</div>
          <button class="floor-btn active" onclick="selectFloor(1)" id="floor1Btn">
            <span class="floor-num">1</span>
            <span class="floor-name">Lobby</span>
          </button>
          <button class="floor-btn" onclick="selectFloor(2)" id="floor2Btn">
            <span class="floor-num">2</span>
            <span class="floor-name">Warm-Up</span>
          </button>
          <button class="floor-btn" onclick="selectFloor(3)" id="floor3Btn">
            <span class="floor-num">3</span>
            <span class="floor-name">Food Stop</span>
          </button>
        </div>
      </section>

      <!-- Word Warm-Up Screen (Floor 2) -->
      <!-- Educational purpose: Pre-teaching vocabulary + explicit phonics instruction -->
      <!-- This follows Orton-Gillingham approach: see it, hear it, say it -->
      <section class="screen warmup-screen" id="warmupScreen">
        <div class="warmup-header">
          <div class="warmup-icon" id="warmupIcon" style="display: none;"></div>
          <h2 class="warmup-title">Word Warm-Up!</h2>
          <p class="warmup-subtitle">Tap a word to hear it and practice. This is optional.</p>
        </div>

        <!-- Phonics Focus Box - Shows digraph/pattern for this station -->
        <div class="phonics-focus-box" id="phonicsFocusBox" style="display: none;">
          <span class="phonics-label">Sound focus</span>
          <span class="phonics-pattern" id="phonicsPattern">SH</span>
          <span class="phonics-example" id="phonicsExample">says shh, like quiet.</span>
        </div>

        <div class="warmup-words" id="warmupWords">
          <!-- Words will be inserted dynamically -->
        </div>

        <div class="warmup-progress">
          <div class="warmup-progress-bar" id="warmupProgressBar"></div>
        </div>

        <!-- Sight Word Reminder -->
        <div class="sight-word-reminder" id="sightWordReminder" style="display: none;">
          <span class="reminder-text">Cards marked <strong>SW</strong> are <strong>sight words</strong>. We memorize them.</span>
        </div>

        <button class="warmup-continue-btn" id="warmupContinueBtn" onclick="finishWarmup()">
          <span>Go to Food Stop!</span>
          <span class="arrow" aria-hidden="true">â†’</span>
        </button>
      </section>

      <!-- Restaurant Screen -->
	      <section class="screen restaurant-screen" id="restaurantScreen">
	        <div class="restaurant-header">
	          <h2 class="restaurant-name" id="restaurantName">Fruit Stand</h2>
	          <div class="lesson-floor-chip" id="lessonFloorChip">Floor 3</div>
	        </div>

        <!-- MRT Lesson Progress - Mini MRT line with animated train -->
        <div class="mrt-progress-bar line-red" id="mrtLessonProgress" style="display: none;">
          <!-- Mobile View: Mini MRT Line -->
          <div class="mrt-progress-mobile" id="mrtProgressMobile">
            <div class="mrt-progress-mini-track" id="mobileTrackContainer">
              <div class="mrt-progress-mini-line" id="mobileMiniLine">
                <!-- Generated by JS: stops and segments -->
              </div>
            </div>
            <div class="mrt-progress-mobile-info">
              <span class="mrt-progress-mobile-badge" id="mobileBadge">Red</span>
              <span class="mrt-progress-mobile-station" id="mobileStationName">Fruit Stand</span>
              <span class="mrt-progress-mobile-count" id="mobileCount">â€¢ 1/8</span>
            </div>
          </div>

          <!-- Desktop View: Full MRT Line -->
          <div class="mrt-progress-desktop">
            <div class="mrt-progress-track" id="mrtProgressTrack">
              <!-- Progress stops with train will be generated here by JavaScript -->
            </div>
            <div class="mrt-progress-info">
              <span class="mrt-progress-line-badge" id="progressLineBadge">Red Line</span>
              <span class="mrt-progress-station-name" id="progressStationName">Fruit Stand</span>
            </div>
          </div>
        </div>

        <!-- Story Scene Art (pilot â€œchoose your adventureâ€ stations) -->
        <div class="story-scene-panel" id="storyScenePanel" style="display: none;">
          <div class="story-scene-frame">
            <img id="storySceneImage" alt="" loading="eager" />
            <div class="story-scene-vignette" aria-hidden="true"></div>
          </div>
          <div class="story-scene-caption" id="storySceneCaption" style="display: none;"></div>
        </div>

	        <div class="reading-section">
          <!-- MRT Line Indicator - shows which line/stop you're on -->
          <div class="mrt-line-indicator" id="mrtLineIndicator" style="display: none;">
            <span class="line-dot"></span>
            <span class="line-name" id="lineIndicatorName">Red Line</span>
            <span class="stop-info" id="lineIndicatorStop">â€¢ Stop 1</span>
          </div>
          <div class="sentence-image" id="sentenceImage" style="display: none;"></div>
          <div class="sentence-display" id="sentenceDisplay">
            <!-- Words will be inserted here -->
          </div>

          <!-- Reading Tip Box - Scaffolding for struggling readers -->
          <div class="reading-tip-box" id="readingTipBox" style="display: none;">
            <span class="tip-text" id="readingTipText"></span>
          </div>

	          <!-- Sight Word Focus - Compact single-line design -->
	          <div class="sight-word-focus" id="sightWordFocus" style="display: none;">
	            <span class="focus-label" id="sightWordLabel">Sight word</span>
	            <span class="focus-word" id="focusSightWord"></span>
	            <span class="focus-action" id="sightWordAction">Tap to hear</span>
	          </div>
	          <div class="sight-word-gate-row" id="sightWordGateRow" style="display: none;" aria-live="polite">
	            <div class="sight-word-gate-text" id="sightWordGateText" style="display: none;"></div>
	            <button class="sight-word-skip-btn" id="sightWordSkipBtn" type="button" style="display: none;">Skip</button>
	          </div>

	          <div class="audio-controls">
	            <button class="audio-btn" onclick="playFullSentence()">
	              <span>Read to Me</span>
	            </button>
            <button class="audio-btn tip-btn" onclick="showReadingTip()" id="tipBtn" style="display: none;">
              <span>Help</span>
            </button>
          </div>
        </div>

        <div class="menu-section" id="menuSection" style="display: none;">
          <div class="menu-story" id="menuStory" style="display: none;"></div>
          <div class="menu-prompt">What do you want?</div>
          <div class="menu-grid" id="menuGrid">
            <!-- Menu items inserted dynamically -->
          </div>
        </div>

        <div class="question-section" id="questionSection" style="display: none;">
          <!-- Progress Indicator -->
          <div class="question-progress" id="questionProgress">
            <div class="progress-dots" id="progressDots"></div>
          </div>

          <!-- Question Type Badge -->
          <div class="question-type-badge" id="questionTypeBadge">
            <span class="badge-icon">?</span>
            <span class="badge-text">Question</span>
          </div>

          <div class="passage-box question-passage" id="passageBox"
            style="display: none; margin-bottom: var(--space-md); max-width: 560px; margin-left: auto; margin-right: auto;">
            <div class="passage-header">
              <span class="passage-title">The Story So Far</span>
              <button class="control-btn passage-read-btn" id="passageReadBtn" type="button">Read All</button>
            </div>
            <div class="passage-body" id="passageText"></div>
          </div>

          <div class="question-text" id="questionText">What did you pick?</div>

          <!-- Evidence-based answering prompt -->
          <div class="evidence-prompt" id="evidencePrompt">
            <span class="evidence-text">Tip: Tap the words in the story that help answer this question.</span>
          </div>

          <!-- 3-Level Hint Ladder -->
          <div class="hint-ladder" id="hintLadder">
            <div class="hint-ladder-header">
              <div class="hint-ladder-title">
                <span>Need Help?</span>
              </div>
              <button class="hint-btn" id="getHintBtn" onclick="showNextHint()">
                <span>Get Hint</span>
                <span class="hint-counter" id="hintCounter">3</span>
              </button>
            </div>
            <div class="hint-level level-1" id="hintLevel1"></div>
            <div class="hint-level level-2" id="hintLevel2"></div>
            <div class="hint-level level-3" id="hintLevel3"></div>
          </div>

          <!-- Error explanation for instructional feedback -->
          <div class="error-explanation" id="errorExplanation">
            <div class="error-explanation-title">Let's think about this...</div>
            <div class="error-explanation-text" id="errorExplanationText"></div>
          </div>

          <!-- Hint Box (appears after wrong answer) -->
          <div class="hint-box" id="hintBox" style="display: none;">
            <div class="hint-box-icon">ðŸ’¡</div>
            <div class="hint-box-content">
              <div class="hint-box-title">Hint</div>
              <div class="hint-box-text" id="hintBoxText"></div>
            </div>
          </div>

          <div class="question-hint" id="questionHint" style="display: none;"></div>

          <!-- Bonus phonics question for digraph stations -->
          <div class="bonus-question" id="bonusQuestion" style="display: none;">
            <span class="bonus-text" id="bonusQuestionText"></span>
          </div>

          <div class="answer-grid" id="answerGrid">
            <!-- Answer buttons inserted dynamically -->
          </div>

          <!-- Success feedback with learning reinforcement -->
          <div class="success-feedback" id="successFeedback" style="display: none;">
            <div class="success-icon">âœ“</div>
            <span class="success-text" id="successFeedbackText"></span>
          </div>

          <!-- Celebration Container -->
          <div class="celebration-container" id="celebrationContainer"></div>
        </div>

        <div style="text-align: center; margin-top: auto; padding-top: var(--space-md);">
          <button class="big-btn secondary" id="continueBtn" style="display: none;" onclick="continueStory()">
            <span>Next</span>
            <span aria-hidden="true">â†’</span>
          </button>
        </div>
      </section>

      <!-- Interactive Read Page -->
      <section class="screen read-page" id="readPageScreen">
        <div class="read-page-container">

          <!-- Page Progress Indicator -->
          <div class="read-progress-dots" id="readProgressDots">
            <!-- Dots will be generated by JS -->
          </div>

          <!-- Station-themed Background Image -->
          <div class="read-page-background" id="readPageBackground"></div>

          <!-- Large Emoji Display -->
          <div class="read-page-emoji" id="readPageEmoji">ðŸŽ</div>

          <!-- Reading Tip Box -->
          <div class="reading-tip" id="readingTip" style="display: none;">
            <span class="tip-icon">ðŸ’¡</span>
            <span class="tip-text" id="tipText">Tap each word to hear it!</span>
          </div>

          <!-- Interactive Sentence Display -->
          <div class="read-sentence" id="readSentence">
            <!-- Words will be inserted here by createInteractiveWord() -->
          </div>

          <!-- Read-to-Me Controls -->
          <div class="read-controls">
            <button class="read-to-me-btn" id="readToMeBtn" type="button" aria-label="Read entire sentence">
              <span class="read-btn-icon">ðŸ”Š</span>
              <span class="read-btn-text">Read to Me</span>
            </button>

            <div class="read-speed-controls" id="readSpeedControls">
              <button class="speed-btn" id="speedNormal" data-speed="normal" type="button">Normal</button>
              <button class="speed-btn" id="speedSlow" data-speed="slow" type="button">Slow</button>
            </div>

            <button class="read-pause-btn" id="readPauseBtn" type="button" style="display: none;">
              <span id="pauseBtnIcon">â¸</span>
              <span id="pauseBtnText">Pause</span>
            </button>
          </div>

          <!-- Navigation -->
          <div class="read-navigation">
            <button class="read-nav-btn read-prev-btn" id="readPrevBtn" type="button" style="display: none;">
              <span>â† Previous</span>
            </button>
            <button class="read-nav-btn read-next-btn" id="readNextBtn" type="button">
              <span>Next â†’</span>
            </button>
          </div>

        </div>
      </section>

      <!-- Reward Screen -->
      <section class="screen reward-screen" id="rewardScreen">
        <div class="reward-celebration"></div>
        <h2 class="reward-title">Great Job!</h2>
        <p class="reward-message" id="rewardMessage">You read and ordered food!</p>
        <div class="reward-story-meta" id="rewardStoryMeta" style="display: none;"></div>
        <div class="sticker-earned" id="stickerEarned"></div>
        <div class="reward-actions">
          <button class="big-btn primary" onclick="finishReward()" id="rewardContinueBtn" type="button">
            <span id="rewardContinueText">Keep Going!</span>
          </button>
          <button class="big-btn secondary" id="rewardPlayAgainBtn" type="button" style="display: none;" onclick="replayStoryFromReward()">
            <span>Try a different path</span>
          </button>
        </div>
      </section>

    </main>
  </div>

  <!-- Parent Settings Modal -->
  <div class="modal-overlay" id="settingsModal">
    <div class="modal-content">
      <h3 class="modal-title">Parent Settings</h3>

      <div class="setting-group">
        <label class="setting-label">Sound</label>
        <div class="setting-toggle">
          <span>Enable Sound</span>
          <div class="toggle-switch active" id="soundSettingToggle" onclick="toggleSetting('sound')"></div>
        </div>
        <div class="setting-toggle">
          <span>Voice guidance</span>
          <div class="toggle-switch active" id="guidanceSettingToggle" onclick="toggleSetting('guidance')"></div>
        </div>
      </div>

      <div class="setting-group">
        <label class="setting-label">Appearance</label>
        <div class="setting-toggle">
          <span>Text Size</span>
          <div class="segmented-control">
            <button class="segment-btn active" id="fontNormalBtn" onclick="toggleSetting('font-normal')">Aa</button>
            <button class="segment-btn" id="fontLargeBtn" onclick="toggleSetting('font-large')">Aa+</button>
            <button class="segment-btn" id="fontXLargeBtn" onclick="toggleSetting('font-xlarge')">Aa++</button>
          </div>
        </div>
        <div class="setting-toggle">
          <span>High Contrast</span>
          <div class="toggle-switch" id="contrastSettingToggle" onclick="toggleSetting('contrast')"></div>
        </div>
      </div>

      <div class="setting-group">
        <label class="setting-label">Calm Mode</label>
        <div class="setting-toggle">
          <span>Reduce animations &amp; colors</span>
          <div class="toggle-switch" id="calmSettingToggle" onclick="toggleSetting('calm')"></div>
        </div>
      </div>

      <div class="setting-group">
        <label class="setting-label">Reading Supports</label>
        <div class="setting-toggle">
          <span>Mark sight words in sentences</span>
          <div class="toggle-switch active" id="sightWordMarksSettingToggle" onclick="toggleSetting('sightWordMarks')">
          </div>
        </div>
        <div class="setting-toggle">
          <span>Tap sight word to unlock Next</span>
          <div class="toggle-switch active" id="sightWordGateSettingToggle" onclick="toggleSetting('sightWordGate')">
          </div>
        </div>
      </div>

      <div class="setting-group" id="cloudSaveSettingsGroup">
        <label class="setting-label">Account &amp; Cloud Save</label>
        <div class="setting-toggle">
          <span id="firebaseStatusText">Cloud save: checkingâ€¦</span>
          <div style="display: flex; gap: 8px; align-items: center; flex-wrap: wrap; justify-content: flex-end;">
            <button class="modal-action-btn" id="googleSignInBtn" type="button" style="display: none;">Sign in</button>
            <button class="modal-action-btn secondary" id="signOutBtn" type="button" style="display: none;">Sign
              out</button>
          </div>
        </div>
        <div class="setting-toggle" id="childProfileRow" style="display: none;">
          <span>Child profile</span>
          <div style="display: flex; gap: 8px; align-items: center; flex-wrap: wrap; justify-content: flex-end;">
            <span class="cloud-pill" id="activeChildLabel" style="display: none;">No child selected</span>
            <button class="modal-action-btn" id="manageProfilesBtn" type="button">Choose</button>
          </div>
        </div>
        <div class="setting-toggle" id="cloudSyncRow" style="display: none;">
          <span id="cloudSyncText">Cloud sync: off</span>
          <button class="modal-action-btn secondary" id="cloudSyncNowBtn" type="button">Sync now</button>
        </div>
        <div class="setting-toggle" id="dashboardRow" style="display: none;">
          <span>Insights</span>
          <button class="modal-action-btn" id="openDashboardBtn" type="button">Parent dashboard</button>
        </div>
      </div>

      <div class="setting-group">
        <label class="setting-label">Progress</label>
        <div class="setting-toggle">
          <span>Pages completed today: <strong id="pagesCompleted">0</strong></span>
        </div>
      </div>

      <div class="setting-group">
        <label class="setting-label">Words Mastered</label>
        <div class="setting-toggle">
          <span id="wordsMastered">0</span> / <span id="wordsTotal">50</span>
        </div>
      </div>

      <div class="setting-group">
        <label class="setting-label">Stations Completed</label>
        <div class="setting-toggle">
          <span id="stationsCompleted">0</span> / 8
        </div>
      </div>

      <div class="setting-group">
        <label class="setting-label">Reset Progress</label>
        <div class="setting-toggle">
          <button onclick="resetProgress()"
            style="padding: 8px 16px; background: var(--accent-coral); color: white; border: none; border-radius: 8px; cursor: pointer;">Reset
            All</button>
        </div>
      </div>

      <div class="setting-group">
        <label class="setting-label">Navigation</label>
        <div class="setting-toggle" style="justify-content: flex-end;">
          <button class="modal-action-btn secondary" id="settingsMapBtn" type="button">Back to map</button>
        </div>
      </div>

      <button class="modal-close" onclick="closeSettings()">Done</button>
    </div>
  </div>

  <!-- Child Profiles Modal (Firebase-backed, parent-managed) -->
  <div class="modal-overlay" id="profilesModal">
    <div class="modal-content">
      <h3 class="modal-title">Child Profiles</h3>

      <div class="setting-group">
        <label class="setting-label">Choose a child</label>
        <div class="profiles-list" id="profilesList"></div>
        <div class="profile-meta" id="profilesEmptyText" style="display: none; margin-top: var(--space-sm);">
          No child profiles yet. Add one below.
        </div>
      </div>

      <div class="setting-group">
        <label class="setting-label" id="childFormTitle">Add a child</label>
        <div style="display: flex; flex-direction: column; gap: 10px;">
          <input class="modal-input" id="childNameInput" type="text" placeholder="Child name (e.g., Isaiah)"
            maxlength="24" autocomplete="off" />
          <div id="avatarPicker" class="avatar-picker"></div>
          <div style="display: flex; gap: 10px; justify-content: flex-end; flex-wrap: wrap;">
            <button class="modal-action-btn secondary" id="cancelEditChildBtn" type="button"
              style="display: none;">Cancel</button>
            <button class="modal-action-btn danger" id="deleteChildBtn" type="button"
              style="display: none;">Archive</button>
            <button class="modal-action-btn" id="saveChildBtn" type="button">Save</button>
          </div>
          <div class="profile-meta" id="profilesErrorText" style="display: none; color: #A54545; font-weight: 900;">
          </div>
        </div>
      </div>

      <button class="modal-close" onclick="closeProfiles()">Done</button>
    </div>
  </div>

  <!-- Parent Dashboard Modal -->
  <div class="modal-overlay" id="dashboardModal">
    <div class="modal-content">
      <h3 class="modal-title">Parent Dashboard</h3>

      <div class="setting-group">
        <label class="setting-label">Signed in as</label>
        <div class="setting-toggle">
          <span id="dashboardUserText">â€”</span>
        </div>
      </div>

      <div class="setting-group">
        <label class="setting-label">Children</label>
        <div class="profiles-list" id="dashboardChildrenList"></div>
      </div>

      <div class="setting-group" id="dashboardDetailGroup" style="display: none;">
        <label class="setting-label">Child details</label>
        <div id="dashboardDetail" style="display: flex; flex-direction: column; gap: 10px;"></div>
      </div>

      <button class="modal-close" onclick="closeDashboard()">Done</button>
    </div>
  </div>

  <!-- Confirm Modal (in-app replacement for browser confirm dialogs) -->
  <div class="modal-overlay" id="confirmModal" role="dialog" aria-modal="true" aria-labelledby="confirmTitle"
    aria-describedby="confirmMessage">
    <div class="modal-content">
      <h3 class="modal-title" id="confirmTitle">Are you sure?</h3>
      <p class="confirm-message" id="confirmMessage">Do you want to continue?</p>
      <div class="confirm-actions">
        <button class="modal-action-btn secondary" id="confirmCancelBtn" type="button">Cancel</button>
        <button class="modal-action-btn" id="confirmOkBtn" type="button">OK</button>
      </div>
    </div>
  </div>

  <script>
    // ===== GAME STATE =====
    // TEST MODE: Set to true to unlock all stations for testing
	    const TEST_MODE = true;
	    const state = {
	      currentScreen: 'welcomeScreen',
	      currentStation: null,
	      currentFloor: 1,
	      currentPage: 0,
	      sessionPages: null,
	      mapTrainStation: null,
	      mapTrainAtHub: false,
	      lessonElevatorPlan: null,
	      lessonElevatorSegmentByPage: null,
	      lessonElevatorVisitedSegments: null,
	      lessonElevatorActiveSegment: 0,
	      elevatorTripCounter: 0,
	      deviceId: null,
	      serverTimeOffsetMs: 0,
	      serverTimeOffsetUpdatedAt: 0,
      stickers: 0,
      pagesCompleted: 0,
      progressCounters: {
        stickersByDevice: { legacy: 0 },
        pagesCompletedByDevice: { legacy: 0 },
      },
      progressUpdatedAt: 0,
      progressResetAt: 0,
      soundEnabled: true,
      guidanceEnabled: true,
      calmMode: false,
      fontSize: 'normal',
      highContrast: false,
      sightWordMarksEnabled: true,
      sightWordGateEnabled: true,
      completedStations: [],
      masteredWords: new Set(),
	      currentOrder: null,
	      // Food Adventure story runs (pilot). Used to build branching pages + track endings.
	      storySession: null,
	      storyProgress: {
	        schemaVersion: 1,
	        stations: {}
	      },
	      stationTransitionTimeoutId: null,
	      isTransitioningToStation: false, // Prevents double-clicking stations
	      lastUserInteractionAt: Date.now(),
      requiredSightWord: null,
      sightWordGateSatisfied: true,
      sightWordSkipTimeoutId: null,
      practiceSkillId: null,
      practiceCorrect: 0,
      practiceFirstTryCorrect: 0,
      practiceTotal: 0,
      skillsLevelFilter: 'all',
      analytics: {
        schemaVersion: 1,
        stations: {},
        skills: {},
        strategies: {},
        recentAnswers: [],
        recentMistakes: [],
        updatedAt: 0,
      },
      mastery: {
        schemaVersion: 1,
        attemptsBySkill: {},
        skills: {},
        updatedAt: 0,
      },
      cloud: {
        enabled: false,
        ready: false,
        config: null,
        user: null,
        activeChildId: null,
        activeChild: null,
        children: [],
        syncing: false,
        lastSyncAt: null,
        saveDebounceId: null,
        suppressNextCloudSave: false,
        sessionId: null,
        localImportPrompted: false,
      },
      localProfiles: [],
    };

    // ===== DEVICE ID + SERVER TIME OFFSET (SYNC STABILITY) =====
    const DEVICE_ID_KEY = 'isaiahDeviceId';
    const SERVER_TIME_OFFSET_KEY = 'isaiahServerTimeOffsetMs';
    const SERVER_TIME_OFFSET_UPDATED_KEY = 'isaiahServerTimeOffsetUpdatedAt';

    function getOrCreateDeviceId() {
      try {
        const existing = localStorage.getItem(DEVICE_ID_KEY);
        if (existing && typeof existing === 'string' && existing.trim()) return existing.trim();
      } catch (e) { }

      const id = `dev_${Math.random().toString(36).slice(2, 10)}_${Date.now().toString(36)}`;
      try { localStorage.setItem(DEVICE_ID_KEY, id); } catch (e) { }
      return id;
    }

    function loadServerTimeOffsetFromStorage() {
      try {
        const offset = Number(localStorage.getItem(SERVER_TIME_OFFSET_KEY));
        const updatedAt = Number(localStorage.getItem(SERVER_TIME_OFFSET_UPDATED_KEY));
        if (Number.isFinite(offset)) state.serverTimeOffsetMs = offset;
        if (Number.isFinite(updatedAt)) state.serverTimeOffsetUpdatedAt = updatedAt;
      } catch (e) { }
    }

    function getSyncNowMs() {
      const offset = Number.isFinite(state.serverTimeOffsetMs) ? state.serverTimeOffsetMs : 0;
      return Date.now() + offset;
    }

    async function refreshServerTimeOffset({ force = false } = {}) {
      const now = Date.now();
      const last = Number.isFinite(state.serverTimeOffsetUpdatedAt) ? state.serverTimeOffsetUpdatedAt : 0;
      if (!force && last && (now - last) < 10 * 60 * 1000) return state.serverTimeOffsetMs;

      try {
        const t0 = Date.now();
        const response = await fetch('/api/time', { cache: 'no-store' });
        const t1 = Date.now();
        if (!response.ok) return state.serverTimeOffsetMs;
        const body = await response.json();
        const serverNowMs = body && Number.isFinite(body.nowMs) ? body.nowMs : null;
        if (serverNowMs === null) return state.serverTimeOffsetMs;

        // Best-effort NTP-style midpoint estimate to reduce network jitter.
        const midClientMs = (t0 + t1) / 2;
        const rawOffset = serverNowMs - midClientMs;
        if (!Number.isFinite(rawOffset)) return state.serverTimeOffsetMs;

        // Clamp extreme offsets (guards against bad responses / crazy device clocks).
        const maxAbs = 7 * 24 * 60 * 60 * 1000; // 7 days
        const offset = Math.max(-maxAbs, Math.min(maxAbs, rawOffset));

        state.serverTimeOffsetMs = offset;
        state.serverTimeOffsetUpdatedAt = now;
        try {
          localStorage.setItem(SERVER_TIME_OFFSET_KEY, String(offset));
          localStorage.setItem(SERVER_TIME_OFFSET_UPDATED_KEY, String(now));
        } catch (e) { }

        return offset;
      } catch (e) {
        return state.serverTimeOffsetMs;
      }
    }

    // ===== VOICE GUIDANCE PROMPTS =====
    // Short, friendly, auto-play instructions that tell the learner what to do on each screen/card.
    // These are played with the ElevenLabs voice (via `speak()`), and can be disabled in Parent Settings.
	    const guidancePrompts = {
	      screens: {
        welcomeScreen: 'Ready to read and ride? Tap Start to begin.',
        mrtScreen: 'Pick a station.',
        skillsScreen: 'Pick a skill. Choose a level if you want.',
        mrtRideScreen: 'All aboard! We are riding to your next stop.',
        elevatorScreen: 'Choose a floor.',
        warmupScreen: 'Tap the word cards to hear them. When you feel ready, continue to the story.',
        rewardScreen: 'Nice work! Tap Keep Going to choose what to do next.',
      },
	      lessons: {
	        read: {
	          standard: 'Read the sentence and follow along. Tap a word to hear it.',
	          sightGate: 'Tap the highlighted sight word one time. Then read the sentence. Press Next when you are ready.',
	          sightGateBlocked: 'Tap the highlighted sight word one time. Then press Next.',
	          sightGateSatisfied: 'Nice! One is enough. Press Next.',
	        },
        menu: {
          standard: 'Choose one thing you want. Then press Next to keep going.',
        },
        question: {
          withPassage: 'Read the full story in the box. Look for the green highlighted part, then choose the best answer.',
          noPassage: 'Read the question and choose the best answer.',
          sightBlank: 'Read the sentence with the blank, then choose the word that makes it sound right.',
        },
        practice: {
          withClue: 'Practice time! Check the clue in the box, then pick the best answer.',
          noClue: 'Practice time! Read carefully, then pick the best answer.',
          sightBlank: 'Practice time! Read the sentence with the blank, then choose the word that fits.',
        }
      }
    };
    // ===== END GUIDANCE PROMPTS =====

    let guidanceTimeoutId = null;
    let guidanceToken = 0;
    const playedPageGuidanceKeys = new Set();
    const playedScreenGuidanceKeys = new Set();
    let lastGuidanceKey = null;
    let lastGuidanceAt = 0;
    let lastUserInteractionAt = 0;

    function markUserInteraction() {
      lastUserInteractionAt = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
      // If the learner is already interacting, don't let queued guidance interrupt them.
      if (guidanceTimeoutId) cancelGuidancePlayback();
    }

    function cancelGuidancePlayback() {
      guidanceToken++;
      if (guidanceTimeoutId) {
        clearTimeout(guidanceTimeoutId);
        guidanceTimeoutId = null;
      }
    }

    function stopGuidanceAudioOnNavigation({ fadeMs = 140 } = {}) {
      cancelGuidancePlayback();
      if (currentAudioKind === 'guidance') {
        stopSpeech({ fadeMs });
        currentAudioKind = null;
      }
    }

    function scheduleGuidancePlayback({ key, text, guardScreenId = null, delayMs = 220 }) {
      if (!text || typeof text !== 'string' || !text.trim()) return;
      if (!state.soundEnabled || !state.guidanceEnabled) return;

      const now = Date.now();
      if (lastGuidanceKey === key && (now - lastGuidanceAt) < 1200) return;
      lastGuidanceKey = key;
      lastGuidanceAt = now;

      cancelGuidancePlayback();
      const token = ++guidanceToken;
      const interactionMark = lastUserInteractionAt;

      guidanceTimeoutId = setTimeout(() => {
        if (token !== guidanceToken) return;
        if (guardScreenId && state.currentScreen !== guardScreenId) return;
        if (interactionMark !== lastUserInteractionAt) return;
        if (!state.soundEnabled || !state.guidanceEnabled) return;

        try {
          if (window.speechSynthesis) window.speechSynthesis.cancel();
        } catch (e) { }

        speak(text, 1.08, { kind: 'guidance' });
      }, Math.max(0, delayMs));
    }

    function collectStringsFromObject(value, out = []) {
      if (typeof value === 'string') {
        if (value.trim()) out.push(value.trim());
        return out;
      }
      if (Array.isArray(value)) {
        value.forEach(v => collectStringsFromObject(v, out));
        return out;
      }
      if (value && typeof value === 'object') {
        Object.values(value).forEach(v => collectStringsFromObject(v, out));
      }
      return out;
    }

    async function preloadGuidanceAudio() {
      try {
        const texts = collectStringsFromObject(guidancePrompts, []);
        const unique = Array.from(new Set(texts.map(t => t.toLowerCase().trim()))).filter(Boolean);
        const storeInMemory = !shouldPreferHtmlAudioPlayback();
        unique.forEach(cacheKey => enqueueTtsPreload(cacheKey, { priority: 25, token: null, storeInMemory }));
      } catch (e) {
        // Best effort; guidance can still be fetched on-demand.
      }
    }

	    function playScreenGuidance(screenId) {
	      if (!screenId || !guidancePrompts || !guidancePrompts.screens) return;
	      // Restaurant guidance is handled per-card (read/menu/question), not per-screen, to avoid double narration.
	      if (screenId === 'restaurantScreen') return;
	      // During auto elevator transitions, skip the "Choose a floor" guidance.
	      if (screenId === 'elevatorScreen') {
	        const elevator = document.getElementById('elevatorScreen');
	        if (elevator && elevator.classList.contains('elevator-auto-mode')) return;
	      }
	      // During the return ride animation, skip ride guidance (it would announce the wrong â€œnext stopâ€).
	      if (screenId === 'mrtRideScreen') {
	        const ride = document.getElementById('mrtRideScreen');
	        if (ride && ride.classList.contains('returning')) return;
	      }

	      // The map + skills screens are visited frequently; only play their guidance once per app load.
	      if ((screenId === 'mrtScreen' || screenId === 'skillsScreen') && playedScreenGuidanceKeys.has(screenId)) {
	        return;
	      }
      playedScreenGuidanceKeys.add(screenId);

      let text = guidancePrompts.screens[screenId] || '';
      let key = `screen:${screenId}`;

      // Make the train ride guidance specific: "Next stop: Smoothie Stand."
      if (screenId === 'mrtRideScreen' && state.currentStation) {
        const station = stationContent[state.currentStation];
        const stationName = station && station.name ? String(station.name).trim() : '';
        if (stationName) {
          text = `All aboard! Next stop: ${stationName}.`;
          key = `screen:${screenId}:${state.currentStation}`;
        }
      }

      scheduleGuidancePlayback({ key, text, guardScreenId: screenId });
    }

    function normalizeTokenForGuidance(tokenText) {
      return String(tokenText || '')
        .toLowerCase()
        .replace(/^[â€œ"']+|[â€"']+$/g, '')
        .replace(/[^a-z0-9']/g, '');
    }

    function getLessonGuidanceForPage(page) {
      if (!page || typeof page !== 'object' || !guidancePrompts || !guidancePrompts.lessons) return null;
      const station = stationContent[state.currentStation];
      const isPractice = !!station?.isPractice;

      if (page.type === 'read') {
        const focusSightWord = String(page.sightWordFocus || '').trim();
        const shouldGate =
          !!(focusSightWord &&
            page.requireSightWordTap &&
            state.sightWordGateEnabled &&
            !state.calmMode &&
            (() => {
              const wordList = Array.isArray(page.words) ? page.words : splitSentenceIntoWords(page.sentence || '');
              const focusKey = normalizeTokenForGuidance(focusSightWord);
              return wordList.some(w => normalizeTokenForGuidance(w) === focusKey);
            })());

        return {
          key: `page:${state.currentStation}:${state.currentPage}:read:${shouldGate ? 'sightGate' : 'standard'}`,
          text: shouldGate ? guidancePrompts.lessons.read.sightGate : guidancePrompts.lessons.read.standard,
        };
      }

      if (page.type === 'menu') {
        return {
          key: `page:${state.currentStation}:${state.currentPage}:menu:standard`,
          text: guidancePrompts.lessons.menu.standard,
        };
      }

      if (page.type === 'question') {
        const questionLower = String(page.question || '').toLowerCase();
        const passageLower = String(page.passage || '').toLowerCase();
        const isSightWordQuestion = questionLower.includes('sight word') || passageLower.includes('sight word');
        const hasBlank =
          /_{2,}/.test(String(page.passage || '')) ||
          /_{2,}/.test(String(page.question || '')) ||
          questionLower.includes('fill in') ||
          questionLower.includes('blank');

        const fullPassage = getFullPassageForQuestion();
        const passage = fullPassage || normalizePassageText(page.passage || '') || getMostRecentPassageTextForQuestion();
        const isComprehensionQuestion = page.questionType === 'comprehension' && !isSightWordQuestion;
        const showsPassageBox = Boolean(passage && isComprehensionQuestion);

        if (hasBlank || isSightWordQuestion) {
          return {
            key: `page:${state.currentStation}:${state.currentPage}:question:blank`,
            text: isPractice ? guidancePrompts.lessons.practice.sightBlank : guidancePrompts.lessons.question.sightBlank,
          };
        }

        if (showsPassageBox) {
          return {
            key: `page:${state.currentStation}:${state.currentPage}:question:withPassage`,
            text: isPractice ? guidancePrompts.lessons.practice.withClue : guidancePrompts.lessons.question.withPassage,
          };
        }

        return {
          key: `page:${state.currentStation}:${state.currentPage}:question:noPassage`,
          text: isPractice ? guidancePrompts.lessons.practice.noClue : guidancePrompts.lessons.question.noPassage,
        };
      }

      return null;
    }

    function playLessonGuidanceForPage(page) {
      const info = getLessonGuidanceForPage(page);
      if (!info || !info.key || !info.text) return;

      // Only play once per unique page instance (avoids repeating when the UI re-renders).
      if (playedPageGuidanceKeys.has(info.key)) return;
      playedPageGuidanceKeys.add(info.key);

      scheduleGuidancePlayback({ key: info.key, text: info.text, guardScreenId: state.currentScreen });
    }

    // ===== CLOUD BACKEND (FIREBASE AUTH + FIRESTORE) =====
    const CLOUD_ACTIVE_CHILD_KEY = 'isaiahActiveChildId';
    const CLOUD_ACTIVE_CHILD_SNAPSHOT_KEY = 'isaiahActiveChildSnapshot';
    const LOCAL_CHILD_PROFILES_KEY = 'isaiahChildProfiles';
    const CLOUD_PROGRESS_CHILD_PREFIX = 'isaiahProgress_child_';
    const CLOUD_LEGACY_PROGRESS_MIGRATED_KEY = 'isaiahLegacyProgressMigrated';
    const LEGACY_PROGRESS_KEY = 'isaiahProgress';
    const CLOUD_PERSISTABLE_EVENT_TYPES = new Set(['session_start', 'question_answered', 'station_completed', 'progress_reset']);
    const CLOUD_EVENT_TTL_DAYS = 180;
    const CLOUD_EVENT_TTL_MS = CLOUD_EVENT_TTL_DAYS * 24 * 60 * 60 * 1000;

    const FIREBASE_SDK_VERSION = '10.12.5';
    const FIREBASE_SDK_URLS = [
      `https://www.gstatic.com/firebasejs/${FIREBASE_SDK_VERSION}/firebase-app-compat.js`,
      `https://www.gstatic.com/firebasejs/${FIREBASE_SDK_VERSION}/firebase-auth-compat.js`,
      `https://www.gstatic.com/firebasejs/${FIREBASE_SDK_VERSION}/firebase-firestore-compat.js`,
    ];

    const AVATAR_OPTIONS = [
      'ðŸ§’', 'ðŸ‘§', 'ðŸ‘¦', 'ðŸ¯', 'ðŸ¦Š', 'ðŸ¼', 'ðŸ¨', 'ðŸ¸',
      'ðŸ¦', 'ðŸµ', 'ðŸ°', 'ðŸ¶', 'ðŸ±', 'ðŸ»', 'ðŸ¦„', 'ðŸ™',
      'ðŸ³', 'ðŸ¦–', 'ðŸš†', 'ðŸš€', 'ðŸŒˆ', 'â­ï¸', 'ðŸ•', 'ðŸ¦'
    ];

    let profilesEditingChildId = null;
    let profilesSelectedAvatar = AVATAR_OPTIONS[0];

    function safeJsonParse(raw, fallback = null) {
      if (typeof raw !== 'string' || !raw) return fallback;
      try {
        return JSON.parse(raw);
      } catch (e) {
        return fallback;
      }
    }

    function makeId(prefix = 'id') {
      return `${prefix}_${Math.random().toString(36).slice(2, 10)}_${Date.now().toString(36)}`;
    }

    function getProgressStorageKey(childId = null) {
      const id = childId || state.cloud.activeChildId;
      return id ? `${CLOUD_PROGRESS_CHILD_PREFIX}${id}` : 'isaiahProgress';
    }

    function getActiveChildSnapshot() {
      try {
        return safeJsonParse(localStorage.getItem(CLOUD_ACTIVE_CHILD_SNAPSHOT_KEY), null);
      } catch (e) {
        return null;
      }
    }

    function setActiveChildSnapshot(snapshot) {
      if (!snapshot) {
        try { localStorage.removeItem(CLOUD_ACTIVE_CHILD_SNAPSHOT_KEY); } catch (e) { }
        return;
      }
      try { localStorage.setItem(CLOUD_ACTIVE_CHILD_SNAPSHOT_KEY, JSON.stringify(snapshot)); } catch (e) { }
    }

    function getProfilesSource() {
      return (state.cloud.ready && state.cloud.user) ? 'cloud' : 'local';
    }

    function readLocalProfilesRaw() {
      try {
        const parsed = safeJsonParse(localStorage.getItem(LOCAL_CHILD_PROFILES_KEY), []);
        return Array.isArray(parsed) ? parsed : [];
      } catch (e) {
        return [];
      }
    }

    function writeLocalProfilesRaw(profiles) {
      try { localStorage.setItem(LOCAL_CHILD_PROFILES_KEY, JSON.stringify(profiles)); } catch (e) { }
    }

    function loadLocalProfiles() {
      const raw = readLocalProfilesRaw();
      const seen = new Set();
      const cleaned = [];

      raw.forEach(item => {
        if (!item || typeof item !== 'object') return;
        const id = typeof item.id === 'string' ? item.id.trim() : '';
        if (!id || seen.has(id)) return;
        seen.add(id);

        const name = String(item.name || '').trim() || 'Child';
        const avatar = String(item.avatar || 'ðŸ§’');
        const archived = Boolean(item.archived);
        const createdAt = Number.isFinite(item.createdAt) ? item.createdAt : 0;
        const updatedAt = Number.isFinite(item.updatedAt) ? item.updatedAt : 0;

        cleaned.push({ id, name, avatar, archived, createdAt, updatedAt });
      });

      cleaned.sort((a, b) => (a.createdAt || 0) - (b.createdAt || 0));
      state.localProfiles = cleaned.filter(p => !p.archived);
      return state.localProfiles;
    }

    function mergeLocalProfilesFromCloud(children) {
      if (!Array.isArray(children) || children.length === 0) return;
      const now = Date.now();
      const raw = readLocalProfilesRaw();
      const byId = new Map();

      raw.forEach(item => {
        if (!item || typeof item !== 'object') return;
        const id = typeof item.id === 'string' ? item.id.trim() : '';
        if (!id) return;
        byId.set(id, item);
      });

      children.forEach(child => {
        if (!child || typeof child !== 'object') return;
        const id = typeof child.id === 'string' ? child.id.trim() : '';
        if (!id) return;

        const existing = byId.get(id) || {};
        byId.set(id, {
          ...existing,
          id,
          name: String(child.name || existing.name || 'Child').trim() || 'Child',
          avatar: String(child.avatar || existing.avatar || 'ðŸ§’'),
          archived: false,
          createdAt: Number.isFinite(existing.createdAt) ? existing.createdAt : now,
          updatedAt: now,
        });
      });

      writeLocalProfilesRaw(Array.from(byId.values()));
      loadLocalProfiles();
    }

    function getProfilesForUi() {
      if (getProfilesSource() === 'cloud') {
        return Array.isArray(state.cloud.children) ? state.cloud.children : [];
      }
      return Array.isArray(state.localProfiles) ? state.localProfiles : [];
    }

    function getActiveProfileDisplay() {
      const active = state.cloud.activeChild || getActiveChildSnapshot();
      if (active && active.name) {
        return {
          name: String(active.name || '').trim() || 'Child',
          avatar: String(active.avatar || 'ðŸ§’'),
        };
      }
      return { name: 'Isaiah', avatar: 'ðŸ§’' };
    }

    function updateWelcomeAccountUi() {
      const avatarEl = document.getElementById('welcomeProfileAvatar');
      const nameEl = document.getElementById('welcomeProfileName');
      const { name, avatar } = getActiveProfileDisplay();

      if (avatarEl) avatarEl.textContent = avatar;
      if (nameEl) nameEl.textContent = name;
    }

    function bindWelcomeAccountHandlers() {
      // Clicking the user chip or switch button opens profile selector
      const userChip = document.getElementById('welcomeProfileCard');
      const switchBtn = document.getElementById('welcomeSwitchUserBtn');

      if (userChip) userChip.onclick = () => openProfiles();
      if (switchBtn) switchBtn.onclick = (e) => {
        e.stopPropagation(); // Prevent double-trigger from chip
        openProfiles();
      };
    }

    // Bind immediately (don't wait for `window.onload`, which can be delayed by large images).
    bindWelcomeAccountHandlers();

    async function loadExternalScriptOnce(src) {
      if (!loadExternalScriptOnce.promises) loadExternalScriptOnce.promises = new Map();
      const existing = loadExternalScriptOnce.promises.get(src);
      if (existing) return existing;

      const promise = new Promise((resolve, reject) => {
        const script = document.createElement('script');
        script.src = src;
        script.async = true;
        script.onload = () => resolve();
        script.onerror = () => reject(new Error(`Failed to load script: ${src}`));
        document.head.appendChild(script);
      });

      loadExternalScriptOnce.promises.set(src, promise);
      return promise;
    }

    async function loadFirebaseSdk() {
      if (window.firebase && window.firebase.apps) return true;
      try {
        for (const url of FIREBASE_SDK_URLS) {
          await loadExternalScriptOnce(url);
        }
        return Boolean(window.firebase && window.firebase.apps);
      } catch (e) {
        console.warn('Failed to load Firebase SDK', e);
        return false;
      }
    }

    function updateWelcomeTitle() {
      const title = document.getElementById('welcomeTitle');
      const display = getActiveProfileDisplay();
      const displayName = String(display && display.name ? display.name : 'Isaiah').trim() || 'Isaiah';

      if (title) {
        const words = title.querySelectorAll('.title-word');
        if (words && words.length >= 2) {
          words[0].textContent = `${displayName}'s`;
        } else {
          title.textContent = `Welcome, ${displayName}!`;
        }
      }

      updateWelcomeAccountUi();
    }

    function setCloudUiText(text) {
      const el = document.getElementById('firebaseStatusText');
      if (el) el.textContent = text;
    }

    function updateCloudSettingsUi() {
      const signInBtn = document.getElementById('googleSignInBtn');
      const signOutBtn = document.getElementById('signOutBtn');
      const childRow = document.getElementById('childProfileRow');
      const childLabel = document.getElementById('activeChildLabel');
      const cloudSyncRow = document.getElementById('cloudSyncRow');
      const cloudSyncText = document.getElementById('cloudSyncText');
      const dashboardRow = document.getElementById('dashboardRow');

      if (!state.cloud.enabled) {
        setCloudUiText('Cloud save: not configured');
        if (signInBtn) signInBtn.style.display = 'none';
        if (signOutBtn) signOutBtn.style.display = 'none';
        if (childRow) childRow.style.display = 'none';
        if (cloudSyncRow) cloudSyncRow.style.display = 'none';
        if (dashboardRow) dashboardRow.style.display = 'none';
        if (childLabel) childLabel.style.display = 'none';
        return;
      }

      if (!state.cloud.ready) {
        setCloudUiText('Cloud save: loadingâ€¦');
        if (signInBtn) signInBtn.style.display = 'none';
        if (signOutBtn) signOutBtn.style.display = 'none';
        if (childRow) childRow.style.display = 'none';
        if (cloudSyncRow) cloudSyncRow.style.display = 'none';
        if (dashboardRow) dashboardRow.style.display = 'none';
        if (childLabel) childLabel.style.display = 'none';
        return;
      }

      if (!state.cloud.user) {
        setCloudUiText('Cloud save: sign in to save progress');
        if (signInBtn) signInBtn.style.display = 'inline-flex';
        if (signOutBtn) signOutBtn.style.display = 'none';
        if (childRow) childRow.style.display = 'none';
        if (cloudSyncRow) cloudSyncRow.style.display = 'none';
        if (dashboardRow) dashboardRow.style.display = 'none';
        if (childLabel) childLabel.style.display = 'none';
        return;
      }

      setCloudUiText('Cloud save: signed in');
      if (signInBtn) signInBtn.style.display = 'none';
      if (signOutBtn) signOutBtn.style.display = 'inline-flex';
      if (childRow) childRow.style.display = 'flex';
      if (dashboardRow) dashboardRow.style.display = 'flex';

      if (childLabel) {
        const active = state.cloud.activeChild || getActiveChildSnapshot();
        if (active && (active.name || active.avatar)) {
          const avatar = active.avatar ? `${active.avatar} ` : '';
          childLabel.textContent = `${avatar}${active.name || 'Child'}`.trim();
          childLabel.style.display = 'inline-flex';
        } else {
          childLabel.textContent = 'No child selected';
          childLabel.style.display = 'none';
        }
      }

      if (cloudSyncRow) cloudSyncRow.style.display = state.cloud.activeChildId ? 'flex' : 'none';
      if (cloudSyncText) {
        if (!state.cloud.activeChildId) cloudSyncText.textContent = 'Cloud sync: choose a child';
        else if (state.cloud.syncing) cloudSyncText.textContent = 'Cloud sync: syncingâ€¦';
        else if (state.cloud.lastSyncAt) cloudSyncText.textContent = 'Cloud sync: synced';
        else cloudSyncText.textContent = 'Cloud sync: ready';
      }
    }

    function closeProfiles() {
      const modal = document.getElementById('profilesModal');
      if (modal) modal.classList.remove('active');
    }

    function openProfiles(options = {}) {
      const modal = document.getElementById('profilesModal');
      if (modal) modal.classList.add('active');
      profilesEditingChildId = null;
      profilesSelectedAvatar = AVATAR_OPTIONS[0];
      loadLocalProfiles();
      renderProfilesModal();

      if (options && options.focusAdd) {
        requestAnimationFrame(() => {
          const nameInput = document.getElementById('childNameInput');
          if (nameInput) {
            nameInput.focus();
            if (typeof nameInput.scrollIntoView === 'function') {
              nameInput.scrollIntoView({ block: 'center' });
            }
          }
        });
      }
    }

    function closeDashboard() {
      const modal = document.getElementById('dashboardModal');
      if (modal) modal.classList.remove('active');
    }

    function openDashboard() {
      const modal = document.getElementById('dashboardModal');
      if (modal) modal.classList.add('active');
      renderDashboardModal();
    }

    async function initCloudBackend() {
      setCloudUiText('Cloud save: checkingâ€¦');
      await refreshServerTimeOffset().catch(() => { });

      // Restore last selected child ID (used for local progress keying even before auth).
      let cachedChildId = null;
      try { cachedChildId = localStorage.getItem(CLOUD_ACTIVE_CHILD_KEY); } catch (e) { cachedChildId = null; }
      if (cachedChildId && !state.cloud.activeChildId) {
        state.cloud.activeChildId = cachedChildId;
      }
      updateWelcomeTitle();

      try {
        const resp = await fetch('/api/firebase-config', { cache: 'no-store' });
        if (!resp.ok) {
          state.cloud.enabled = false;
          state.cloud.ready = false;
          setCloudUiText('Cloud save: unavailable');
          updateCloudSettingsUi();
          return;
        }

        const body = await resp.json();
        state.cloud.enabled = Boolean(body && body.enabled && body.config);
        state.cloud.config = (body && body.config) ? body.config : null;

        if (!state.cloud.enabled) {
          state.cloud.ready = false;
          setCloudUiText('Cloud save: not configured');
          updateCloudSettingsUi();
          return;
        }

        const sdkOk = await loadFirebaseSdk();
        if (!sdkOk) {
          state.cloud.ready = false;
          setCloudUiText('Cloud save: failed to load');
          updateCloudSettingsUi();
          return;
        }

        const cfg = state.cloud.config;
        if (cfg && window.firebase && window.firebase.apps && window.firebase.apps.length === 0) {
          window.firebase.initializeApp(cfg);
        }

        state.cloud.ready = true;
        updateCloudSettingsUi();

        try {
          window.firebase.firestore().enablePersistence({ synchronizeTabs: true }).catch(() => { });
        } catch (e) { }

        try {
          window.firebase.auth().setPersistence(window.firebase.auth.Auth.Persistence.LOCAL).catch(() => { });
        } catch (e) { }

        // If we used redirect sign-in on mobile, finalize it.
        try {
          window.firebase.auth().getRedirectResult().catch(() => { });
        } catch (e) { }

        window.firebase.auth().onAuthStateChanged(user => {
          handleAuthStateChanged(user).catch(err => console.warn('Auth state handler failed', err));
        });
      } catch (e) {
        console.warn('Cloud backend init failed', e);
        state.cloud.enabled = false;
        state.cloud.ready = false;
        setCloudUiText('Cloud save: unavailable');
        updateCloudSettingsUi();
      }
    }

    function getParentRef() {
      if (!state.cloud.user || !window.firebase) return null;
      return window.firebase.firestore().collection('parents').doc(state.cloud.user.uid);
    }

    function getChildrenCol() {
      const parentRef = getParentRef();
      if (!parentRef) return null;
      return parentRef.collection('children');
    }

    async function ensureParentDoc(user) {
      if (!user || !window.firebase) return;
      const parentRef = window.firebase.firestore().collection('parents').doc(user.uid);
      const now = window.firebase.firestore.FieldValue.serverTimestamp();

      try {
        const snap = await parentRef.get();
        const existing = snap.exists ? (snap.data() || {}) : {};
        if (!snap.exists) {
          await parentRef.set({
            createdAt: now,
            updatedAt: now,
            email: user.email || null,
            displayName: user.displayName || null,
            photoURL: user.photoURL || null,
            lastSignInAt: now,
          });
        } else {
          await parentRef.set(
            {
              updatedAt: now,
              email: user.email || existing.email || null,
              displayName: user.displayName || existing.displayName || null,
              photoURL: user.photoURL || existing.photoURL || null,
              lastSignInAt: now,
            },
            { merge: true }
          );
        }
      } catch (e) {
        console.warn('Failed to ensure parent doc', e);
      }
    }

    async function loadChildren() {
      const col = getChildrenCol();
      if (!col) return [];

      try {
        const snapshot = await col.orderBy('createdAt', 'asc').get();
        const children = snapshot.docs
          .map(doc => ({ id: doc.id, ...doc.data() }))
          .filter(child => !child.archived);
        state.cloud.children = children;
        mergeLocalProfilesFromCloud(children);
        return children;
      } catch (e) {
        console.warn('Failed to load children', e);
        state.cloud.children = [];
        return [];
      } finally {
        renderProfilesList();
        updateWelcomeTitle();
      }
    }

    function hasMeaningfulProgressSnapshot(progress) {
      const p = normalizeProgressData(progress);
      return (
        (p.stickers || 0) > 0 ||
        (p.pagesCompleted || 0) > 0 ||
        (Array.isArray(p.completedStations) && p.completedStations.length > 0) ||
        (Array.isArray(p.masteredWords) && p.masteredWords.length > 0) ||
        (p.analytics && (p.analytics.updatedAt || 0) > 0)
      );
    }

    function readLocalProgressSnapshotForChild(childId) {
      if (!childId) return null;
      try {
        const raw = localStorage.getItem(getProgressStorageKey(childId));
        return normalizeProgressData(safeJsonParse(raw, null));
      } catch (e) {
        return normalizeProgressData(null);
      }
    }

    async function maybeImportLocalProfilesToCloud() {
      if (!state.cloud.ready || !state.cloud.user || !window.firebase) return false;

      // Load local profiles (offline progress) and compare to the cloud child IDs.
      const localProfiles = loadLocalProfiles();
      const cloudIds = new Set(
        (Array.isArray(state.cloud.children) ? state.cloud.children : [])
          .map(c => (c && c.id ? String(c.id) : ''))
          .filter(Boolean)
      );

      const candidates = (Array.isArray(localProfiles) ? localProfiles : [])
        .filter(p => p && p.id && !p.archived)
        .filter(p => !cloudIds.has(String(p.id)))
        .map(p => ({ profile: p, progress: readLocalProgressSnapshotForChild(p.id) }))
        .filter(x => hasMeaningfulProgressSnapshot(x.progress));

      if (candidates.length === 0) return false;
      if (state.cloud.localImportPrompted) return false;
      state.cloud.localImportPrompted = true;

      const nameList = candidates
        .slice(0, 3)
        .map(x => String(x.profile && x.profile.name ? x.profile.name : 'Child').trim() || 'Child')
        .join(', ');
      const extra = candidates.length > 3 ? ` and ${candidates.length - 3} more` : '';

      const ok = await showConfirmModal({
        title: 'Import local progress?',
        message: `We found saved progress on this device (${nameList}${extra}). Import it into your cloud account so it syncs across devices?`,
        confirmText: 'Import',
        cancelText: 'Not now',
        danger: false,
      });
      if (!ok) return false;

      const col = getChildrenCol();
      const parentRef = getParentRef();
      if (!col || !parentRef) return false;

      const FieldValue = window.firebase.firestore.FieldValue;
      const now = FieldValue.serverTimestamp();

      try {
        for (const item of candidates) {
          const childId = item && item.profile && item.profile.id ? String(item.profile.id) : '';
          if (!childId || childId.includes('/')) continue;

          // Merge with any existing doc (defensive; avoids clobbering if IDs overlap).
          let remoteProgress = null;
          let hadExistingDoc = false;
          try {
            const snap = await col.doc(childId).get();
            if (snap.exists) {
              hadExistingDoc = true;
              const data = snap.data() || {};
              remoteProgress = data.progress || null;
            }
          } catch (e) {
            remoteProgress = null;
          }

          const mergedProgress = remoteProgress ? mergeProgress(item.progress, remoteProgress).merged : item.progress;

          const docPayload = {
            name: String(item.profile.name || 'Child').trim() || 'Child',
            avatar: String(item.profile.avatar || 'ðŸ§’'),
            archived: false,
            updatedAt: now,
            lastPlayedAt: now,
            progress: mergedProgress,
          };
          if (!hadExistingDoc) docPayload.createdAt = now;

          await col.doc(childId).set(docPayload, { merge: true });
        }

        await parentRef.set({ migrations: { localImportAt: now } }, { merge: true });
      } catch (e) {
        console.warn('Local import failed', e);
        alert('Could not import local progress. Please try again.');
        return false;
      }

      await loadChildren();
      return true;
    }

    async function handleAuthStateChanged(user) {
      state.cloud.user = user || null;

      if (!user) {
        state.cloud.children = [];
        // Keep locally-selected profile so offline progress stays separated by user.
        let cachedChildId = null;
        try { cachedChildId = localStorage.getItem(CLOUD_ACTIVE_CHILD_KEY); } catch (e) { cachedChildId = null; }
        state.cloud.activeChildId = cachedChildId || null;
        loadLocalProfiles();
        const localChild = cachedChildId ? state.localProfiles.find(p => p.id === cachedChildId) : null;
        state.cloud.activeChild = localChild || getActiveChildSnapshot() || null;
        updateWelcomeTitle();
        updateCloudSettingsUi();
        return;
      }

      await ensureParentDoc(user);
      await loadChildren();
      await maybeImportLocalProfilesToCloud();

      // Restore preferred child if it exists; otherwise pick the first child.
      let cachedChildId = null;
      try { cachedChildId = localStorage.getItem(CLOUD_ACTIVE_CHILD_KEY); } catch (e) { cachedChildId = null; }
      const preferred = cachedChildId && state.cloud.children.find(c => c.id === cachedChildId) ? cachedChildId : null;
      const fallback = state.cloud.children.length === 1 ? state.cloud.children[0].id : null;
      const next = preferred || fallback;

      if (next) {
        await setActiveChild(next, { reason: 'auth-restore' });
      } else {
        state.cloud.activeChildId = null;
        state.cloud.activeChild = null;
        try { localStorage.removeItem(CLOUD_ACTIVE_CHILD_KEY); } catch (e) { }
        setActiveChildSnapshot(null);
        updateCloudSettingsUi();
        updateWelcomeTitle();
      }
    }

    async function signInWithGoogle() {
      if (!state.cloud.ready || !window.firebase) return;
      const provider = new window.firebase.auth.GoogleAuthProvider();
      provider.setCustomParameters({ prompt: 'select_account' });

      try {
        await window.firebase.auth().signInWithPopup(provider);
      } catch (e) {
        const code = e && e.code ? String(e.code) : '';
        const fallbackToRedirect =
          code === 'auth/popup-blocked' ||
          code === 'auth/popup-closed-by-user' ||
          code === 'auth/operation-not-supported-in-this-environment';

        if (!fallbackToRedirect) {
          console.warn('Google sign-in failed', e);
          alert('Sign-in failed. Please try again.');
          return;
        }

        try {
          await window.firebase.auth().signInWithRedirect(provider);
        } catch (err2) {
          console.warn('Google redirect sign-in failed', err2);
          alert('Sign-in failed. Please try again.');
        }
      }
    }

    async function signOutCloud() {
      if (!state.cloud.ready || !window.firebase) return;
      try {
        await window.firebase.auth().signOut();
      } catch (e) {
        console.warn('Sign-out failed', e);
      }
    }

    function normalizeDeviceCounterBucket(raw) {
      const out = {};
      if (!raw || typeof raw !== 'object') return out;
      for (const [key, value] of Object.entries(raw)) {
        const k = String(key || '').trim();
        if (!k) continue;
        const n = Number(value);
        if (!Number.isFinite(n) || n < 0) continue;
        out[k] = n;
      }
      return out;
    }

    function sumDeviceCounterBucket(bucket) {
      if (!bucket || typeof bucket !== 'object') return 0;
      let sum = 0;
      for (const v of Object.values(bucket)) {
        const n = Number(v);
        if (!Number.isFinite(n)) continue;
        sum += n;
      }
      return sum;
    }

    function mergeDeviceCounterBuckets(aRaw, bRaw) {
      const a = normalizeDeviceCounterBucket(aRaw);
      const b = normalizeDeviceCounterBucket(bRaw);
      const out = {};
      const keys = new Set([...Object.keys(a), ...Object.keys(b)]);
      keys.forEach(k => {
        out[k] = Math.max(a[k] || 0, b[k] || 0);
      });
      return out;
    }

    function normalizeStoryProgress(raw) {
      const obj = raw && typeof raw === 'object' ? raw : {};
      const stationsRaw = obj.stations && typeof obj.stations === 'object' ? obj.stations : {};
      const stations = {};

      Object.entries(stationsRaw).forEach(([stationId, value]) => {
        const v = value && typeof value === 'object' ? value : {};
        const endingsUnlocked = Array.isArray(v.endingsUnlocked) ? v.endingsUnlocked.filter(Boolean) : [];
        stations[String(stationId)] = {
          endingsUnlocked: Array.from(new Set(endingsUnlocked.map(String))),
          playCount: Number.isFinite(v.playCount) ? Math.max(0, v.playCount) : 0,
          compCorrect: Number.isFinite(v.compCorrect) ? Math.max(0, v.compCorrect) : 0,
          compTotal: Number.isFinite(v.compTotal) ? Math.max(0, v.compTotal) : 0,
        };
      });

      return {
        schemaVersion: 1,
        stations,
      };
    }

    function mergeStoryProgress(localRaw, remoteRaw) {
      const local = normalizeStoryProgress(localRaw);
      const remote = normalizeStoryProgress(remoteRaw);
      const merged = { schemaVersion: 1, stations: {} };

      const ids = new Set([
        ...Object.keys(local.stations || {}),
        ...Object.keys(remote.stations || {}),
      ]);

      ids.forEach(id => {
        const a = local.stations && local.stations[id] ? local.stations[id] : {};
        const b = remote.stations && remote.stations[id] ? remote.stations[id] : {};
        merged.stations[id] = {
          endingsUnlocked: Array.from(new Set([...(a.endingsUnlocked || []), ...(b.endingsUnlocked || [])])),
          playCount: Math.max(Number(a.playCount) || 0, Number(b.playCount) || 0),
          compCorrect: Math.max(Number(a.compCorrect) || 0, Number(b.compCorrect) || 0),
          compTotal: Math.max(Number(a.compTotal) || 0, Number(b.compTotal) || 0),
        };
      });

      return merged;
    }

	    function normalizeProgressData(data) {
	      const obj = data && typeof data === 'object' ? data : {};
	      const countersRaw = obj.counters && typeof obj.counters === 'object' ? obj.counters : {};
	      const stickersLegacy = Number.isFinite(obj.stickers) ? obj.stickers : 0;
	      const pagesLegacy = Number.isFinite(obj.pagesCompleted) ? obj.pagesCompleted : 0;
	      const completedStationsRaw = Array.isArray(obj.completedStations) ? obj.completedStations : [];

      const stickersByDevice = normalizeDeviceCounterBucket(countersRaw.stickersByDevice);
      const pagesCompletedByDevice = normalizeDeviceCounterBucket(countersRaw.pagesCompletedByDevice);

      // Back-compat: old schema stored only totals. Keep totals under a shared "legacy" bucket
      // so future per-device counters can accumulate without double-counting.
      if (Object.keys(stickersByDevice).length === 0) {
        stickersByDevice.legacy = stickersLegacy;
      } else if (!Number.isFinite(stickersByDevice.legacy)) {
        stickersByDevice.legacy = 0;
      }

      if (Object.keys(pagesCompletedByDevice).length === 0) {
        pagesCompletedByDevice.legacy = pagesLegacy;
      } else if (!Number.isFinite(pagesCompletedByDevice.legacy)) {
        pagesCompletedByDevice.legacy = 0;
      }

	      const stickersTotal = sumDeviceCounterBucket(stickersByDevice);
	      const pagesTotal = sumDeviceCounterBucket(pagesCompletedByDevice);

	      // Food-only pivot: ignore archived stations in progress so the map/progress bar stays sane.
	      const completedStations = (() => {
	        try {
	          if (!stationContent || typeof stationContent !== 'object') return completedStationsRaw;
	          const keep = completedStationsRaw
	            .map(s => String(s || ''))
	            .filter(Boolean)
	            .filter(id => {
	              const st = stationContent[id];
	              if (!st || typeof st !== 'object') return false;
	              if (st.isPractice) return false;
	              if (st.comingSoon) return false;
	              return true;
	            });
	          return Array.from(new Set(keep));
	        } catch (e) {
	          return completedStationsRaw;
	        }
	      })();

	      return {
	        counters: {
	          stickersByDevice,
	          pagesCompletedByDevice,
	        },
	        stickers: stickersTotal,
	        pagesCompleted: pagesTotal,
	        completedStations,
	        masteredWords: Array.isArray(obj.masteredWords) ? obj.masteredWords : [],
	        soundEnabled: obj.soundEnabled !== false,
        guidanceEnabled: obj.guidanceEnabled !== false,
        calmMode: Boolean(obj.calmMode),
        sightWordMarksEnabled: obj.sightWordMarksEnabled !== false,
        sightWordGateEnabled: obj.sightWordGateEnabled !== false,
        updatedAt: Number.isFinite(obj.updatedAt) ? obj.updatedAt : 0,
        resetAt: Number.isFinite(obj.resetAt) ? obj.resetAt : 0,
        lastPosition: obj.lastPosition && typeof obj.lastPosition === 'object' ? obj.lastPosition : null,
        analytics: normalizeAnalyticsData(obj.analytics),
        storyProgress: normalizeStoryProgress(obj.storyProgress),
      };
    }

    function mergeProgress(localRaw, remoteRaw) {
      const local = normalizeProgressData(localRaw);
      const remote = normalizeProgressData(remoteRaw);

      if (remote.resetAt > local.resetAt) return { merged: remote, source: 'remote' };
      if (local.resetAt > remote.resetAt) return { merged: local, source: 'local' };

      const mergedStickerCounters = mergeDeviceCounterBuckets(
        local.counters && local.counters.stickersByDevice,
        remote.counters && remote.counters.stickersByDevice
      );
      const mergedPagesCounters = mergeDeviceCounterBuckets(
        local.counters && local.counters.pagesCompletedByDevice,
        remote.counters && remote.counters.pagesCompletedByDevice
      );

      const mergedStations = Array.from(new Set([...(local.completedStations || []), ...(remote.completedStations || [])]));
      const mergedWords = Array.from(new Set([...(local.masteredWords || []), ...(remote.masteredWords || [])]));

      const merged = {
        ...local,
        counters: {
          stickersByDevice: mergedStickerCounters,
          pagesCompletedByDevice: mergedPagesCounters,
        },
        stickers: sumDeviceCounterBucket(mergedStickerCounters),
        pagesCompleted: sumDeviceCounterBucket(mergedPagesCounters),
        completedStations: mergedStations,
        masteredWords: mergedWords,
        soundEnabled: local.updatedAt >= remote.updatedAt ? local.soundEnabled : remote.soundEnabled,
        guidanceEnabled: local.updatedAt >= remote.updatedAt ? local.guidanceEnabled : remote.guidanceEnabled,
        calmMode: local.updatedAt >= remote.updatedAt ? local.calmMode : remote.calmMode,
        sightWordMarksEnabled: local.updatedAt >= remote.updatedAt ? local.sightWordMarksEnabled : remote.sightWordMarksEnabled,
        sightWordGateEnabled: local.updatedAt >= remote.updatedAt ? local.sightWordGateEnabled : remote.sightWordGateEnabled,
        updatedAt: Math.max(local.updatedAt || 0, remote.updatedAt || 0),
        resetAt: Math.max(local.resetAt || 0, remote.resetAt || 0),
        lastPosition: (local.updatedAt >= remote.updatedAt ? local.lastPosition : remote.lastPosition) || null,
        analytics: mergeAnalyticsData(local.analytics, remote.analytics),
        storyProgress: mergeStoryProgress(local.storyProgress, remote.storyProgress),
      };

      const source = local.updatedAt >= remote.updatedAt ? 'local' : 'remote';
      return { merged, source };
    }

    function applyProgressToState(progress, { persistLocal = true } = {}) {
      const p = normalizeProgressData(progress);

      state.progressCounters = p.counters || { stickersByDevice: { legacy: 0 }, pagesCompletedByDevice: { legacy: 0 } };
      state.stickers = p.stickers;
      state.pagesCompleted = p.pagesCompleted;
      state.completedStations = p.completedStations;
      state.masteredWords = new Set(p.masteredWords);
      state.soundEnabled = p.soundEnabled;
      state.guidanceEnabled = p.guidanceEnabled;
      state.calmMode = p.calmMode;
      state.sightWordMarksEnabled = p.sightWordMarksEnabled;
      state.sightWordGateEnabled = p.sightWordGateEnabled;
      state.progressUpdatedAt = p.updatedAt;
      state.progressResetAt = p.resetAt;
      state.analytics = normalizeAnalyticsData(p.analytics);
      state.storyProgress = normalizeStoryProgress(p.storyProgress);

      // Update UI without writing back updatedAt.
      updateProgress({ save: false });
      syncSettingsButtonsToState();
      generateMRTMap();

      if (persistLocal) {
        saveProgress({ skipCloud: true, forceUpdatedAt: p.updatedAt, forceResetAt: p.resetAt });
      }
    }

    async function loadCloudProgress(childId) {
      const col = getChildrenCol();
      if (!col) return null;
      try {
        const snap = await col.doc(childId).get();
        if (!snap.exists) return null;
        const data = snap.data() || {};
        state.cloud.activeChild = { id: snap.id, ...data };
        return data.progress || null;
      } catch (e) {
        console.warn('Failed to load child progress', e);
        return null;
      }
    }

    async function setActiveChild(childId, { reason = 'user' } = {}) {
      const prevChildId = state.cloud.activeChildId;
      const isSwitchingProfiles = Boolean(prevChildId && childId && childId !== prevChildId);
      const isInLessonFlow =
        state.currentScreen === 'mrtRideScreen' ||
        state.currentScreen === 'elevatorScreen' ||
        state.currentScreen === 'warmupScreen' ||
        state.currentScreen === 'restaurantScreen';

      if (isSwitchingProfiles && isInLessonFlow && state.currentStation) {
        const ok = await showConfirmModal({
          title: 'Switch profiles?',
          message: 'Switch child profiles? You will leave this story.',
          confirmText: 'Switch',
          cancelText: 'Stay here',
          danger: false,
        });
        if (!ok) return;

        stopSpeech();
        cancelMapTrainMotion();
        clearSightWordGate();

        if (state.stationTransitionTimeoutId) {
          clearTimeout(state.stationTransitionTimeoutId);
          state.stationTransitionTimeoutId = null;
        }

	      state.currentStation = null;
	      state.currentOrder = null;
	      state.currentPage = 0;
	      state.currentFloor = 1;
	      state.sessionPages = null;
	      state.storySession = null;
	      state.lessonElevatorPlan = null;
	      state.lessonElevatorSegmentByPage = null;
	      state.lessonElevatorVisitedSegments = null;
	      state.lessonElevatorActiveSegment = 0;
	      state.practiceSkillId = null;
	      state.practiceCorrect = 0;
	      state.practiceFirstTryCorrect = 0;
	      state.practiceTotal = 0;

        generateMRTMap();
        goToScreen('mrtScreen');
      }

      const child =
        state.cloud.children.find(c => c.id === childId) ||
        state.localProfiles.find(p => p.id === childId) ||
        null;
      state.cloud.activeChildId = childId || null;
      state.cloud.activeChild = child;

      if (childId) {
        try { localStorage.setItem(CLOUD_ACTIVE_CHILD_KEY, childId); } catch (e) { }
        setActiveChildSnapshot(child ? { id: child.id, name: child.name || null, avatar: child.avatar || null } : null);
      } else {
        try { localStorage.removeItem(CLOUD_ACTIVE_CHILD_KEY); } catch (e) { }
        setActiveChildSnapshot(null);
      }

      // Load local progress for this child immediately (offline-friendly), then merge with cloud.
      loadProgress({ storageKey: getProgressStorageKey(childId) });
      generateMRTMap();

      updateWelcomeTitle();
      updateCloudSettingsUi();

      if (!state.cloud.user || !state.cloud.ready || !childId) return;

      state.cloud.syncing = true;
      updateCloudSettingsUi();

      const remoteProgress = await loadCloudProgress(childId);
      let localProgressRaw = null;
      try { localProgressRaw = localStorage.getItem(getProgressStorageKey(childId)); } catch (e) { localProgressRaw = null; }
      const localProgress = safeJsonParse(localProgressRaw, null);
      const localNorm = normalizeProgressData(localProgress);
      const remoteNorm = normalizeProgressData(remoteProgress);
      const { merged, source } = mergeProgress(localNorm, remoteNorm);

      // Apply merged progress locally and push the merged state back to cloud when local is newer or cloud missing.
      applyProgressToState(merged, { persistLocal: true });
      const childIndex = state.cloud.children.findIndex(c => c.id === childId);
      if (childIndex >= 0) {
        state.cloud.children[childIndex].progress = merged;
      }
      if (state.cloud.activeChild) {
        state.cloud.activeChild.progress = merged;
      }

      const shouldPushToCloud = source === 'local' || !remoteProgress || (merged.updatedAt > remoteNorm.updatedAt);
      if (shouldPushToCloud) {
        await syncProgressToCloud({ reason: `merge:${reason}`, force: true });
      }

      await logCloudEvent('session_start', { reason });

      state.cloud.syncing = false;
      state.cloud.lastSyncAt = Date.now();
      updateCloudSettingsUi();
    }

    async function syncProgressToCloud({ reason = 'progress', force = false } = {}) {
      if (!state.cloud.ready || !state.cloud.user || !state.cloud.activeChildId || !window.firebase) return;
      if (state.cloud.syncing && !force) return;

      const col = getChildrenCol();
      if (!col) return;
      const childId = state.cloud.activeChildId;
      const now = getSyncNowMs();
      recalcProgressCountersTotals();
      const counters = ensureProgressCountersState();

      const progress = normalizeProgressData({
        counters,
        stickers: state.stickers,
        pagesCompleted: state.pagesCompleted,
        completedStations: state.completedStations,
        masteredWords: Array.from(state.masteredWords),
        soundEnabled: state.soundEnabled,
        guidanceEnabled: state.guidanceEnabled,
        calmMode: state.calmMode,
        sightWordMarksEnabled: state.sightWordMarksEnabled,
        sightWordGateEnabled: state.sightWordGateEnabled,
        updatedAt: now,
        resetAt: state.progressResetAt || 0,
        lastPosition: {
          stationId: state.currentStation || null,
          pageIndex: Number.isFinite(state.currentPage) ? state.currentPage : 0,
        },
        analytics: normalizeAnalyticsData(state.analytics),
      });

      state.cloud.syncing = true;
      updateCloudSettingsUi();

      try {
        await col.doc(childId).set(
          {
            updatedAt: window.firebase.firestore.FieldValue.serverTimestamp(),
            lastPlayedAt: window.firebase.firestore.FieldValue.serverTimestamp(),
            progress,
          },
          { merge: true }
        );
        state.cloud.lastSyncAt = Date.now();
      } catch (e) {
        console.warn('Cloud sync failed', e);
      } finally {
        state.cloud.syncing = false;
        updateCloudSettingsUi();
      }
    }

    function scheduleCloudSave(reason = 'progress') {
      if (!state.cloud.ready || !state.cloud.user || !state.cloud.activeChildId) return;
      if (state.cloud.suppressNextCloudSave) {
        state.cloud.suppressNextCloudSave = false;
        return;
      }

      if (state.cloud.saveDebounceId) {
        clearTimeout(state.cloud.saveDebounceId);
      }

      state.cloud.saveDebounceId = setTimeout(() => {
        state.cloud.saveDebounceId = null;
        syncProgressToCloud({ reason }).catch(err => console.warn('Cloud sync failed', err));
      }, 1200);
    }

    async function logCloudEvent(type, payload = {}) {
      if (!state.cloud.ready || !state.cloud.user || !state.cloud.activeChildId || !window.firebase) return;
      const col = getChildrenCol();
      if (!col) return;

      // Keep cloud writes low-cost by only persisting a small set of high-signal events.
      // (Detailed per-tap logs are kept locally in `state.analytics` and synced via `progress`.)
      if (!CLOUD_PERSISTABLE_EVENT_TYPES.has(type)) return;

      // For question events, only count/log the first attempt (matches `recordQuestionAnalytics`).
      if (type === 'question_answered') {
        const attempt = payload && Number.isFinite(payload.attempt) ? payload.attempt : null;
        if (attempt !== 1) return;
      }

      const childId = state.cloud.activeChildId;
      const sessionId = state.cloud.sessionId || (state.cloud.sessionId = makeId('sess'));

      try {
        const expiresAt = (() => {
          try {
            const ms = getSyncNowMs() + CLOUD_EVENT_TTL_MS;
            return window.firebase.firestore.Timestamp.fromMillis(ms);
          } catch (e) {
            return null;
          }
        })();

        await col.doc(childId).collection('events').add({
          type,
          payload,
          stationId: state.currentStation || null,
          pageIndex: Number.isFinite(state.currentPage) ? state.currentPage : null,
          sessionId,
          createdAt: window.firebase.firestore.FieldValue.serverTimestamp(),
          ...(expiresAt ? { expiresAt } : {}),
        });

        // Keep a few summary counters on the child doc for fast dashboards (optional).
        const FieldValue = window.firebase.firestore.FieldValue;
        const statsUpdate = {};

        if (type === 'session_start') {
          statsUpdate['stats.sessions'] = FieldValue.increment(1);
        } else if (type === 'question_answered') {
          statsUpdate['stats.questionsTotal'] = FieldValue.increment(1);
          if (payload && payload.correct) statsUpdate['stats.questionsCorrect'] = FieldValue.increment(1);
        } else if (type === 'station_completed') {
          statsUpdate['stats.stationsCompleted'] = FieldValue.increment(1);
        } else if (type === 'progress_reset') {
          statsUpdate['stats.resets'] = FieldValue.increment(1);
        }

        if (Object.keys(statsUpdate).length > 0) {
          await col.doc(childId).set(
            {
              ...statsUpdate,
              updatedAt: FieldValue.serverTimestamp(),
            },
            { merge: true }
          );
        }
      } catch (e) {
        // Event logging should never break the lesson.
        console.warn('Failed to log event', type, e);
      }
    }

    function renderAvatarPicker() {
      const picker = document.getElementById('avatarPicker');
      if (!picker) return;
      picker.innerHTML = '';

      AVATAR_OPTIONS.forEach(emoji => {
        const btn = document.createElement('div');
        btn.className = 'avatar-option' + (emoji === profilesSelectedAvatar ? ' selected' : '');
        btn.textContent = emoji;
        btn.onclick = () => {
          profilesSelectedAvatar = emoji;
          renderAvatarPicker();
        };
        picker.appendChild(btn);
      });
    }

    function setProfilesError(message) {
      const el = document.getElementById('profilesErrorText');
      if (!el) return;
      if (!message) {
        el.style.display = 'none';
        el.textContent = '';
        return;
      }
      el.textContent = message;
      el.style.display = 'block';
    }

    function setProfilesEditMode(child) {
      const title = document.getElementById('childFormTitle');
      const nameInput = document.getElementById('childNameInput');
      const cancelBtn = document.getElementById('cancelEditChildBtn');
      const deleteBtn = document.getElementById('deleteChildBtn');
      const saveBtn = document.getElementById('saveChildBtn');

      if (!nameInput || !saveBtn) return;

      if (child) {
        profilesEditingChildId = child.id;
        profilesSelectedAvatar = child.avatar || profilesSelectedAvatar;
        if (title) title.textContent = 'Edit child';
        nameInput.value = child.name || '';
        if (cancelBtn) cancelBtn.style.display = 'inline-flex';
        if (deleteBtn) deleteBtn.style.display = 'inline-flex';
        saveBtn.textContent = 'Save changes';
      } else {
        profilesEditingChildId = null;
        profilesSelectedAvatar = AVATAR_OPTIONS[0];
        if (title) title.textContent = 'Add a child';
        nameInput.value = '';
        if (cancelBtn) cancelBtn.style.display = 'none';
        if (deleteBtn) deleteBtn.style.display = 'none';
        saveBtn.textContent = 'Save';
      }

      renderAvatarPicker();
      setProfilesError(null);
    }

    function renderProfilesList() {
      const list = document.getElementById('profilesList');
      const emptyText = document.getElementById('profilesEmptyText');
      if (!list) return;

      list.innerHTML = '';
      const source = getProfilesSource();
      const children = getProfilesForUi();

      if (emptyText) emptyText.style.display = children.length === 0 ? 'block' : 'none';

      children.forEach(child => {
        const card = document.createElement('div');
        card.className = 'profile-card profile-select-row';
        card.tabIndex = 0;
        card.setAttribute('role', 'button');

        const left = document.createElement('div');
        left.className = 'profile-left';

        const avatar = document.createElement('div');
        avatar.className = 'avatar-chip';
        avatar.textContent = child.avatar || 'ðŸ§’';

        const text = document.createElement('div');
        text.className = 'profile-text';

        const name = document.createElement('div');
        name.className = 'profile-name';
        name.textContent = child.name || 'Child';

        const meta = document.createElement('div');
        meta.className = 'profile-meta';
        let stationsDone = 0;
        let wordsDone = 0;
        if (source === 'cloud') {
          stationsDone = child.progress && Array.isArray(child.progress.completedStations) ? child.progress.completedStations.length : 0;
          wordsDone = child.progress && Array.isArray(child.progress.masteredWords) ? child.progress.masteredWords.length : 0;
        } else {
          try {
            const raw = localStorage.getItem(getProgressStorageKey(child.id));
            const p = normalizeProgressData(safeJsonParse(raw, null));
            stationsDone = Array.isArray(p.completedStations) ? p.completedStations.length : 0;
            wordsDone = Array.isArray(p.masteredWords) ? p.masteredWords.length : 0;
          } catch (e) {
            stationsDone = 0;
            wordsDone = 0;
          }
        }
        meta.textContent = `${stationsDone} stations â€¢ ${wordsDone} words`;

        text.appendChild(name);
        text.appendChild(meta);

        left.appendChild(avatar);
        left.appendChild(text);

        const right = document.createElement('div');
        right.style.display = 'flex';
        right.style.gap = '8px';
        right.style.alignItems = 'center';
        right.style.flexWrap = 'wrap';
        right.style.justifyContent = 'flex-end';

        const editBtn = document.createElement('button');
        editBtn.className = 'modal-action-btn secondary';
        editBtn.type = 'button';
        editBtn.textContent = 'Edit';
        editBtn.onclick = (e) => {
          if (e && typeof e.stopPropagation === 'function') e.stopPropagation();
          setProfilesEditMode(child);
        };

        const isActive = child.id === state.cloud.activeChildId;
        if (isActive) {
          card.classList.add('is-active');
          card.setAttribute('aria-current', 'true');
          const status = document.createElement('div');
          status.className = 'profile-select-status';
          status.textContent = 'Using';
          right.appendChild(status);
        }

        right.appendChild(editBtn);

        card.appendChild(left);
        card.appendChild(right);

        const selectThisChild = async () => {
          if (child.id === state.cloud.activeChildId) return;
          await setActiveChild(child.id, { reason: 'choose' });
          closeProfiles();
        };

        card.onclick = (e) => {
          if (e && e.target && typeof e.target.closest === 'function') {
            if (e.target.closest('button')) return;
          }
          selectThisChild();
        };

        card.onkeydown = (e) => {
          if (!e) return;
          if (e.target && e.target.tagName === 'BUTTON') return;
          if (e.key === 'Enter' || e.key === ' ') {
            e.preventDefault();
            selectThisChild();
          }
        };

        list.appendChild(card);
      });
    }

    function renderProfilesModal() {
      renderProfilesList();
      setProfilesEditMode(null);
    }

    async function upsertChildProfile() {
      const nameInput = document.getElementById('childNameInput');
      const name = (nameInput && nameInput.value ? nameInput.value : '').trim();
      if (!name) {
        setProfilesError('Please enter a child name.');
        return;
      }

      const avatar = profilesSelectedAvatar || 'ðŸ§’';
      const isCloudMode = Boolean(state.cloud.ready && state.cloud.user && window.firebase);

      if (isCloudMode) {
        const col = getChildrenCol();
        if (!col) return;
        const now = window.firebase.firestore.FieldValue.serverTimestamp();

        try {
          let createdChildId = null;
          if (profilesEditingChildId) {
            await col.doc(profilesEditingChildId).set(
              { name, avatar, updatedAt: now },
              { merge: true }
            );
          } else {
            const ref = await col.add({
              name,
              avatar,
              createdAt: now,
              updatedAt: now,
              archived: false,
              progress: {
                stickers: 0,
                pagesCompleted: 0,
                completedStations: [],
                masteredWords: [],
                soundEnabled: true,
                guidanceEnabled: true,
                calmMode: false,
                sightWordMarksEnabled: true,
                sightWordGateEnabled: true,
                updatedAt: 0,
                resetAt: 0,
                lastPosition: null,
                analytics: normalizeAnalyticsData(null),
              },
            });
            createdChildId = ref && ref.id ? ref.id : null;
          }

          setProfilesError(null);
          await loadChildren();
          if (createdChildId) {
            await setActiveChild(createdChildId, { reason: 'cloud-create' });
          } else if (state.cloud.activeChildId) {
            state.cloud.activeChild = state.cloud.children.find(c => c.id === state.cloud.activeChildId) || state.cloud.activeChild;
            if (state.cloud.activeChild) {
              setActiveChildSnapshot({
                id: state.cloud.activeChild.id,
                name: state.cloud.activeChild.name || null,
                avatar: state.cloud.activeChild.avatar || null,
              });
            }
            updateWelcomeTitle();
          }
          setProfilesEditMode(null);
        } catch (e) {
          console.warn('Failed to save child', e);
          setProfilesError('Could not save. Please try again.');
        }
        return;
      }

      const raw = readLocalProfilesRaw();
      const now = Date.now();

      let newId = null;
      const nextRaw = Array.isArray(raw) ? [...raw] : [];

      if (profilesEditingChildId) {
        const idx = nextRaw.findIndex(item => item && typeof item === 'object' && item.id === profilesEditingChildId);
        if (idx >= 0) {
          nextRaw[idx] = { ...nextRaw[idx], name, avatar, archived: false, updatedAt: now };
        } else {
          newId = makeId('child');
          nextRaw.push({ id: newId, name, avatar, archived: false, createdAt: now, updatedAt: now });
        }
      } else {
        newId = makeId('child');
        nextRaw.push({ id: newId, name, avatar, archived: false, createdAt: now, updatedAt: now });
      }

      writeLocalProfilesRaw(nextRaw);
      loadLocalProfiles();

      // Ensure a clean progress record for new profiles.
      if (newId) {
        try { localStorage.setItem(getProgressStorageKey(newId), JSON.stringify(normalizeProgressData(null))); } catch (e) { }
      }

      const updatedId = profilesEditingChildId || newId;
      const updated = updatedId ? state.localProfiles.find(p => p.id === updatedId) : null;
      if (updatedId && updated && state.cloud.activeChildId === updatedId) {
        state.cloud.activeChild = updated;
        setActiveChildSnapshot({ id: updated.id, name: updated.name || null, avatar: updated.avatar || null });
      }

      if (newId) await setActiveChild(newId, { reason: 'local-create' });
      else updateWelcomeTitle();

      setProfilesError(null);
      renderProfilesModal();
    }

    async function archiveEditingChild() {
      if (!profilesEditingChildId) return;
      const isCloudMode = Boolean(state.cloud.ready && state.cloud.user && window.firebase);

      if (isCloudMode) {
        const col = getChildrenCol();
        if (!col) return;

        const child = state.cloud.children.find(c => c.id === profilesEditingChildId);
        const childName = child && child.name ? child.name : 'this child';
        const ok = await showConfirmModal({
          title: `Archive ${childName}?`,
          message: 'You can add them again later.',
          confirmText: 'Archive',
          cancelText: 'Cancel',
          danger: true,
        });
        if (!ok) return;

        try {
          await col.doc(profilesEditingChildId).set(
            {
              archived: true,
              archivedAt: window.firebase.firestore.FieldValue.serverTimestamp(),
            },
            { merge: true }
          );

          if (state.cloud.activeChildId === profilesEditingChildId) {
            state.cloud.activeChildId = null;
            state.cloud.activeChild = null;
            try { localStorage.removeItem(CLOUD_ACTIVE_CHILD_KEY); } catch (e) { }
            setActiveChildSnapshot(null);
            updateWelcomeTitle();
          }

          setProfilesError(null);
          await loadChildren();
          setProfilesEditMode(null);
          updateCloudSettingsUi();
        } catch (e) {
          console.warn('Failed to archive child', e);
          setProfilesError('Could not archive. Please try again.');
        }
        return;
      }

      const raw = readLocalProfilesRaw();
      const profile = raw.find(item => item && typeof item === 'object' && item.id === profilesEditingChildId);
      const childName = profile && profile.name ? String(profile.name) : 'this child';
      const ok = await showConfirmModal({
        title: `Archive ${childName}?`,
        message: 'You can add them again later.',
        confirmText: 'Archive',
        cancelText: 'Cancel',
        danger: true,
      });
      if (!ok) return;

      const now = Date.now();
      const nextRaw = raw.map(item => {
        if (!item || typeof item !== 'object') return item;
        if (item.id !== profilesEditingChildId) return item;
        return { ...item, archived: true, updatedAt: now };
      });

      writeLocalProfilesRaw(nextRaw);
      loadLocalProfiles();

      if (state.cloud.activeChildId === profilesEditingChildId) {
        const nextId = state.localProfiles.length > 0 ? state.localProfiles[0].id : null;
        await setActiveChild(nextId, { reason: 'local-archive' });
      } else {
        updateWelcomeTitle();
      }

      setProfilesError(null);
      renderProfilesModal();
      updateCloudSettingsUi();
    }

    function renderDashboardModal() {
      const userText = document.getElementById('dashboardUserText');
      if (userText) {
        const u = state.cloud.user;
        userText.textContent = u ? (u.email || u.displayName || 'Signed in') : 'Not signed in';
      }

      const list = document.getElementById('dashboardChildrenList');
      const detailGroup = document.getElementById('dashboardDetailGroup');
      const detail = document.getElementById('dashboardDetail');

      if (detailGroup) detailGroup.style.display = 'none';
      if (detail) detail.innerHTML = '';
      if (!list) return;

      list.innerHTML = '';
      const children = Array.isArray(state.cloud.children) ? state.cloud.children : [];

      if (children.length === 0) {
        const msg = document.createElement('div');
        msg.className = 'profile-meta';
        msg.textContent = 'No child profiles yet.';
        list.appendChild(msg);
        return;
      }

      children.forEach(child => {
        const card = document.createElement('div');
        card.className = 'profile-card';

        const left = document.createElement('div');
        left.className = 'profile-left';

        const avatar = document.createElement('div');
        avatar.className = 'avatar-chip';
        avatar.textContent = child.avatar || 'ðŸ§’';

        const text = document.createElement('div');
        text.className = 'profile-text';

        const name = document.createElement('div');
        name.className = 'profile-name';
        name.textContent = child.name || 'Child';

        const meta = document.createElement('div');
        meta.className = 'profile-meta';
        const p = child.progress || {};
        const stationsDone = Array.isArray(p.completedStations) ? p.completedStations.length : 0;
        const wordsDone = Array.isArray(p.masteredWords) ? p.masteredWords.length : 0;
        meta.textContent = `${stationsDone} stations â€¢ ${wordsDone} words â€¢ ${Number.isFinite(p.stickers) ? p.stickers : 0} stickers`;

        text.appendChild(name);
        text.appendChild(meta);
        left.appendChild(avatar);
        left.appendChild(text);

        const right = document.createElement('div');
        right.style.display = 'flex';
        right.style.gap = '8px';
        right.style.alignItems = 'center';
        right.style.flexWrap = 'wrap';
        right.style.justifyContent = 'flex-end';

        const viewBtn = document.createElement('button');
        viewBtn.className = 'modal-action-btn secondary';
        viewBtn.type = 'button';
        viewBtn.textContent = 'View';
        viewBtn.onclick = () => showDashboardChildDetail(child);

        const useBtn = document.createElement('button');
        useBtn.className = 'modal-action-btn';
        useBtn.type = 'button';
        useBtn.textContent = child.id === state.cloud.activeChildId ? 'Using' : 'Use';
        useBtn.disabled = child.id === state.cloud.activeChildId;
        useBtn.onclick = async () => {
          await setActiveChild(child.id, { reason: 'dashboard' });
          renderDashboardModal();
          closeDashboard();
        };

        right.appendChild(viewBtn);
        right.appendChild(useBtn);

        card.appendChild(left);
        card.appendChild(right);

        list.appendChild(card);
      });
    }

    function showDashboardChildDetail(child) {
      const detailGroup = document.getElementById('dashboardDetailGroup');
      const detail = document.getElementById('dashboardDetail');
      if (!detailGroup || !detail) return;

      detail.innerHTML = '';
      const p = child.progress || {};
      const stationsDone = Array.isArray(p.completedStations) ? p.completedStations.length : 0;
      const wordsDone = Array.isArray(p.masteredWords) ? p.masteredWords.length : 0;
      const stickers = Number.isFinite(p.stickers) ? p.stickers : 0;
      const pages = Number.isFinite(p.pagesCompleted) ? p.pagesCompleted : 0;

      const row = (label, value) => {
        const wrap = document.createElement('div');
        wrap.className = 'setting-toggle';
        wrap.style.padding = '12px';
        const l = document.createElement('span');
        l.textContent = label;
        const v = document.createElement('span');
        v.style.fontWeight = '900';
        v.style.color = 'var(--text-primary)';
        v.textContent = value;
        wrap.appendChild(l);
        wrap.appendChild(v);
        return wrap;
      };

      const header = document.createElement('div');
      header.className = 'profile-card';
      header.style.justifyContent = 'flex-start';
      const chip = document.createElement('div');
      chip.className = 'avatar-chip';
      chip.textContent = child.avatar || 'ðŸ§’';
      const name = document.createElement('div');
      name.className = 'profile-name';
      name.textContent = child.name || 'Child';
      header.appendChild(chip);
      header.appendChild(name);

      detail.appendChild(header);
      detail.appendChild(row('Stations completed', `${stationsDone}`));
      detail.appendChild(row('Words tapped', `${wordsDone}`));
      detail.appendChild(row('Stickers earned', `${stickers}`));
      detail.appendChild(row('Pages completed', `${pages}`));

      const stats = child.stats || {};
      const sessions = Number.isFinite(stats.sessions) ? stats.sessions : 0;
      const qTotal = Number.isFinite(stats.questionsTotal) ? stats.questionsTotal : 0;
      const qCorrect = Number.isFinite(stats.questionsCorrect) ? stats.questionsCorrect : 0;
      const resets = Number.isFinite(stats.resets) ? stats.resets : 0;

      if (sessions > 0) detail.appendChild(row('Sessions', `${sessions}`));
      if (qTotal > 0) {
        const pct = Math.round((qCorrect / Math.max(1, qTotal)) * 100);
        detail.appendChild(row('Question accuracy', `${qCorrect}/${qTotal} (${pct}%)`));
      }
      if (resets > 0) detail.appendChild(row('Progress resets', `${resets}`));

      // Per-skill / strategy weaknesses (from already-synced analytics in progress).
      const analytics = normalizeAnalyticsData(p.analytics);
      const scoreWeak = (bucket, minTotal = 4, maxItems = 3) =>
        Object.entries(bucket || {})
          .map(([id, stat]) => {
            const total = stat && Number.isFinite(stat.totalQuestions) ? stat.totalQuestions : 0;
            const first = stat && Number.isFinite(stat.firstTryCorrect) ? stat.firstTryCorrect : 0;
            const lastAt = stat && Number.isFinite(stat.lastAt) ? stat.lastAt : 0;
            const acc = total ? (first / total) : 1;
            return { id, total, first, acc, lastAt };
          })
          .filter(x => x.total >= minTotal)
          .sort((a, b) => (a.acc - b.acc) || (b.total - a.total) || (b.lastAt - a.lastAt))
          .slice(0, maxItems);

      const weakStrategies = scoreWeak(analytics.strategies, 4, 3);
      const weakSkills = scoreWeak(analytics.skills, 4, 3);

      const labelForId = (id) => {
        const skill = getSkillById(id);
        if (skill && skill.name) return skill.name;
        return String(id || '').replace(/-/g, ' ').replace(/\b\w/g, c => c.toUpperCase()) || 'Skill';
      };

      const addHeading = (text) => {
        const h = document.createElement('div');
        h.style.marginTop = '14px';
        h.style.fontFamily = 'var(--font-display)';
        h.style.fontWeight = '900';
        h.style.color = 'var(--text-primary)';
        h.textContent = text;
        detail.appendChild(h);
      };

      if (weakStrategies.length || weakSkills.length) {
        addHeading('Needs practice');
        weakStrategies.forEach(item => {
          const pct = Math.round(item.acc * 100);
          detail.appendChild(row(`Strategy: ${labelForId(item.id)}`, `${item.first}/${item.total} (${pct}%)`));
        });
        weakSkills.forEach(item => {
          const pct = Math.round(item.acc * 100);
          detail.appendChild(row(`Skill: ${labelForId(item.id)}`, `${item.first}/${item.total} (${pct}%)`));
        });
      }

      if (detailGroup) detailGroup.style.display = 'block';
    }

    function bindCloudUiHandlers() {
      const signInBtn = document.getElementById('googleSignInBtn');
      if (signInBtn) signInBtn.onclick = () => signInWithGoogle();

      const signOutBtn = document.getElementById('signOutBtn');
      if (signOutBtn) signOutBtn.onclick = () => signOutCloud();

      const manageBtn = document.getElementById('manageProfilesBtn');
      if (manageBtn) manageBtn.onclick = () => openProfiles();

      const cloudSyncBtn = document.getElementById('cloudSyncNowBtn');
      if (cloudSyncBtn) cloudSyncBtn.onclick = () => syncProgressToCloud({ reason: 'manual', force: true });

      const dashboardBtn = document.getElementById('openDashboardBtn');
      if (dashboardBtn) dashboardBtn.onclick = () => openDashboard();

      const saveChildBtn = document.getElementById('saveChildBtn');
      if (saveChildBtn) saveChildBtn.onclick = () => upsertChildProfile();

      const cancelEditBtn = document.getElementById('cancelEditChildBtn');
      if (cancelEditBtn) cancelEditBtn.onclick = () => setProfilesEditMode(null);

      const deleteBtn = document.getElementById('deleteChildBtn');
      if (deleteBtn) deleteBtn.onclick = () => archiveEditingChild();

      // Close modals on overlay click
      const profilesModal = document.getElementById('profilesModal');
      if (profilesModal) {
        profilesModal.onclick = e => {
          if (e.target && e.target.id === 'profilesModal') closeProfiles();
        };
      }

      const dashboardModal = document.getElementById('dashboardModal');
      if (dashboardModal) {
        dashboardModal.onclick = e => {
          if (e.target && e.target.id === 'dashboardModal') closeDashboard();
        };
      }
    }

    function pickRandom(array) {
      if (!Array.isArray(array) || array.length === 0) return null;
      return array[Math.floor(Math.random() * array.length)];
    }

    function escapeRegExp(text) {
      return String(text || '').replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    }

    function blankFirstWordOccurrence(sentence, word) {
      const text = String(sentence || '');
      const target = String(word || '').trim();
      if (!text || !target) return null;

      const escaped = escapeRegExp(target);
      const re = new RegExp(`(^|[^A-Za-z'])(${escaped})(?=[^A-Za-z']|$)`, 'i');
      if (!re.test(text)) return null;
      return text.replace(re, (_, lead) => `${lead}____`);
    }

    function buildSightWordCheckPage({ station, sourceSentence, focusWord }) {
      const blanked = blankFirstWordOccurrence(sourceSentence, focusWord);
      if (!blanked) return null;

      const stationSightWords = Array.isArray(station?.sightWords) ? station.sightWords : [];
      const bankSightWords = Array.isArray(skillWordBanks?.sightWords) ? skillWordBanks.sightWords : [];
      const normalizedFocus = String(focusWord || '').toLowerCase();
      const pool = [...stationSightWords, ...bankSightWords]
        .filter(w => w && String(w).toLowerCase() !== normalizedFocus);
      const distractors = pickDistinct(pool, 2);
      const answers = shuffleInPlace([focusWord, ...distractors].filter(Boolean));

      const stems = [
        { q: 'Which sight word completes the sentence?', h: 'Read the sentence again. Sight words are words you memorize.' },
        { q: 'Fill in the blank with the sight word.', h: 'Look at the blank. Which word makes the sentence sound right?' },
        { q: 'Which word fits in the blank?', h: 'Try reading the sentence out loud with each word.' }
      ];
      const stem = pickOne(stems);
      return makeMCQ({
        questionType: 'sightWord',
        passage: blanked,
        question: stem.q,
        hint: stem.h,
        answers,
        correctAnswerName: focusWord,
        successMessage: 'Nice! You used the sight word in a sentence.'
      });
    }

    function buildSightWordPracticePassage(word, bank) {
      const w = String(word || '').trim();
      if (!w) return '';

      const lower = w.toLowerCase();
      const noun = pickOne(bank?.nouns || ['dog', 'cat', 'book']);
      const noun2 = pickOne((bank?.nouns || ['dog', 'cat', 'book']).filter(n => n !== noun)) || noun;
      const place = pickOne(bank?.nounTypes?.place || ['school', 'park', 'home']);
      const person = pickOne(bank?.nounTypes?.person || ['Mom', 'Dad', 'Teacher']);
      const verb = pickOne(bank?.verbs || ['run', 'read', 'play']);
      const verb2 = pickOne((bank?.verbs || ['run', 'read', 'play']).filter(v => v !== verb)) || verb;
      const adj = pickOne(bank?.adjectives || ['big', 'small', 'happy']);

      const templates = {
        the: [
          () => `The ${noun} is ${adj}.`,
          () => `The ${noun2} can ${verb}.`
        ],
        and: [
          () => `I see a ${noun} and a ${noun2}.`,
          () => `We ${verb} and ${verb2}.`
        ],
        to: [
          () => `We go to the ${place}.`,
          () => `I like to ${verb}.`
        ],
        a: [
          () => `I see a ${noun}.`,
          () => `I want a ${noun2}.`
        ],
        i: [
          () => `I ${verb}.`,
          () => `I have a ${noun}.`
        ],
        see: [
          () => `I see the ${noun}.`,
          () => `Can you see the ${noun2}?`
        ],
        want: [
          () => `I want a ${noun}.`,
          () => `We want to ${verb}.`
        ],
        can: [
          () => `I can ${verb}.`,
          () => `The ${noun} can ${verb2}.`
        ],
        my: [
          () => `This is my ${noun}.`,
          () => `My ${noun2} is ${adj}.`
        ],
        is: [
          () => `The ${noun} is ${adj}.`,
          () => `This is a ${noun2}.`
        ],
        you: [
          () => `You can ${verb}.`,
          () => `Do you see the ${noun}?`
        ],
        we: [
          () => `We ${verb}.`,
          () => `We go to the ${place}.`
        ],
        like: [
          () => `I like ${noun}.`,
          () => `We like to ${verb}.`
        ],
        have: [
          () => `I have a ${noun}.`,
          () => `They have a ${noun2}.`
        ],
        this: [
          () => `This is my ${noun}.`,
          () => `This ${noun2} is ${adj}.`
        ],
        there: [
          () => `There is a ${noun}.`,
          () => `There is a ${noun2} here.`
        ],
        they: [
          () => `They ${verb}.`,
          () => `They have a ${noun}.`
        ],
        with: [
          () => `I go with ${person}.`,
          () => `I play with my ${noun}.`
        ],
        said: [
          () => `${person} said stop.`,
          () => `Ben said come here.`
        ],
        come: [
          () => `Come here.`,
          () => `Come with me.`
        ],
        here: [
          () => `Come here.`,
          () => `I am here.`
        ],
        it: [
          () => `It is ${adj}.`,
          () => `It can ${verb}.`
        ]
      };

      const fns = templates[lower] || [
        () => `Sight word is ${w}.`,
        () => `I see the word ${w}.`
      ];
      const sentences = [fns[0](), fns[1]()].filter(Boolean);
      return sentences.join(' ');
    }

    const MIN_QUESTIONS_PER_READING_PASSAGE = 2;

    function normalizeTextForMatch(text) {
      return normalizePassageText(text)
        .toLowerCase()
        .replace(/[^a-z0-9\s]/g, ' ')
        .replace(/\s+/g, ' ')
        .trim();
    }

    function getReadPageText(page) {
      if (!page) return '';
      if (typeof page.sentence === 'string' && page.sentence.trim()) return page.sentence;
      if (Array.isArray(page.words) && page.words.length) return page.words.join(' ');
      return '';
    }

    function splitIntoSentences(text) {
      const normalized = normalizePassageText(text);
      if (!normalized) return [];
      return normalized.split(/(?<=[.!?])\s+/).map(s => s.trim()).filter(Boolean);
    }

    function getKeySentencesForReadPage(page, maxCount = 3) {
      const raw = getReadPageText(page);
      const sentences = splitIntoSentences(raw);
      if (sentences.length === 0) return raw ? [normalizePassageText(raw)] : [];
      return sentences.filter(Boolean).slice(0, maxCount);
    }

    function getGlobalExtraQuestionWordPool() {
      if (getGlobalExtraQuestionWordPool.cached) return getGlobalExtraQuestionWordPool.cached;

      const words = [];
      const seen = new Set();
      const add = w => {
        const normalized = String(w || '').trim();
        const key = normalized.toLowerCase();
        if (!normalized || seen.has(key)) return;
        seen.add(key);
        words.push(normalized);
      };

      try {
        Object.values(stationContent || {}).forEach(station => {
          if (!station || typeof station !== 'object') return;
          (station.previewWords || []).forEach(item => add(item && item.word ? item.word : null));
          (station.sightWords || []).forEach(item => add(item));
        });
      } catch (e) { }

      if (words.length === 0) {
        ['pizza', 'burger', 'sushi', 'noodle', 'fruit', 'drink', 'bread', 'cheese', 'chicken'].forEach(add);
      }

      getGlobalExtraQuestionWordPool.cached = words;
      return words;
    }

    function getGlobalExtraQuestionSentencePool() {
      if (getGlobalExtraQuestionSentencePool.cached) return getGlobalExtraQuestionSentencePool.cached;

      const pool = [];
      const seen = new Set();
      const add = (text, stationId) => {
        const normalized = normalizePassageText(text);
        const key = normalizeTextForMatch(normalized);
        if (!normalized || !key || seen.has(key)) return;
        seen.add(key);
        pool.push({ text: normalized, stationId });
      };

      try {
        Object.entries(stationContent || {}).forEach(([id, station]) => {
          if (!station || typeof station !== 'object' || !Array.isArray(station.pages)) return;
          station.pages.forEach(page => {
            if (!page || page.type !== 'read') return;
            const first = splitIntoSentences(getReadPageText(page))[0];
            if (first && first.length <= 90) add(first, id);
          });
        });
      } catch (e) { }

      getGlobalExtraQuestionSentencePool.cached = pool;
      return pool;
    }

    function pickContentWordFromSentence(sentence, station, exclude = new Set()) {
      const rawTokens = String(sentence || '').match(/[A-Za-z']+/g) || [];
      const stop = new Set([
        'i', 'a', 'an', 'the', 'and', 'or', 'to', 'of', 'in', 'on', 'at', 'is', 'am', 'are',
        'was', 'were', 'my', 'me', 'we', 'you', 'it', 'so', 'this', 'that', 'these', 'those',
        'can', 'like', 'want', 'see', 'do', 'did', 'will', 'with', 'for', 'up', 'down', 'here',
        'there', 'now', 'then', 'too', 'very', 'not', 'be', 'as', 'but'
      ]);
      (station && Array.isArray(station.sightWords) ? station.sightWords : []).forEach(w => stop.add(String(w || '').toLowerCase()));

      const candidates = rawTokens
        .map(t => t.trim())
        .filter(Boolean)
        .filter(t => t.length >= 3)
        .filter(t => !stop.has(t.toLowerCase()))
        .filter(t => !exclude.has(t.toLowerCase()));

      candidates.sort((a, b) => b.length - a.length);
      return candidates.length ? candidates[0] : null;
    }

    function buildExtraWordQuestion({ station, keySentence, usedWords = new Set() }) {
      const correct = pickContentWordFromSentence(keySentence, station, usedWords);
      if (!correct) return null;

      const correctKey = correct.toLowerCase();
      usedWords.add(correctKey);

      const stop = new Set([
        'i', 'a', 'an', 'the', 'and', 'or', 'to', 'of', 'in', 'on', 'at', 'is', 'am', 'are',
        'was', 'were', 'my', 'me', 'we', 'you', 'it', 'so', 'this', 'that', 'these', 'those',
        'can', 'like', 'want', 'see', 'do', 'did', 'will', 'with', 'for', 'up', 'down', 'here',
        'there', 'now', 'then', 'too', 'very', 'not', 'be', 'as', 'but'
      ]);
      (station && Array.isArray(station.sightWords) ? station.sightWords : []).forEach(w => stop.add(String(w || '').toLowerCase()));

      const sentenceWords = new Set((String(keySentence || '').match(/[A-Za-z']+/g) || []).map(w => w.toLowerCase()));
      const pool = getGlobalExtraQuestionWordPool()
        .map(w => String(w || '').trim())
        .filter(Boolean)
        .filter(w => !sentenceWords.has(w.toLowerCase()))
        .filter(w => w.toLowerCase() !== correctKey)
        .filter(w => !stop.has(w.toLowerCase()))
        .filter(w => !usedWords.has(w.toLowerCase()));

      const distractors = pickDistinct(pool, 2);
      if (distractors.length < 2) return null;

      const answers = shuffleInPlace([correct, ...distractors]);
      return makeMCQ({
        question: 'Which word is in the story?',
        passage: keySentence,
        hint: 'Look at the highlighted sentence.',
        answers,
        correctAnswerName: correct,
        successMessage: 'Yes! You found the word in the story.',
        questionType: 'comprehension',
      });
    }

    function buildExtraSentenceQuestion({ stationId, keySentence }) {
      const correct = normalizePassageText(keySentence);
      const correctKey = normalizeTextForMatch(correct);
      if (!correct || !correctKey) return null;

      const pool = getGlobalExtraQuestionSentencePool()
        .filter(item => item && item.text && item.stationId && item.stationId !== stationId)
        .map(item => item.text)
        .filter(text => normalizeTextForMatch(text) !== correctKey);

      const distractors = pickDistinct(pool, 2);
      if (distractors.length < 2) return null;

      const answers = shuffleInPlace([correct, ...distractors]);
      return makeMCQ({
        question: 'Which sentence did you read?',
        passage: correct,
        hint: 'Look at the highlighted sentence.',
        answers,
        correctAnswerName: correct,
        successMessage: 'Yes! That sentence was in the story.',
        questionType: 'comprehension',
      });
    }

    function buildExtraQuestionsForReadPage({ stationId, station, readPage, needed }) {
      const extras = [];
      const usedWords = new Set();
      const keySentences = getKeySentencesForReadPage(readPage, 4);
      const usedKeySentences = new Set();

      for (let i = 0; i < needed; i++) {
        const nextKeySentence = keySentences.find(s => !usedKeySentences.has(normalizeTextForMatch(s)));
        const keySentence = nextKeySentence || keySentences[0] || '';
        const keySentenceKey = normalizeTextForMatch(keySentence);
        if (!keySentence || !keySentenceKey) break;
        if (nextKeySentence) usedKeySentences.add(keySentenceKey);

        const wordQ = buildExtraWordQuestion({ station, keySentence, usedWords });
        if (wordQ) {
          extras.push(wordQ);
          continue;
        }

        // Only use the sentence fallback when we can rotate key sentences; otherwise it becomes a duplicate.
        if (!nextKeySentence) break;
        const sentenceQ = buildExtraSentenceQuestion({ stationId, keySentence });
        if (sentenceQ) extras.push(sentenceQ);
      }

      return extras;
    }

    // ===== FOOD ADVENTURE: CHOOSE-YOUR-ADVENTURE (PILOT) =====
    // Pilot scope: a smaller set of food stops are interactive branching stories.
    // Other stations are shown on the map as "Coming soon".
	    const FOOD_STORY_PILOT_ORDER = [
	      'fruit',
	      'drink',
	      'bakery',
	      'pizza',
	      'bubbletea',
	      'icecream',
	    ];
	    const FOOD_STORY_PILOT_SET = new Set(FOOD_STORY_PILOT_ORDER);

    function isFoodStoryPilotStation(stationId) {
      return FOOD_STORY_PILOT_SET.has(String(stationId || ''));
    }

    function buildStoryNodesCommon({ stationId, sceneBase }) {
      const station = stationContent && stationContent[stationId] ? stationContent[stationId] : null;
      const stationName = station && station.name ? station.name : 'Food Stop';
      const sceneDefault = sceneBase || (stationImages && stationImages[stationId]) || null;

      return { stationName, sceneDefault };
    }

    // Branching story graphs. Nodes are converted to session pages as the child makes choices.
    // Node fields:
    // - type: 'read' | 'question' | 'menu' | 'router'
    // - next: node id (for non-menu)
    // - items: [{ name, icon?, description?, next, setFlags? }]
    // - sceneImage: optional per-node art (uses existing food art style)
    // - endingId/endingTitle/endingSummary: for the final read node in a path
	    const FOOD_STORY_GRAPHS = (() => {
	      const fruitScene = 'assets/elevator_scenes/fruit_restaurant.jpg';
	      const drinkScene = 'assets/elevator_scenes/drink_restaurant.jpg';
	      const bakeryScene = 'assets/elevator_scenes/bakery_restaurant.jpg';
	      const pizzaScene = 'assets/elevator_scenes/pizza_restaurant.jpg';
	      const icecreamScene = 'assets/elevator_scenes/icecream_restaurant.jpg';

	      const bubbleteaScene = 'assets/train_scenes/taipei_bubble_tea.jpeg';

	      return {
	        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	        // THE MAGIC FRUIT STAND - An Immersive Choose-Your-Adventure Story
	        // ~550 words across all branches, 4 major choice points, 3 unique endings
	        // Designed for Grade 1 reading comprehension (WHO, WHAT, WHERE, WHEN, WHY)
	        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	        fruit: {
	          start: 'ch1_arrival',
	          immersiveMode: true, // Enable storybook styling
	          storyTitle: 'The Magic Fruit Stand',
	          nodes: {
	            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
	            // CHAPTER 1: The Arrival
	            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
	            ch1_arrival: {
	              type: 'read',
	              sceneImage: fruitScene,
	              chapter: 'Chapter 1',
	              chapterTitle: 'The Market Street',
	              chapterIcon: 'ðŸŒ…',
	              sceneMood: 'warm',
	              showDropCap: true,
	              sentence: 'The morning sun feels warm on my face. I walk down the old market street in Taipei. I hear birds sing. I smell fresh bread from a shop. Then I see itâ€”a fruit stand with a bright red roof! An old man waves at me. His eyes are kind. His name is Mr. Lin. He has sold fruit here for many, many years.',
	              sightWordFocus: 'see',
	              readingTip: 'Look for "I see" - it tells you what the child notices.',
	              next: 'q1_where',
	            },
	            q1_where: {
	              type: 'question',
	              sceneImage: fruitScene,
	              questionType: 'comprehension',
	              questionMode: 'multipleChoice',
	              questionLabel: 'ðŸ“– Story Check',
	              passage: 'I walk down the old market street in Taipei.',
	              question: 'Where does this story take place?',
	              comprehensionHint: 'Look for the name of the city.',
	              answers: [
	                { name: 'Taipei', icon: 'ðŸ™ï¸' },
	                { name: 'The beach', icon: 'ðŸ–ï¸' },
	                { name: 'A school', icon: 'ðŸ«' },
	              ],
	              correctAnswerName: 'Taipei',
	              successMessage: 'Great job! You found the setting of our story.',
	              next: 'ch1_mr_lin',
	            },
	            ch1_mr_lin: {
	              type: 'read',
	              sceneImage: fruitScene,
	              sentence: 'Mr. Lin smiles at me. His teeth are white. His hands are tan from the sun. His table is full of fruit. I see golden mangoes, red apples, and purple grapes. Each fruit seems to glow in the soft morning light. A sweet smell fills the air. "Pick one," says Mr. Lin in a gentle voice. "Today is a good day for a gift."',
	              sightWordFocus: 'one',
	              readingTip: '"One" means just 1. Mr. Lin wants you to pick one fruit.',
	              next: 'q2_who',
	            },
	            q2_who: {
	              type: 'question',
	              sceneImage: fruitScene,
	              questionType: 'comprehension',
	              questionMode: 'multipleChoice',
	              questionLabel: 'ðŸ“– Story Check',
	              passage: 'His name is Mr. Lin. He has sold fruit here for many years.',
	              question: 'Who is Mr. Lin?',
	              comprehensionHint: 'What does Mr. Lin do?',
	              answers: [
	                { name: 'The fruit seller', icon: 'ðŸ§“' },
	                { name: 'A bus driver', icon: 'ðŸšŒ' },
	                { name: 'A teacher', icon: 'ðŸ‘©â€ðŸ«' },
	              ],
	              correctAnswerName: 'The fruit seller',
	              successMessage: 'Yes! Mr. Lin sells fruit at his stand.',
	              next: 'choice_fruit',
	            },

	            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
	            // CHOICE 1: Which magic fruit will you choose?
	            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
	            choice_fruit: {
	              type: 'menu',
	              storyChoice: true,
	              sceneImage: fruitScene,
	              prompt: 'Which fruit catches your eye?',
	              menuStory: 'Each fruit has its own magic. Choose wisely!',
	              chapterIcon: 'âœ¨',
	              items: [
	                { name: 'Golden Mango', icon: 'ðŸ¥­', description: 'It glows warm like a tiny sun', next: 'ch2_mango', setFlags: { fruit: 'mango' } },
	                { name: 'Red Apple', icon: 'ðŸŽ', description: 'Cool and smooth like a river stone', next: 'ch2_apple', setFlags: { fruit: 'apple' } },
	                { name: 'Purple Grapes', icon: 'ðŸ‡', description: 'A cluster of sweet little jewels', next: 'ch2_grapes', setFlags: { fruit: 'grapes' } },
	              ],
	            },

	            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
	            // CHAPTER 2: The Magic Awakens (3 paths)
	            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
	            ch2_mango: {
	              type: 'read',
	              sceneImage: fruitScene,
	              chapter: 'Chapter 2',
	              chapterTitle: 'The Golden Gift',
	              chapterIcon: 'ðŸ¥­',
	              sceneMood: 'magic',
	              showDropCap: true,
	              sentence: 'I pick up the golden mango. Oh! It feels warm in my hands, like a tiny sun. The skin is smooth and soft. Mr. Lin nods slowly. "That mango came from a tree on a sunny hill far away. It holds the warmth of summer days inside." I feel happy just holding it. My heart beats with joy.',
	              sightWordFocus: 'my',
	              next: 'q3_what_mango',
	            },
	            ch2_apple: {
	              type: 'read',
	              sceneImage: fruitScene,
	              chapter: 'Chapter 2',
	              chapterTitle: 'The Mountain Gift',
	              chapterIcon: 'ðŸŽ',
	              sceneMood: 'magic',
	              showDropCap: true,
	              sentence: 'I pick up the red apple. Oh! It is cold and smooth, like a stone from a stream. The red skin shines like a jewel. Mr. Lin smiles softly. "That apple fell from an old tree high in the mountains. It is full of sweet juice." The apple feels very special in my hand.',
	              sightWordFocus: 'is',
	              next: 'q3_what_apple',
	            },
	            ch2_grapes: {
	              type: 'read',
	              sceneImage: fruitScene,
	              chapter: 'Chapter 2',
	              chapterTitle: 'The River Gift',
	              chapterIcon: 'ðŸ‡',
	              sceneMood: 'magic',
	              showDropCap: true,
	              sentence: 'I pick up the purple grapes. Oh! They are small but heavy, like little plums. The purple skins are dusted with a soft, misty glow. Mr. Lin whispers, "These grapes grew by a quiet river. Each one holds a tiny bit of sweetness." I count them carefully. There are ten little grapes.',
	              sightWordFocus: 'are',
	              next: 'q3_what_grapes',
	            },

	            q3_what_mango: {
	              type: 'question',
	              sceneImage: fruitScene,
	              questionType: 'comprehension',
	              questionMode: 'multipleChoice',
	              questionLabel: 'ðŸ“– Story Check',
	              passage: 'It holds the warmth of summer days.',
	              question: 'What does the mango hold?',
	              answers: [
	                { name: 'Warmth', icon: 'â˜€ï¸' },
	                { name: 'Water', icon: 'ðŸ’§' },
	                { name: 'Seeds', icon: 'ðŸŒ±' },
	              ],
	              correctAnswerName: 'Warmth',
	              successMessage: 'The magic mango holds summer warmth!',
	              next: 'choice_action',
	            },
	            q3_what_apple: {
	              type: 'question',
	              sceneImage: fruitScene,
	              questionType: 'comprehension',
	              questionMode: 'multipleChoice',
	              questionLabel: 'ðŸ“– Story Check',
	              passage: 'It is full of sweet juice.',
	              question: 'What is the apple full of?',
	              answers: [
	                { name: 'Sweet juice', icon: 'ðŸ’§' },
	                { name: 'Seeds', icon: 'ðŸŒ±' },
	                { name: 'Air', icon: 'ðŸ’¨' },
	              ],
	              correctAnswerName: 'Sweet juice',
	              successMessage: 'Yes! The mountain apple is full of sweet juice.',
	              next: 'choice_action',
	            },
	            q3_what_grapes: {
	              type: 'question',
	              sceneImage: fruitScene,
	              questionType: 'comprehension',
	              questionMode: 'multipleChoice',
	              questionLabel: 'ðŸ“– Story Check',
	              passage: 'I count them. There are ten.',
	              question: 'How many grapes are there?',
	              answers: [
	                { name: 'Ten', icon: 'ðŸ”Ÿ' },
	                { name: 'Five', icon: '5ï¸âƒ£' },
	                { name: 'Twenty', icon: '2ï¸âƒ£' },
	              ],
	              correctAnswerName: 'Ten',
	              successMessage: 'You counted correctly! Ten little grapes.',
	              next: 'choice_action',
	            },

	            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
	            // CHOICE 2: What will you do with your magic fruit?
	            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
	            choice_action: {
	              type: 'menu',
	              storyChoice: true,
	              sceneImage: fruitScene,
	              prompt: 'What will you do now?',
	              menuStory: 'Your choice will change the story!',
	              chapterIcon: 'ðŸŽ¯',
	              items: [
	                { name: 'Eat it now', icon: 'ðŸ˜‹', description: 'Take a bite and taste the magic inside', next: 'ch3_eat', setFlags: { action: 'eat' } },
	                { name: 'Share it', icon: 'ðŸ¤', description: 'Look for someone to share with', next: 'ch3_share', setFlags: { action: 'share' } },
	                { name: 'Ask Mr. Lin', icon: 'â“', description: 'Ask about the fruit\'s secret', next: 'ch3_ask', setFlags: { action: 'ask' } },
	              ],
	            },

	            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
	            // CHAPTER 3: The Choice (3 paths)
	            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
	            ch3_eat: {
	              type: 'read',
	              sceneImage: fruitScene,
	              chapter: 'Chapter 3',
	              chapterTitle: 'A Magical Taste',
	              chapterIcon: 'âœ¨',
	              sceneMood: 'magic',
	              showDropCap: true,
	              floatingElements: ['âœ¨', 'ðŸŒŸ', 'â­'],
	              sentence: 'I take a small bite. Mmm! The taste fills my mouth with sweetness like honey. Juice runs down my chin. I close my eyes tight. And then... I can see a sunny hill! I see an old tree with wide branches. I hear a quiet river flowing. The magic fruit shows me where it grew! I open my eyes in wonder.',
	              sightWordFocus: 'can',
	              next: 'q4_why_eat',
	            },
	            ch3_share: {
	              type: 'read',
	              sceneImage: fruitScene,
	              chapter: 'Chapter 3',
	              chapterTitle: 'A Kind Heart',
	              chapterIcon: 'ðŸ’•',
	              sceneMood: 'warm',
	              showDropCap: true,
	              floatingElements: ['ðŸ’•', 'ðŸ’›', 'ðŸ§¡'],
	              sentence: 'I look around the market. I see a little girl sitting alone on a wooden bench. Her head is down. She looks sad and lonely. I walk over to her. My feet tap on the ground. "Would you like some?" I ask softly. She looks up. Her eyes grow big. She smiles and takes a piece. We sit together and eat. The fruit tastes even sweeter when shared.',
	              sightWordFocus: 'to',
	              next: 'q4_why_share',
	            },
	            ch3_ask: {
	              type: 'read',
	              sceneImage: fruitScene,
	              chapter: 'Chapter 3',
	              chapterTitle: 'The Secret',
	              chapterIcon: 'ðŸ¤«',
	              sceneMood: 'warm',
	              showDropCap: true,
	              floatingElements: ['ðŸŒ±', 'â˜€ï¸', 'ðŸ’§'],
	              sentence: 'I look at Mr. Lin with big, curious eyes. "How is this fruit magic?" I ask. He laughs softly. His laugh sounds like wind chimes. "All fruit is magic," he says with a wink. "It grows from a tiny, tiny seed. The warm sun and cool rain help it grow. Then it gives us joy to eat." I nod. Now I understand.',
	              sightWordFocus: 'is',
	              next: 'q4_why_ask',
	            },

	            q4_why_eat: {
	              type: 'question',
	              sceneImage: fruitScene,
	              questionType: 'comprehension',
	              questionMode: 'multipleChoice',
	              questionLabel: 'ðŸ“– Story Check',
	              passage: 'The fruit shows me where it grew!',
	              question: 'Why did the child close their eyes?',
	              answers: [
	                { name: 'To see where the fruit grew', icon: 'ðŸ‘ï¸' },
	                { name: 'To go to sleep', icon: 'ðŸ˜´' },
	                { name: 'Because it was too bright', icon: 'â˜€ï¸' },
	              ],
	              correctAnswerName: 'To see where the fruit grew',
	              successMessage: 'The magic fruit showed a vision of its home!',
	              next: 'choice_final',
	            },
	            q4_why_share: {
	              type: 'question',
	              sceneImage: fruitScene,
	              questionType: 'comprehension',
	              questionMode: 'multipleChoice',
	              questionLabel: 'ðŸ“– Story Check',
	              passage: 'She looks sad. I walk over to her.',
	              question: 'Why did you share with the girl?',
	              answers: [
	                { name: 'She looked sad', icon: 'ðŸ˜¢' },
	                { name: 'She asked for it', icon: 'ðŸ™‹' },
	                { name: 'Mr. Lin told you to', icon: 'ðŸ§“' },
	              ],
	              correctAnswerName: 'She looked sad',
	              successMessage: 'You noticed she was sad and wanted to help!',
	              next: 'choice_final',
	            },
	            q4_why_ask: {
	              type: 'question',
	              sceneImage: fruitScene,
	              questionType: 'comprehension',
	              questionMode: 'multipleChoice',
	              questionLabel: 'ðŸ“– Story Check',
	              passage: 'It grows from a tiny seed. The sun and rain help it.',
	              question: 'What helps the fruit grow?',
	              answers: [
	                { name: 'Sun and rain', icon: 'ðŸŒ¦ï¸' },
	                { name: 'Snow and ice', icon: 'â„ï¸' },
	                { name: 'Magic words', icon: 'âœ¨' },
	              ],
	              correctAnswerName: 'Sun and rain',
	              successMessage: 'Mr. Lin taught you about nature!',
	              next: 'choice_final',
	            },

	            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
	            // CHOICE 3: How will your story end?
	            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
	            choice_final: {
	              type: 'menu',
	              storyChoice: true,
	              sceneImage: fruitScene,
	              prompt: 'How do you want to end your day?',
	              menuStory: 'Every story needs a good ending.',
	              chapterIcon: 'ðŸŒŸ',
	              items: [
	                { name: 'Thank Mr. Lin', icon: 'ðŸ™', description: 'Bow your head and say thank you', next: 'ending_grateful', setFlags: { ending: 'grateful' } },
	                { name: 'Make a wish', icon: 'â­', description: 'Close your eyes and make a wish', next: 'ending_wish', setFlags: { ending: 'wish' } },
	                { name: 'Come back tomorrow', icon: 'ðŸŒ…', description: 'Wave goodbye and promise to return', next: 'ending_return', setFlags: { ending: 'return' } },
	              ],
	            },

	            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
	            // CHAPTER 4: The Endings (3 unique endings)
	            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
	            ending_grateful: {
	              type: 'read',
	              sceneImage: fruitScene,
	              chapter: 'The End',
	              chapterTitle: 'The Grateful Heart',
	              chapterIcon: 'ðŸ™',
	              sceneMood: 'sunset',
	              showDropCap: true,
	              sentence: 'I bow my head to Mr. Lin. "Thank you for your gift," I say. My voice is soft with thanks. He pats my shoulder gently. His hand is warm. "You have a kind heart," he says. "That is the best magic of all." The sun sets behind us. I walk home feeling warm inside, like I swallowed a piece of sunshine. The fruit stand will be here tomorrow. And I will come back. I promise.',
	              endingId: 'fruit_grateful',
	              endingTitle: 'The Grateful Heart',
	              endingSummary: 'You showed kindness to Mr. Lin and learned that gratitude is the best magic.',
	              sightWordFocus: 'for',
	              autoSightWordQuestion: false,
	            },
	            ending_wish: {
	              type: 'read',
	              sceneImage: fruitScene,
	              chapter: 'The End',
	              chapterTitle: 'The Wishing Star',
	              chapterIcon: 'â­',
	              sceneMood: 'sunset',
	              showDropCap: true,
	              sentence: 'I hold the last piece of fruit in my hand. It glows softly in the evening light. I close my eyes tight and make a wish. I wish for more sunny days. I wish for more kind people like Mr. Lin. I wish for magic everywhere. When I open my eyes, the sun seems brighter. The sky is painted with pink and gold. Maybe wishes do come true.',
	              endingId: 'fruit_wish',
	              endingTitle: 'The Wishing Star',
	              endingSummary: 'You made a wish on the magic fruit. Maybe it will come true!',
	              sightWordFocus: 'for',
	              autoSightWordQuestion: false,
	            },
	            ending_return: {
	              type: 'read',
	              sceneImage: fruitScene,
	              chapter: 'The End',
	              chapterTitle: 'The New Friend',
	              chapterIcon: 'ðŸŒ…',
	              sceneMood: 'sunset',
	              showDropCap: true,
	              sentence: 'I wave goodbye to Mr. Lin. My arm swings high. "I will come back tomorrow!" I call out. My voice echoes down the street. He waves back with a big, wide smile. His eyes sparkle like stars. The old market street feels like home now. The sounds. The smells. The colors. I know I have found a special place. And a very special friend.',
	              endingId: 'fruit_return',
	              endingTitle: 'The New Friend',
	              endingSummary: 'You made a friend at the fruit stand and will visit again.',
	              sightWordFocus: 'will',
	              autoSightWordQuestion: false,
	            },
	          },
	        },

	        drink: {
	          start: 'start',
	          nodes: {
	            start: {
	              type: 'read',
	              sceneImage: drinkScene,
	              sentence: 'I am at the drink bar today. I see cups. I see cold water. I see juice. I see tea. I feel thirsty.',
	              sightWordFocus: 'see',
	              readingTip: 'Look for details. I see tells what is there.',
	              next: 'q_where',
	            },
	            q_where: {
	              type: 'question',
	              sceneImage: drinkScene,
	              questionType: 'comprehension',
	              questionMode: 'multipleChoice',
	              passage: 'I am at the drink bar today.',
	              question: 'Where am I?',
	              comprehensionHint: 'Find the place name.',
	              answers: [
	                { name: 'Drink Bar', icon: 'ðŸ¥¤' },
	                { name: 'Bakery', icon: 'ðŸ§' },
	                { name: 'Park', icon: 'ðŸŒ³' },
	              ],
	              correctAnswerName: 'Drink Bar',
	              successMessage: 'Yes! You found the setting.',
	              next: 'read_counter',
	            },
	            read_counter: {
	              type: 'read',
	              sceneImage: drinkScene,
	              sentence: 'A worker smiles at me. I walk to the counter.',
	              sightWordFocus: 'to',
	              autoSightWordQuestion: false,
	              next: 'choice_words',
	            },
	            choice_words: {
	              type: 'menu',
	              storyChoice: true,
	              sceneImage: drinkScene,
	              prompt: 'What will you say?',
	              menuStory: 'Be kind at the drink bar.',
	              items: [
	                { name: 'Hello', icon: 'ðŸ‘‹', description: 'Say hi', next: 'read_greet', setFlags: { greet: 'hello' } },
	                { name: 'Please', icon: 'ðŸ™', description: 'Ask nicely', next: 'read_greet', setFlags: { greet: 'please' } },
	                { name: 'Thank you', icon: 'ðŸ’›', description: 'Be grateful', next: 'read_greet', setFlags: { greet: 'thanks' } },
	              ],
	            },
	            read_greet: {
	              type: 'read',
	              sceneImage: drinkScene,
	              sentence: 'I use a kind voice. The worker listens to me. The worker gives me a cup.',
	              sightWordFocus: 'the',
	              autoSightWordQuestion: false,
	              next: 'q_cup',
	            },
	            q_cup: {
	              type: 'question',
	              sceneImage: drinkScene,
	              questionType: 'comprehension',
	              questionMode: 'multipleChoice',
	              passage: 'The worker gives me a cup.',
	              question: 'What does the worker give me?',
	              comprehensionHint: 'Find the object word.',
	              answers: [
	                { name: 'A cup', icon: 'ðŸ¥¤' },
	                { name: 'A hat', icon: 'ðŸ§¢' },
	                { name: 'A toy', icon: 'ðŸ§¸' },
	              ],
	              correctAnswerName: 'A cup',
	              successMessage: 'Yes! The worker gives me a cup.',
	              next: 'choice_drink',
	            },
	            choice_drink: {
	              type: 'menu',
	              storyChoice: true,
	              sceneImage: drinkScene,
	              prompt: 'What drink do you want?',
	              menuStory: 'Think about the story: cold water, juice, tea.',
	              items: [
	                { name: 'Water', icon: 'ðŸ’§', description: 'Cold water', next: 'read_make', setFlags: { drink: 'water' } },
	                { name: 'Juice', icon: 'ðŸ§ƒ', description: 'Sweet juice', next: 'read_make', setFlags: { drink: 'juice' } },
	                { name: 'Tea', icon: 'ðŸµ', description: 'Warm tea', next: 'read_make', setFlags: { drink: 'tea' } },
	              ],
	            },
	            read_make: {
	              type: 'read',
	              sceneImage: drinkScene,
	              sentence: 'The worker pours my drink. Now I can pick a cup size.',
	              sightWordFocus: 'can',
	              autoSightWordQuestion: false,
	              next: 'choice_size',
	            },
	            choice_size: {
	              type: 'menu',
	              storyChoice: true,
	              sceneImage: drinkScene,
	              prompt: 'Pick a cup size!',
	              menuStory: 'Choose a size that feels right.',
	              items: [
	                { name: 'Small', icon: 'ðŸ¥›', description: 'A small cup', next: 'read_ice', setFlags: { size: 'small' } },
	                { name: 'Medium', icon: 'ðŸ¥¤', description: 'A medium cup', next: 'read_ice', setFlags: { size: 'medium' } },
	                { name: 'Big', icon: 'ðŸ§ƒ', description: 'A big cup', next: 'read_ice', setFlags: { size: 'big' } },
	              ],
	            },
	            read_ice: {
	              type: 'read',
	              sceneImage: drinkScene,
	              sentence: 'Now I can pick ice.',
	              sightWordFocus: 'can',
	              autoSightWordQuestion: false,
	              next: 'choice_ice',
	            },
	            choice_ice: {
	              type: 'menu',
	              storyChoice: true,
	              sceneImage: drinkScene,
	              prompt: 'How much ice?',
	              menuStory: 'Pick what you like.',
	              items: [
	                { name: 'Lots of ice', icon: 'ðŸ§Š', description: 'Very cold', next: 'read_straw', setFlags: { ice: 'lots' } },
	                { name: 'Little ice', icon: 'ðŸ§Š', description: 'A few cubes', next: 'read_straw', setFlags: { ice: 'little' } },
	                { name: 'No ice', icon: 'ðŸ™‚', description: 'No cubes', next: 'read_straw', setFlags: { ice: 'none' } },
	              ],
	            },
	            read_straw: {
	              type: 'read',
	              sceneImage: drinkScene,
	              sentence: 'I see straws on the counter.',
	              sightWordFocus: 'see',
	              autoSightWordQuestion: false,
	              next: 'choice_straw',
	            },
	            choice_straw: {
	              type: 'menu',
	              storyChoice: true,
	              sceneImage: drinkScene,
	              prompt: 'Pick a straw!',
	              menuStory: 'Choose what helps you drink.',
	              items: [
	                { name: 'Big straw', icon: 'ðŸŸ¦', description: 'Big sip', next: 'read_place', setFlags: { straw: 'big' } },
	                { name: 'Small straw', icon: 'ðŸŸ¨', description: 'Small sip', next: 'read_place', setFlags: { straw: 'small' } },
	                { name: 'No straw', icon: 'ðŸ¥›', description: 'Drink from cup', next: 'read_place', setFlags: { straw: 'none' } },
	              ],
	            },
	            read_place: {
	              type: 'read',
	              sceneImage: drinkScene,
	              sentence: 'My drink is ready. I need a calm place to drink.',
	              sightWordFocus: 'my',
	              autoSightWordQuestion: false,
	              next: 'choice_place',
	            },
	            choice_place: {
	              type: 'menu',
	              storyChoice: true,
	              sceneImage: drinkScene,
	              prompt: 'Where will you drink?',
	              menuStory: 'Pick a calm choice.',
	              items: [
	                { name: 'Small table', icon: 'ðŸª‘', description: 'Sit down', next: 'read_friend', setFlags: { place: 'table' } },
	                { name: 'By the window', icon: 'ðŸªŸ', description: 'Look out', next: 'read_friend', setFlags: { place: 'window' } },
	                { name: 'Outside air', icon: 'ðŸŒ¤', description: 'Cool breeze', next: 'read_friend', setFlags: { place: 'outside' } },
	              ],
	            },
	            read_friend: {
	              type: 'read',
	              sceneImage: drinkScene,
	              sentence: 'A friend walks by. My friend looks at my drink.',
	              sightWordFocus: 'my',
	              autoSightWordQuestion: false,
	              next: 'choice_share',
	            },
	            choice_share: {
	              type: 'menu',
	              storyChoice: true,
	              sceneImage: drinkScene,
	              prompt: 'What will you do?',
	              menuStory: 'Be a good friend.',
	              items: [
	                { name: 'Share a sip', icon: 'ðŸ¤', description: 'Share kindly', next: 'read_cleanup', setFlags: { share: true } },
	                { name: 'Save it', icon: 'ðŸ§¡', description: 'Keep it for me', next: 'read_cleanup', setFlags: { share: false } },
	                { name: 'Ask first', icon: 'â“', description: 'Use kind words', next: 'read_cleanup', setFlags: { share: 'ask' } },
	              ],
	            },
	            read_cleanup: {
	              type: 'read',
	              sceneImage: drinkScene,
	              sentence: 'All done. I hold my cup.',
	              sightWordFocus: 'my',
	              autoSightWordQuestion: false,
	              next: 'choice_cleanup',
	            },
	            choice_cleanup: {
	              type: 'menu',
	              storyChoice: true,
	              sceneImage: drinkScene,
	              prompt: 'What do you do with the cup?',
	              menuStory: 'Use a clean choice.',
	              items: [
	                { name: 'Recycle', icon: 'â™»ï¸', description: 'Put it in recycle', next: 'router_end', setFlags: { clean: 'recycle' } },
	                { name: 'Trash', icon: 'ðŸ—‘ï¸', description: 'Throw it away', next: 'router_end', setFlags: { clean: 'trash' } },
	                { name: 'Keep it', icon: 'ðŸ§ƒ', description: 'Take it home', next: 'router_end', setFlags: { clean: 'keep' } },
	              ],
	            },
	            router_end: {
	              type: 'router',
	              routes: [
	                { when: (flags) => flags.share === true || flags.share === 'ask', next: 'ending_friend' },
	                { when: (flags) => flags.drink === 'tea', next: 'ending_tea' },
	                { when: (flags) => flags.drink === 'juice', next: 'ending_juice' },
	                { when: () => true, next: 'ending_water' },
	              ],
	            },
	            ending_friend: {
	              type: 'read',
	              sceneImage: drinkScene,
	              sentence: 'My drink story ends with sharing. I use kind words. I feel proud.',
	              endingId: 'drink_friend',
	              endingTitle: 'Kind Sip',
	              endingSummary: 'You shared your drink and used kind words.',
	              sightWordFocus: 'my',
	              autoSightWordQuestion: false,
	            },
	            ending_tea: {
	              type: 'read',
	              sceneImage: drinkScene,
	              sentence: 'My drink story ends with tea. I take a warm sip. I feel calm.',
	              endingId: 'drink_tea',
	              endingTitle: 'Warm Tea',
	              endingSummary: 'You picked tea and drank calmly.',
	              sightWordFocus: 'I',
	              autoSightWordQuestion: false,
	            },
	            ending_juice: {
	              type: 'read',
	              sceneImage: drinkScene,
	              sentence: 'My drink story ends with juice. It is sweet. Yum!',
	              endingId: 'drink_juice',
	              endingTitle: 'Juice Yum',
	              endingSummary: 'You picked juice and enjoyed a sweet drink.',
	              sightWordFocus: 'is',
	              autoSightWordQuestion: false,
	            },
	            ending_water: {
	              type: 'read',
	              sceneImage: drinkScene,
	              sentence: 'My drink story ends with cold water. I feel refreshed.',
	              endingId: 'drink_water',
	              endingTitle: 'Cool Water',
	              endingSummary: 'You picked cold water and felt refreshed.',
	              sightWordFocus: 'I',
	              autoSightWordQuestion: false,
	            },
	          },
	        },

	        bakery: {
	          start: 'start',
	          nodes: {
	            start: {
	              type: 'read',
	              sceneImage: bakeryScene,
	              sentence: 'I am at the bakery today. The door is open. I smell warm bread. The air is warm and sweet.',
	              sightWordFocus: 'the',
	              readingTip: 'Look for the smell words.',
	              next: 'q_where',
	            },
	            q_where: {
	              type: 'question',
	              sceneImage: bakeryScene,
	              questionType: 'comprehension',
	              questionMode: 'multipleChoice',
	              passage: 'I am at the bakery today.',
	              question: 'Where am I?',
	              comprehensionHint: 'Find the place name.',
	              answers: [
	                { name: 'Bakery', icon: 'ðŸ§' },
	                { name: 'Fruit Stand', icon: 'ðŸŽ' },
	                { name: 'Park', icon: 'ðŸŒ³' },
	              ],
	              correctAnswerName: 'Bakery',
	              successMessage: 'Yes! The story happens at the bakery.',
	              next: 'read_treats',
	            },
	            read_treats: {
	              type: 'read',
	              sceneImage: bakeryScene,
	              sentence: 'I see big cakes. I see little pies. I see warm buns.',
	              sightWordFocus: 'see',
	              autoSightWordQuestion: false,
	              next: 'q_smell',
	            },
	            q_smell: {
	              type: 'question',
	              sceneImage: bakeryScene,
	              questionType: 'comprehension',
	              questionMode: 'multipleChoice',
	              passage: 'I smell warm bread.',
	              question: 'What do I smell?',
	              comprehensionHint: 'Find the smell sentence.',
	              answers: [
	                { name: 'Warm bread', icon: 'ðŸž' },
	                { name: 'Cold ice', icon: 'ðŸ§Š' },
	                { name: 'Soap', icon: 'ðŸ§¼' },
	              ],
	              correctAnswerName: 'Warm bread',
	              successMessage: 'Yes! I smell warm bread.',
	              next: 'choice_first',
	            },
	            choice_first: {
	              type: 'menu',
	              storyChoice: true,
	              sceneImage: bakeryScene,
	              prompt: 'What will you look at first?',
	              menuStory: 'Think about the story: big cakes, little pies, warm buns.',
	              items: [
	                { name: 'Cake shelf', icon: 'ðŸŽ‚', description: 'Big cake', next: 'read_cake', setFlags: { treatLook: 'cake' } },
	                { name: 'Pie tray', icon: 'ðŸ¥§', description: 'Little pies', next: 'read_pie', setFlags: { treatLook: 'pie' } },
	                { name: 'Bun basket', icon: 'ðŸ¥', description: 'Warm buns', next: 'read_bun', setFlags: { treatLook: 'bun' } },
	              ],
	            },
	            read_cake: {
	              type: 'read',
	              sceneImage: bakeryScene,
	              sentence: 'The cake is on the top shelf. It looks big and soft.',
	              sightWordFocus: 'the',
	              autoSightWordQuestion: false,
	              next: 'choice_ask',
	            },
	            read_pie: {
	              type: 'read',
	              sceneImage: bakeryScene,
	              sentence: 'The pies are on a tray. They look sweet and yummy.',
	              sightWordFocus: 'the',
	              autoSightWordQuestion: false,
	              next: 'choice_ask',
	            },
	            read_bun: {
	              type: 'read',
	              sceneImage: bakeryScene,
	              sentence: 'The buns are warm. They smell so good.',
	              sightWordFocus: 'so',
	              autoSightWordQuestion: false,
	              next: 'choice_ask',
	            },
	            choice_ask: {
	              type: 'menu',
	              storyChoice: true,
	              sceneImage: bakeryScene,
	              prompt: 'What will you do?',
	              menuStory: 'The man at the shop can help you.',
	              items: [
	                { name: 'Ask for help', icon: 'ðŸ™‹', description: 'Use words', next: 'read_help', setFlags: { askHelp: true } },
	                { name: 'Point politely', icon: 'ðŸ‘‰', description: 'Show the treat', next: 'read_point', setFlags: { askHelp: 'point' } },
	                { name: 'Wait calmly', icon: 'ðŸ§˜', description: 'Take turns', next: 'read_wait', setFlags: { askHelp: false } },
	              ],
	            },
	            read_help: {
	              type: 'read',
	              sceneImage: bakeryScene,
	              sentence: 'I say, "Please." The man smiles. He listens to me.',
	              sightWordFocus: 'say',
	              autoSightWordQuestion: false,
	              next: 'choice_pick',
	            },
	            read_point: {
	              type: 'read',
	              sceneImage: bakeryScene,
	              sentence: 'I point to the treat. I use a kind voice.',
	              sightWordFocus: 'to',
	              autoSightWordQuestion: false,
	              next: 'choice_pick',
	            },
	            read_wait: {
	              type: 'read',
	              sceneImage: bakeryScene,
	              sentence: 'I wait. Then the man says, "I can help you."',
	              sightWordFocus: 'can',
	              autoSightWordQuestion: false,
	              next: 'choice_pick',
	            },
	            choice_pick: {
	              type: 'menu',
	              storyChoice: true,
	              sceneImage: bakeryScene,
	              prompt: 'Pick your treat!',
	              menuStory: 'Think about the story: big cake, little pies, warm buns.',
	              items: [
	                { name: 'Cake', icon: 'ðŸŽ‚', description: 'Big and soft', next: 'read_drink', setFlags: { treat: 'cake' } },
	                { name: 'Pie', icon: 'ðŸ¥§', description: 'Sweet and yummy', next: 'read_drink', setFlags: { treat: 'pie' } },
	                { name: 'Bun', icon: 'ðŸ¥', description: 'Warm and round', next: 'read_drink', setFlags: { treat: 'bun' } },
	              ],
	            },
	            read_drink: {
	              type: 'read',
	              sceneImage: bakeryScene,
	              sentence: 'The man puts my treat in a bag. He asks, "Do you want a drink too?"',
	              sightWordFocus: 'my',
	              autoSightWordQuestion: false,
	              next: 'choice_drink',
	            },
	            choice_drink: {
	              type: 'menu',
	              storyChoice: true,
	              sceneImage: bakeryScene,
	              prompt: 'Pick a drink!',
	              menuStory: 'Choose a drink for your treat.',
	              items: [
	                { name: 'Milk', icon: 'ðŸ¥›', description: 'Cold milk', next: 'read_pay', setFlags: { drink: 'milk' } },
	                { name: 'Tea', icon: 'ðŸµ', description: 'Warm tea', next: 'read_pay', setFlags: { drink: 'tea' } },
	                { name: 'Water', icon: 'ðŸ’§', description: 'Cool water', next: 'read_pay', setFlags: { drink: 'water' } },
	              ],
	            },
	            read_pay: {
	              type: 'read',
	              sceneImage: bakeryScene,
	              sentence: 'Now I can pay. I hold my bag.',
	              sightWordFocus: 'can',
	              autoSightWordQuestion: false,
	              next: 'choice_pay',
	            },
	            choice_pay: {
	              type: 'menu',
	              storyChoice: true,
	              sceneImage: bakeryScene,
	              prompt: 'How will you pay?',
	              menuStory: 'Choose a way to pay.',
	              items: [
	                { name: 'Coins', icon: 'ðŸª™', description: 'Pay with coins', next: 'read_place', setFlags: { pay: 'coins' } },
	                { name: 'Card', icon: 'ðŸ’³', description: 'Pay with a card', next: 'read_place', setFlags: { pay: 'card' } },
	                { name: 'Ask for help', icon: 'ðŸ™‹', description: 'Get help', next: 'read_place', setFlags: { pay: 'help' } },
	              ],
	            },
	            read_place: {
	              type: 'read',
	              sceneImage: bakeryScene,
	              sentence: 'I have my treat. Now I can pick a calm place to eat.',
	              sightWordFocus: 'my',
	              autoSightWordQuestion: false,
	              next: 'choice_place',
	            },
	            choice_place: {
	              type: 'menu',
	              storyChoice: true,
	              sceneImage: bakeryScene,
	              prompt: 'Where will you eat?',
	              menuStory: 'Pick a calm choice.',
	              items: [
	                { name: 'Small table', icon: 'ðŸª‘', description: 'Sit down', next: 'read_friend', setFlags: { place: 'table' } },
	                { name: 'By the window', icon: 'ðŸªŸ', description: 'Look out', next: 'read_friend', setFlags: { place: 'window' } },
	                { name: 'Outside air', icon: 'ðŸŒ¤', description: 'Cool breeze', next: 'read_friend', setFlags: { place: 'outside' } },
	              ],
	            },
	            read_friend: {
	              type: 'read',
	              sceneImage: bakeryScene,
	              sentence: 'A friend smiles at me. My treat looks so good.',
	              sightWordFocus: 'my',
	              autoSightWordQuestion: false,
	              next: 'choice_share',
	            },
	            choice_share: {
	              type: 'menu',
	              storyChoice: true,
	              sceneImage: bakeryScene,
	              prompt: 'What will you do next?',
	              menuStory: 'Be a good friend.',
	              items: [
	                { name: 'Share a bite', icon: 'ðŸ¤', description: 'Share kindly', next: 'read_cleanup', setFlags: { share: true } },
	                { name: 'Save it', icon: 'ðŸ§¡', description: 'Keep it for me', next: 'read_cleanup', setFlags: { share: false } },
	                { name: 'Ask first', icon: 'â“', description: 'Use kind words', next: 'read_cleanup', setFlags: { share: 'ask' } },
	              ],
	            },
	            read_cleanup: {
	              type: 'read',
	              sceneImage: bakeryScene,
	              sentence: 'All done. I have a wrapper.',
	              sightWordFocus: 'a',
	              autoSightWordQuestion: false,
	              next: 'choice_cleanup',
	            },
	            choice_cleanup: {
	              type: 'menu',
	              storyChoice: true,
	              sceneImage: bakeryScene,
	              prompt: 'What do you do with the wrapper?',
	              menuStory: 'Use a clean choice.',
	              items: [
	                { name: 'Trash can', icon: 'ðŸ—‘ï¸', description: 'Keep it clean', next: 'router_end', setFlags: { clean: 'trash' } },
	                { name: 'Napkin', icon: 'ðŸ§»', description: 'Hold it safely', next: 'router_end', setFlags: { clean: 'napkin' } },
	                { name: 'Pocket (then trash)', icon: 'ðŸ‘–', description: 'Trash it soon', next: 'router_end', setFlags: { clean: 'pocket' } },
	              ],
	            },
	            router_end: {
	              type: 'router',
	              routes: [
	                { when: (flags) => flags.share === true || flags.share === 'ask', next: 'ending_kind' },
	                { when: (flags) => flags.treat === 'bun', next: 'ending_bun' },
	                { when: (flags) => flags.treat === 'pie', next: 'ending_pie' },
	                { when: () => true, next: 'ending_cake' },
	              ],
	            },
	            ending_kind: {
	              type: 'read',
	              sceneImage: bakeryScene,
	              sentence: 'My bakery story ends with sharing. I say thank you. I feel proud.',
	              endingId: 'bakery_kind',
	              endingTitle: 'Kind Baker',
	              endingSummary: 'You shared and used kind words.',
	              sightWordFocus: 'my',
	              autoSightWordQuestion: false,
	            },
	            ending_bun: {
	              type: 'read',
	              sceneImage: bakeryScene,
	              sentence: 'My bakery story ends with a warm bun. It is soft. Yum!',
	              endingId: 'bakery_bun',
	              endingTitle: 'Warm Bun',
	              endingSummary: 'You picked a warm bun and ate calmly.',
	              sightWordFocus: 'a',
	              autoSightWordQuestion: false,
	            },
	            ending_pie: {
	              type: 'read',
	              sceneImage: bakeryScene,
	              sentence: 'My bakery story ends with a sweet pie. I take a bite. Yum!',
	              endingId: 'bakery_pie',
	              endingTitle: 'Sweet Pie',
	              endingSummary: 'You picked a sweet pie and enjoyed it.',
	              sightWordFocus: 'a',
	              autoSightWordQuestion: false,
	            },
	            ending_cake: {
	              type: 'read',
	              sceneImage: bakeryScene,
	              sentence: 'My bakery story ends with cake. It is big and soft. I smile.',
	              endingId: 'bakery_cake',
	              endingTitle: 'Big Cake',
	              endingSummary: 'You picked cake and enjoyed a sweet treat.',
	              sightWordFocus: 'is',
	              autoSightWordQuestion: false,
	            },
	          },
	        },

	        pizza: {
	          start: 'start',
	          nodes: {
	            start: {
	              type: 'read',
	              sceneImage: pizzaScene,
	              sentence: 'I am at the pizza place today. I smell cheese. I see a hot oven.',
	              sightWordFocus: 'see',
	              readingTip: 'Smell is a clue word.',
	              next: 'q_where',
	            },
	            q_where: {
	              type: 'question',
	              sceneImage: pizzaScene,
	              questionType: 'comprehension',
	              questionMode: 'multipleChoice',
	              passage: 'I am at the pizza place today.',
	              question: 'Where am I?',
	              comprehensionHint: 'Find the place name.',
	              answers: [
	                { name: 'Pizza Place', icon: 'ðŸ•' },
	                { name: 'Train', icon: 'ðŸš‡' },
	                { name: 'Fruit Stand', icon: 'ðŸŽ' },
	              ],
	              correctAnswerName: 'Pizza Place',
	              successMessage: 'Yes! The story happens at the pizza place.',
	              next: 'q_smell',
	            },
	            q_smell: {
	              type: 'question',
	              sceneImage: pizzaScene,
	              questionType: 'comprehension',
	              questionMode: 'multipleChoice',
	              passage: 'I smell cheese.',
	              question: 'What do I smell?',
	              comprehensionHint: 'Find the smell sentence.',
	              answers: [
	                { name: 'Cheese', icon: 'ðŸ§€' },
	                { name: 'Soap', icon: 'ðŸ§¼' },
	                { name: 'Flowers', icon: 'ðŸŒ¸' },
	              ],
	              correctAnswerName: 'Cheese',
	              successMessage: 'Yes! I smell cheese.',
	              next: 'read_menu',
	            },
	            read_menu: {
	              type: 'read',
	              sceneImage: pizzaScene,
	              sentence: 'I see cheese pizza. I see veggie pizza. I see pineapple pizza. I want to pick one.',
	              sightWordFocus: 'see',
	              autoSightWordQuestion: false,
	              next: 'choice_size',
	            },
	            choice_size: {
	              type: 'menu',
	              storyChoice: true,
	              sceneImage: pizzaScene,
	              prompt: 'Pick a size!',
	              menuStory: 'Choose a size for your pizza.',
	              items: [
	                { name: 'One slice', icon: 'ðŸ•', description: 'Just one', next: 'read_topping', setFlags: { size: 'slice' } },
	                { name: 'Small pizza', icon: 'ðŸ•', description: 'A small one', next: 'read_topping', setFlags: { size: 'small' } },
	                { name: 'Big pizza', icon: 'ðŸ•', description: 'A big one', next: 'read_topping', setFlags: { size: 'big' } },
	              ],
	            },
	            read_topping: {
	              type: 'read',
	              sceneImage: pizzaScene,
	              sentence: 'Now I pick a topping.',
	              sightWordFocus: 'now',
	              autoSightWordQuestion: false,
	              next: 'choice_topping',
	            },
	            choice_topping: {
	              type: 'menu',
	              storyChoice: true,
	              sceneImage: pizzaScene,
	              prompt: 'Pick a topping!',
	              menuStory: 'Think about the story: cheese, veggie, pineapple.',
	              items: [
	                { name: 'Cheese', icon: 'ðŸ§€', description: 'Melty cheese', next: 'read_wait', setFlags: { topping: 'cheese' } },
	                { name: 'Veggie', icon: 'ðŸ¥¦', description: 'Green veggies', next: 'read_wait', setFlags: { topping: 'veggie' } },
	                { name: 'Pineapple', icon: 'ðŸ', description: 'Sweet fruit', next: 'read_wait', setFlags: { topping: 'pineapple' } },
	              ],
	            },
	            read_wait: {
	              type: 'read',
	              sceneImage: pizzaScene,
	              sentence: 'The cook puts my pizza in the oven. I have to wait.',
	              sightWordFocus: 'my',
	              autoSightWordQuestion: false,
	              next: 'choice_wait',
	            },
	            choice_wait: {
	              type: 'menu',
	              storyChoice: true,
	              sceneImage: pizzaScene,
	              prompt: 'What will you do while you wait?',
	              menuStory: 'Pick a calm choice.',
	              items: [
	                { name: 'Watch the oven', icon: 'ðŸ‘€', description: 'Look quietly', next: 'read_cut', setFlags: { wait: 'watch' } },
	                { name: 'Sit down', icon: 'ðŸª‘', description: 'Rest', next: 'read_cut', setFlags: { wait: 'sit' } },
	                { name: 'Take deep breaths', icon: 'ðŸ«§', description: 'Breathe', next: 'read_cut', setFlags: { wait: 'breathe' } },
	              ],
	            },
	            read_cut: {
	              type: 'read',
	              sceneImage: pizzaScene,
	              sentence: 'Ding! The pizza is ready. The cook can cut it.',
	              sightWordFocus: 'can',
	              autoSightWordQuestion: false,
	              next: 'choice_cut',
	            },
	            choice_cut: {
	              type: 'menu',
	              storyChoice: true,
	              sceneImage: pizzaScene,
	              prompt: 'How should it be cut?',
	              menuStory: 'Choose a shape.',
	              items: [
	                { name: 'Triangles', icon: 'ðŸ”º', description: 'Pizza slices', next: 'read_dip', setFlags: { cut: 'triangles' } },
	                { name: 'Squares', icon: 'â¬›', description: 'Little squares', next: 'read_dip', setFlags: { cut: 'squares' } },
	                { name: 'No cut', icon: 'ðŸ«“', description: 'Fold it', next: 'read_dip', setFlags: { cut: 'none' } },
	              ],
	            },
	            read_dip: {
	              type: 'read',
	              sceneImage: pizzaScene,
	              sentence: 'I can pick a dip.',
	              sightWordFocus: 'can',
	              autoSightWordQuestion: false,
	              next: 'choice_dip',
	            },
	            choice_dip: {
	              type: 'menu',
	              storyChoice: true,
	              sceneImage: pizzaScene,
	              prompt: 'Pick a dip!',
	              menuStory: 'Choose one dip.',
	              items: [
	                { name: 'Tomato dip', icon: 'ðŸ…', description: 'Red dip', next: 'read_drink', setFlags: { dip: 'tomato' } },
	                { name: 'Cheese dip', icon: 'ðŸ§€', description: 'Yellow dip', next: 'read_drink', setFlags: { dip: 'cheese' } },
	                { name: 'No dip', icon: 'ðŸ™‚', description: 'Just pizza', next: 'read_drink', setFlags: { dip: 'none' } },
	              ],
	            },
	            read_drink: {
	              type: 'read',
	              sceneImage: pizzaScene,
	              sentence: 'I also need a drink.',
	              sightWordFocus: 'need',
	              autoSightWordQuestion: false,
	              next: 'choice_drink',
	            },
	            choice_drink: {
	              type: 'menu',
	              storyChoice: true,
	              sceneImage: pizzaScene,
	              prompt: 'Pick a drink!',
	              menuStory: 'Choose one drink.',
	              items: [
	                { name: 'Water', icon: 'ðŸ’§', description: 'Cold water', next: 'read_share', setFlags: { drink: 'water' } },
	                { name: 'Juice', icon: 'ðŸ§ƒ', description: 'Sweet juice', next: 'read_share', setFlags: { drink: 'juice' } },
	                { name: 'Milk', icon: 'ðŸ¥›', description: 'Cold milk', next: 'read_share', setFlags: { drink: 'milk' } },
	              ],
	            },
	            read_share: {
	              type: 'read',
	              sceneImage: pizzaScene,
	              sentence: 'I sit down with my pizza. It smells so good.',
	              sightWordFocus: 'my',
	              autoSightWordQuestion: false,
	              next: 'choice_share',
	            },
	            choice_share: {
	              type: 'menu',
	              storyChoice: true,
	              sceneImage: pizzaScene,
	              prompt: 'What will you do next?',
	              menuStory: 'Be a good friend.',
	              items: [
	                { name: 'Share a slice', icon: 'ðŸ¤', description: 'Share kindly', next: 'read_cleanup', setFlags: { share: true } },
	                { name: 'Save it', icon: 'ðŸ§¡', description: 'Keep it for me', next: 'read_cleanup', setFlags: { share: false } },
	                { name: 'Ask first', icon: 'â“', description: 'Use kind words', next: 'read_cleanup', setFlags: { share: 'ask' } },
	              ],
	            },
	            read_cleanup: {
	              type: 'read',
	              sceneImage: pizzaScene,
	              sentence: 'All done. I have a crust.',
	              sightWordFocus: 'a',
	              autoSightWordQuestion: false,
	              next: 'choice_cleanup',
	            },
	            choice_cleanup: {
	              type: 'menu',
	              storyChoice: true,
	              sceneImage: pizzaScene,
	              prompt: 'What do you do with the box?',
	              menuStory: 'Use a clean choice.',
	              items: [
	                { name: 'Trash can', icon: 'ðŸ—‘ï¸', description: 'Throw it away', next: 'router_end', setFlags: { clean: 'trash' } },
	                { name: 'Take home', icon: 'ðŸ“¦', description: 'Save the box', next: 'router_end', setFlags: { clean: 'home' } },
	                { name: 'Recycle', icon: 'â™»ï¸', description: 'Recycle it', next: 'router_end', setFlags: { clean: 'recycle' } },
	              ],
	            },
	            router_end: {
	              type: 'router',
	              routes: [
	                { when: (flags) => flags.share === true || flags.share === 'ask', next: 'ending_party' },
	                { when: (flags) => flags.topping === 'veggie', next: 'ending_veggie' },
	                { when: (flags) => flags.topping === 'pineapple', next: 'ending_pineapple' },
	                { when: () => true, next: 'ending_cheese' },
	              ],
	            },
	            ending_party: {
	              type: 'read',
	              sceneImage: pizzaScene,
	              sentence: 'My pizza story ends with sharing. I say thank you. Pizza time is fun!',
	              endingId: 'pizza_party',
	              endingTitle: 'Pizza Party',
	              endingSummary: 'You shared pizza and used kind words.',
	              sightWordFocus: 'my',
	              autoSightWordQuestion: false,
	            },
	            ending_veggie: {
	              type: 'read',
	              sceneImage: pizzaScene,
	              sentence: 'My pizza story ends with veggie pizza. Crunch! Yum!',
	              endingId: 'pizza_veggie',
	              endingTitle: 'Veggie Crunch',
	              endingSummary: 'You picked veggie pizza and ate calmly.',
	              sightWordFocus: 'my',
	              autoSightWordQuestion: false,
	            },
	            ending_pineapple: {
	              type: 'read',
	              sceneImage: pizzaScene,
	              sentence: 'My pizza story ends with pineapple pizza. Sweet and yummy!',
	              endingId: 'pizza_pineapple',
	              endingTitle: 'Pineapple Sweet',
	              endingSummary: 'You picked pineapple pizza and enjoyed a sweet bite.',
	              sightWordFocus: 'my',
	              autoSightWordQuestion: false,
	            },
	            ending_cheese: {
	              type: 'read',
	              sceneImage: pizzaScene,
	              sentence: 'My pizza story ends with cheese pizza. It is melty. Yum!',
	              endingId: 'pizza_cheese',
	              endingTitle: 'Cheese Smile',
	              endingSummary: 'You picked cheese pizza and smiled.',
	              sightWordFocus: 'is',
	              autoSightWordQuestion: false,
	            },
	          },
	        },

	        bubbletea: {
	          start: 'start',
	          nodes: {
	            start: {
	              type: 'read',
	              sceneImage: bubbleteaScene,
	              sentence: 'I am at the bubble tea shop. I see cups and straws. I hear ice shake. I want a drink.',
	              sightWordFocus: 'want',
	              next: 'q_where',
	            },
	            q_where: {
	              type: 'question',
	              sceneImage: bubbleteaScene,
	              questionType: 'comprehension',
	              questionMode: 'multipleChoice',
	              passage: 'I am at the bubble tea shop.',
	              question: 'Where am I?',
	              comprehensionHint: 'Find the place name.',
	              answers: [
	                { name: 'Bubble Tea Shop', icon: 'ðŸ§‹' },
	                { name: 'Bakery', icon: 'ðŸ§' },
	                { name: 'Pizza Place', icon: 'ðŸ•' },
	              ],
	              correctAnswerName: 'Bubble Tea Shop',
	              successMessage: 'Yes! The story happens at the bubble tea shop.',
	              next: 'q_hear',
	            },
	            q_hear: {
	              type: 'question',
	              sceneImage: bubbleteaScene,
	              questionType: 'comprehension',
	              questionMode: 'multipleChoice',
	              passage: 'I hear ice shake.',
	              question: 'What do I hear?',
	              comprehensionHint: 'Find the hear sentence.',
	              answers: [
	                { name: 'Ice shake', icon: 'ðŸ§Š' },
	                { name: 'Birds', icon: 'ðŸ¦' },
	                { name: 'Rain', icon: 'ðŸŒ§ï¸' },
	              ],
	              correctAnswerName: 'Ice shake',
	              successMessage: 'Yes! I hear ice shake.',
	              next: 'read_counter',
	            },
	            read_counter: {
	              type: 'read',
	              sceneImage: bubbleteaScene,
	              sentence: 'The worker smiles at me. The worker can help me.',
	              sightWordFocus: 'can',
	              autoSightWordQuestion: false,
	              next: 'choice_words',
	            },
	            choice_words: {
	              type: 'menu',
	              storyChoice: true,
	              sceneImage: bubbleteaScene,
	              prompt: 'What will you say?',
	              menuStory: 'Be kind at the bubble tea shop.',
	              items: [
	                { name: 'Hello', icon: 'ðŸ‘‹', description: 'Say hi', next: 'read_menu', setFlags: { greet: 'hello' } },
	                { name: 'Please', icon: 'ðŸ™', description: 'Ask nicely', next: 'read_menu', setFlags: { greet: 'please' } },
	                { name: 'Thank you', icon: 'ðŸ’›', description: 'Be grateful', next: 'read_menu', setFlags: { greet: 'thanks' } },
	              ],
	            },
	            read_menu: {
	              type: 'read',
	              sceneImage: bubbleteaScene,
	              sentence: 'I look at the tea menu.',
	              sightWordFocus: 'at',
	              autoSightWordQuestion: false,
	              next: 'choice_base',
	            },
	            choice_base: {
	              type: 'menu',
	              storyChoice: true,
	              sceneImage: bubbleteaScene,
	              prompt: 'Pick your tea!',
	              menuStory: 'Choose one drink.',
	              items: [
	                { name: 'Milk tea', icon: 'ðŸ§‹', description: 'Creamy', next: 'read_sweet', setFlags: { tea: 'milk' } },
	                { name: 'Green tea', icon: 'ðŸµ', description: 'Fresh', next: 'read_sweet', setFlags: { tea: 'green' } },
	                { name: 'Fruit tea', icon: 'ðŸ“', description: 'Sweet', next: 'read_sweet', setFlags: { tea: 'fruit' } },
	              ],
	            },
	            read_sweet: {
	              type: 'read',
	              sceneImage: bubbleteaScene,
	              sentence: 'Now I can pick sweetness.',
	              sightWordFocus: 'can',
	              autoSightWordQuestion: false,
	              next: 'choice_sweet',
	            },
	            choice_sweet: {
	              type: 'menu',
	              storyChoice: true,
	              sceneImage: bubbleteaScene,
	              prompt: 'How sweet?',
	              menuStory: 'Pick a sweetness level.',
	              items: [
	                { name: 'Less sweet', icon: 'ðŸ™‚', description: 'A little sweet', next: 'read_ice', setFlags: { sweet: 'less' } },
	                { name: 'Regular', icon: 'âœ¨', description: 'Just right', next: 'read_ice', setFlags: { sweet: 'regular' } },
	                { name: 'Extra sweet', icon: 'ðŸ¬', description: 'Very sweet', next: 'read_ice', setFlags: { sweet: 'extra' } },
	              ],
	            },
	            read_ice: {
	              type: 'read',
	              sceneImage: bubbleteaScene,
	              sentence: 'Now I can pick ice.',
	              sightWordFocus: 'can',
	              autoSightWordQuestion: false,
	              next: 'choice_ice',
	            },
	            choice_ice: {
	              type: 'menu',
	              storyChoice: true,
	              sceneImage: bubbleteaScene,
	              prompt: 'How much ice?',
	              menuStory: 'Pick what you like.',
	              items: [
	                { name: 'Lots of ice', icon: 'ðŸ§Š', description: 'Very cold', next: 'read_toppings', setFlags: { ice: 'lots' } },
	                { name: 'Little ice', icon: 'ðŸ§Š', description: 'A few cubes', next: 'read_toppings', setFlags: { ice: 'little' } },
	                { name: 'No ice', icon: 'ðŸ™‚', description: 'No cubes', next: 'read_toppings', setFlags: { ice: 'none' } },
	              ],
	            },
	            read_toppings: {
	              type: 'read',
	              sceneImage: bubbleteaScene,
	              sentence: 'Now I can pick a topping. The topping goes in the cup.',
	              sightWordFocus: 'can',
	              autoSightWordQuestion: false,
	              next: 'choice_topping',
	            },
	            choice_topping: {
	              type: 'menu',
	              storyChoice: true,
	              sceneImage: bubbleteaScene,
	              prompt: 'Pick a topping!',
	              menuStory: 'Choose what you like.',
	              items: [
	                { name: 'Boba', icon: 'âš«', description: 'Chewy balls', next: 'read_straw', setFlags: { topping: 'boba' } },
	                { name: 'Jelly', icon: 'ðŸŸ©', description: 'Wiggly cubes', next: 'read_straw', setFlags: { topping: 'jelly' } },
	                { name: 'No topping', icon: 'ðŸ™‚', description: 'Just tea', next: 'read_straw', setFlags: { topping: 'none' } },
	              ],
	            },
	            read_straw: {
	              type: 'read',
	              sceneImage: bubbleteaScene,
	              sentence: 'The worker seals the cup. I pick a straw.',
	              sightWordFocus: 'the',
	              autoSightWordQuestion: false,
	              next: 'choice_straw',
	            },
	            choice_straw: {
	              type: 'menu',
	              storyChoice: true,
	              sceneImage: bubbleteaScene,
	              prompt: 'Pick a straw!',
	              menuStory: 'Think about boba and ice.',
	              items: [
	                { name: 'Big straw', icon: 'ðŸŸ¦', description: 'For boba', next: 'read_place', setFlags: { straw: 'big' } },
	                { name: 'Small straw', icon: 'ðŸŸ¨', description: 'For tea', next: 'read_place', setFlags: { straw: 'small' } },
	                { name: 'No straw (sip)', icon: 'ðŸ¥¤', description: 'Sip slowly', next: 'read_place', setFlags: { straw: 'sip' } },
	              ],
	            },
	            read_place: {
	              type: 'read',
	              sceneImage: bubbleteaScene,
	              sentence: 'My drink is ready. I need a calm place to sip.',
	              sightWordFocus: 'my',
	              autoSightWordQuestion: false,
	              next: 'choice_place',
	            },
	            choice_place: {
	              type: 'menu',
	              storyChoice: true,
	              sceneImage: bubbleteaScene,
	              prompt: 'Where will you drink?',
	              menuStory: 'Pick a calm choice.',
	              items: [
	                { name: 'Small table', icon: 'ðŸª‘', description: 'Sit down', next: 'read_friend', setFlags: { place: 'table' } },
	                { name: 'By the window', icon: 'ðŸªŸ', description: 'Look out', next: 'read_friend', setFlags: { place: 'window' } },
	                { name: 'Outside air', icon: 'ðŸŒ¤', description: 'Cool breeze', next: 'read_friend', setFlags: { place: 'outside' } },
	              ],
	            },
	            read_friend: {
	              type: 'read',
	              sceneImage: bubbleteaScene,
	              sentence: 'A friend sees my drink and smiles.',
	              sightWordFocus: 'my',
	              autoSightWordQuestion: false,
	              next: 'choice_share',
	            },
	            choice_share: {
	              type: 'menu',
	              storyChoice: true,
	              sceneImage: bubbleteaScene,
	              prompt: 'What will you do next?',
	              menuStory: 'Be a good friend.',
	              items: [
	                { name: 'Share a sip', icon: 'ðŸ¤', description: 'Share kindly', next: 'read_cleanup', setFlags: { share: true } },
	                { name: 'Save it', icon: 'ðŸ§¡', description: 'Keep it for me', next: 'read_cleanup', setFlags: { share: false } },
	                { name: 'Ask first', icon: 'â“', description: 'Use kind words', next: 'read_cleanup', setFlags: { share: 'ask' } },
	              ],
	            },
	            read_cleanup: {
	              type: 'read',
	              sceneImage: bubbleteaScene,
	              sentence: 'All done. I have an empty cup.',
	              sightWordFocus: 'an',
	              autoSightWordQuestion: false,
	              next: 'choice_cleanup',
	            },
	            choice_cleanup: {
	              type: 'menu',
	              storyChoice: true,
	              sceneImage: bubbleteaScene,
	              prompt: 'What do you do with the cup?',
	              menuStory: 'Use a clean choice.',
	              items: [
	                { name: 'Recycle', icon: 'â™»ï¸', description: 'Put it in recycle', next: 'router_end', setFlags: { clean: 'recycle' } },
	                { name: 'Trash', icon: 'ðŸ—‘ï¸', description: 'Throw it away', next: 'router_end', setFlags: { clean: 'trash' } },
	                { name: 'Keep it', icon: 'ðŸ§‹', description: 'Take it home', next: 'router_end', setFlags: { clean: 'keep' } },
	              ],
	            },
	            router_end: {
	              type: 'router',
	              routes: [
	                { when: (flags) => flags.share === true || flags.share === 'ask', next: 'ending_friend' },
	                { when: (flags) => flags.tea === 'fruit', next: 'ending_fruit' },
	                { when: (flags) => flags.tea === 'green', next: 'ending_green' },
	                { when: () => true, next: 'ending_milk' },
	              ],
	            },
	            ending_friend: {
	              type: 'read',
	              sceneImage: bubbleteaScene,
	              sentence: 'My bubble tea story ends with sharing. I use kind words. I smile.',
	              endingId: 'bubbletea_friend',
	              endingTitle: 'Kind Boba',
	              endingSummary: 'You shared bubble tea and used kind words.',
	              sightWordFocus: 'my',
	              autoSightWordQuestion: false,
	            },
	            ending_fruit: {
	              type: 'read',
	              sceneImage: bubbleteaScene,
	              sentence: 'My bubble tea story ends with fruit tea. It is sweet and fresh.',
	              endingId: 'bubbletea_fruit',
	              endingTitle: 'Fruit Tea',
	              endingSummary: 'You picked fruit tea and drank calmly.',
	              sightWordFocus: 'is',
	              autoSightWordQuestion: false,
	            },
	            ending_green: {
	              type: 'read',
	              sceneImage: bubbleteaScene,
	              sentence: 'My bubble tea story ends with green tea. I feel calm.',
	              endingId: 'bubbletea_green',
	              endingTitle: 'Green Tea Calm',
	              endingSummary: 'You picked green tea and felt calm.',
	              sightWordFocus: 'my',
	              autoSightWordQuestion: false,
	            },
	            ending_milk: {
	              type: 'read',
	              sceneImage: bubbleteaScene,
	              sentence: 'My bubble tea story ends with milk tea. Yum!',
	              endingId: 'bubbletea_milk',
	              endingTitle: 'Milk Tea Yum',
	              endingSummary: 'You picked milk tea and enjoyed it.',
	              sightWordFocus: 'my',
	              autoSightWordQuestion: false,
	            },
	          },
	        },

	        icecream: {
	          start: 'start',
	          nodes: {
	            start: {
	              type: 'read',
	              sceneImage: icecreamScene,
	              sentence: 'I am at the ice cream shop. It is cold inside. I want a sweet treat.',
	              sightWordFocus: 'want',
	              next: 'q_where',
	            },
	            q_where: {
	              type: 'question',
	              sceneImage: icecreamScene,
	              questionType: 'comprehension',
	              questionMode: 'multipleChoice',
	              passage: 'I am at the ice cream shop.',
	              question: 'Where am I?',
	              comprehensionHint: 'Find the place name.',
	              answers: [
	                { name: 'Ice Cream Shop', icon: 'ðŸ¦' },
	                { name: 'Noodle House', icon: 'ðŸœ' },
	                { name: 'Fruit Stand', icon: 'ðŸŽ' },
	              ],
	              correctAnswerName: 'Ice Cream Shop',
	              successMessage: 'Yes! The story happens at the ice cream shop.',
	              next: 'q_cold',
	            },
	            q_cold: {
	              type: 'question',
	              sceneImage: icecreamScene,
	              questionType: 'comprehension',
	              questionMode: 'multipleChoice',
	              passage: 'It is cold inside.',
	              question: 'What is it like inside?',
	              comprehensionHint: 'Find the describing word.',
	              answers: [
	                { name: 'Cold', icon: 'ðŸ§Š' },
	                { name: 'Hot', icon: 'ðŸ”¥' },
	                { name: 'Loud', icon: 'ðŸ“£' },
	              ],
	              correctAnswerName: 'Cold',
	              successMessage: 'Yes! It is cold inside.',
	              next: 'read_line',
	            },
	            read_line: {
	              type: 'read',
	              sceneImage: icecreamScene,
	              sentence: 'I stand in line. The worker smiles.',
	              sightWordFocus: 'in',
	              autoSightWordQuestion: false,
	              next: 'choice_words',
	            },
	            choice_words: {
	              type: 'menu',
	              storyChoice: true,
	              sceneImage: icecreamScene,
	              prompt: 'What will you say?',
	              menuStory: 'Be kind at the ice cream shop.',
	              items: [
	                { name: 'Hello', icon: 'ðŸ‘‹', description: 'Say hi', next: 'read_container', setFlags: { greet: 'hello' } },
	                { name: 'Please', icon: 'ðŸ™', description: 'Ask nicely', next: 'read_container', setFlags: { greet: 'please' } },
	                { name: 'Thank you', icon: 'ðŸ’›', description: 'Be grateful', next: 'read_container', setFlags: { greet: 'thanks' } },
	              ],
	            },
	            read_container: {
	              type: 'read',
	              sceneImage: icecreamScene,
	              sentence: 'I can get a cone or a cup.',
	              sightWordFocus: 'can',
	              autoSightWordQuestion: false,
	              next: 'choice_container',
	            },
	            choice_container: {
	              type: 'menu',
	              storyChoice: true,
	              sceneImage: icecreamScene,
	              prompt: 'Cone or cup?',
	              menuStory: 'Choose one.',
	              items: [
	                { name: 'Cone', icon: 'ðŸ¦', description: 'Hold a cone', next: 'read_flavor', setFlags: { container: 'cone' } },
	                { name: 'Cup', icon: 'ðŸ¥£', description: 'Use a cup', next: 'read_flavor', setFlags: { container: 'cup' } },
	                { name: 'Sandwich', icon: 'ðŸª', description: 'Ice cream sandwich', next: 'read_flavor', setFlags: { container: 'sandwich' } },
	              ],
	            },
	            read_flavor: {
	              type: 'read',
	              sceneImage: icecreamScene,
	              sentence: 'I see three flavors. Vanilla. Chocolate. Strawberry.',
	              sightWordFocus: 'see',
	              autoSightWordQuestion: false,
	              next: 'choice_flavor',
	            },
	            choice_flavor: {
	              type: 'menu',
	              storyChoice: true,
	              sceneImage: icecreamScene,
	              prompt: 'Pick a flavor!',
	              menuStory: 'Choose one flavor.',
	              items: [
	                { name: 'Vanilla', icon: 'ðŸ¦', description: 'Soft and plain', next: 'read_scoops', setFlags: { flavor: 'vanilla' } },
	                { name: 'Chocolate', icon: 'ðŸ«', description: 'Dark and sweet', next: 'read_scoops', setFlags: { flavor: 'chocolate' } },
	                { name: 'Strawberry', icon: 'ðŸ“', description: 'Pink and fruity', next: 'read_scoops', setFlags: { flavor: 'strawberry' } },
	              ],
	            },
	            read_scoops: {
	              type: 'read',
	              sceneImage: icecreamScene,
	              sentence: 'The worker can make one scoop or two scoops.',
	              sightWordFocus: 'can',
	              autoSightWordQuestion: false,
	              next: 'choice_scoops',
	            },
	            choice_scoops: {
	              type: 'menu',
	              storyChoice: true,
	              sceneImage: icecreamScene,
	              prompt: 'How many scoops?',
	              menuStory: 'Pick a number.',
	              items: [
	                { name: 'One scoop', icon: '1ï¸âƒ£', description: 'One scoop', next: 'read_topping', setFlags: { scoops: 1 } },
	                { name: 'Two scoops', icon: '2ï¸âƒ£', description: 'Two scoops', next: 'read_topping', setFlags: { scoops: 2 } },
	                { name: 'Tiny scoop', icon: 'ðŸ¤', description: 'A small scoop', next: 'read_topping', setFlags: { scoops: 0 } },
	              ],
	            },
	            read_topping: {
	              type: 'read',
	              sceneImage: icecreamScene,
	              sentence: 'Now I can pick a topping.',
	              sightWordFocus: 'can',
	              autoSightWordQuestion: false,
	              next: 'choice_topping',
	            },
	            choice_topping: {
	              type: 'menu',
	              storyChoice: true,
	              sceneImage: icecreamScene,
	              prompt: 'Pick a topping!',
	              menuStory: 'Choose what sounds best.',
	              items: [
	                { name: 'Sprinkles', icon: 'âœ¨', description: 'Colorful dots', next: 'read_melt', setFlags: { topping: 'sprinkles' } },
	                { name: 'Cookie', icon: 'ðŸª', description: 'Crunchy bites', next: 'read_melt', setFlags: { topping: 'cookie' } },
	                { name: 'No topping', icon: 'ðŸ™‚', description: 'Just ice cream', next: 'read_melt', setFlags: { topping: 'none' } },
	              ],
	            },
	            read_melt: {
	              type: 'read',
	              sceneImage: icecreamScene,
	              sentence: 'The ice cream starts to melt. I need a plan.',
	              sightWordFocus: 'need',
	              autoSightWordQuestion: false,
	              next: 'choice_melt',
	            },
	            choice_melt: {
	              type: 'menu',
	              storyChoice: true,
	              sceneImage: icecreamScene,
	              prompt: 'What will you do?',
	              menuStory: 'Pick a helpful choice.',
	              items: [
	                { name: 'Eat slowly', icon: 'ðŸ¢', description: 'Small bites', next: 'read_place', setFlags: { melt: 'slow' } },
	                { name: 'Eat faster', icon: 'ðŸƒ', description: 'Quick bites', next: 'read_place', setFlags: { melt: 'fast' } },
	                { name: 'Ask for a napkin', icon: 'ðŸ§»', description: 'Stay clean', next: 'read_place', setFlags: { melt: 'napkin' } },
	              ],
	            },
	            read_place: {
	              type: 'read',
	              sceneImage: icecreamScene,
	              sentence: 'Now I pick a calm place to eat.',
	              sightWordFocus: 'now',
	              autoSightWordQuestion: false,
	              next: 'choice_place',
	            },
	            choice_place: {
	              type: 'menu',
	              storyChoice: true,
	              sceneImage: icecreamScene,
	              prompt: 'Where will you eat?',
	              menuStory: 'Pick a calm choice.',
	              items: [
	                { name: 'Small table', icon: 'ðŸª‘', description: 'Sit down', next: 'read_friend', setFlags: { place: 'table' } },
	                { name: 'Outside air', icon: 'ðŸŒ¤', description: 'Cool breeze', next: 'read_friend', setFlags: { place: 'outside' } },
	                { name: 'Near the window', icon: 'ðŸªŸ', description: 'Look out', next: 'read_friend', setFlags: { place: 'window' } },
	              ],
	            },
	            read_friend: {
	              type: 'read',
	              sceneImage: icecreamScene,
	              sentence: 'A friend smiles at me. My ice cream looks so good.',
	              sightWordFocus: 'my',
	              autoSightWordQuestion: false,
	              next: 'choice_share',
	            },
	            choice_share: {
	              type: 'menu',
	              storyChoice: true,
	              sceneImage: icecreamScene,
	              prompt: 'What will you do next?',
	              menuStory: 'Be a good friend.',
	              items: [
	                { name: 'Share a bite', icon: 'ðŸ¤', description: 'Share kindly', next: 'read_cleanup', setFlags: { share: true } },
	                { name: 'Save it', icon: 'ðŸ§¡', description: 'Keep it for me', next: 'read_cleanup', setFlags: { share: false } },
	                { name: 'Ask first', icon: 'â“', description: 'Use kind words', next: 'read_cleanup', setFlags: { share: 'ask' } },
	              ],
	            },
	            read_cleanup: {
	              type: 'read',
	              sceneImage: icecreamScene,
	              sentence: 'All done. I have a cup or wrapper.',
	              sightWordFocus: 'a',
	              autoSightWordQuestion: false,
	              next: 'choice_cleanup',
	            },
	            choice_cleanup: {
	              type: 'menu',
	              storyChoice: true,
	              sceneImage: icecreamScene,
	              prompt: 'What do you do with it?',
	              menuStory: 'Use a clean choice.',
	              items: [
	                { name: 'Trash can', icon: 'ðŸ—‘ï¸', description: 'Throw it away', next: 'router_end', setFlags: { clean: 'trash' } },
	                { name: 'Recycle', icon: 'â™»ï¸', description: 'Recycle it', next: 'router_end', setFlags: { clean: 'recycle' } },
	                { name: 'Take home', icon: 'ðŸ ', description: 'Save it', next: 'router_end', setFlags: { clean: 'home' } },
	              ],
	            },
	            router_end: {
	              type: 'router',
	              routes: [
	                { when: (flags) => flags.share === true || flags.share === 'ask', next: 'ending_share' },
	                { when: (flags) => flags.flavor === 'strawberry', next: 'ending_pink' },
	                { when: (flags) => flags.container === 'cone', next: 'ending_cone' },
	                { when: () => true, next: 'ending_sweet' },
	              ],
	            },
	            ending_share: {
	              type: 'read',
	              sceneImage: icecreamScene,
	              sentence: 'My ice cream story ends with sharing. I say thank you. I feel happy.',
	              endingId: 'icecream_share',
	              endingTitle: 'Sharing Scoop',
	              endingSummary: 'You shared ice cream and used kind words.',
	              sightWordFocus: 'my',
	              autoSightWordQuestion: false,
	            },
	            ending_pink: {
	              type: 'read',
	              sceneImage: icecreamScene,
	              sentence: 'My ice cream story ends with strawberry. It is pink and sweet. Yum!',
	              endingId: 'icecream_pink',
	              endingTitle: 'Pink Scoop',
	              endingSummary: 'You picked strawberry and enjoyed a sweet treat.',
	              sightWordFocus: 'is',
	              autoSightWordQuestion: false,
	            },
	            ending_cone: {
	              type: 'read',
	              sceneImage: icecreamScene,
	              sentence: 'My ice cream story ends with a cone. I hold it and take small licks.',
	              endingId: 'icecream_cone',
	              endingTitle: 'Cone Time',
	              endingSummary: 'You picked a cone and ate calmly.',
	              sightWordFocus: 'a',
	              autoSightWordQuestion: false,
	            },
	            ending_sweet: {
	              type: 'read',
	              sceneImage: icecreamScene,
	              sentence: 'My ice cream story ends with a sweet scoop. I smile. Ice cream time is the best!',
	              endingId: 'icecream_sweet',
	              endingTitle: 'Ice Cream Smile',
	              endingSummary: 'You made a sweet ice cream choice.',
	              sightWordFocus: 'my',
	              autoSightWordQuestion: false,
	            },
	          },
	        },
	      };
	    })();

    function getFoodStoryGraph(stationId) {
      const id = String(stationId || '');
      if (!isFoodStoryPilotStation(id)) return null;
      const graph = FOOD_STORY_GRAPHS[id];
      if (!graph || typeof graph !== 'object') return null;
      if (!graph.nodes || typeof graph.nodes !== 'object') return null;
      if (!graph.start || typeof graph.start !== 'string') return null;
      return graph;
    }

    function resolveStoryRouterNext(routerNode, flags) {
      const routes = routerNode && Array.isArray(routerNode.routes) ? routerNode.routes : [];
      for (const route of routes) {
        try {
          if (route && typeof route.when === 'function' && route.when(flags)) return route.next || null;
        } catch (e) {
          // ignore and keep trying
        }
      }
      return null;
    }

    function buildStoryPagesFromNode({ stationId, graph, startNodeId, flags, stopAtChoice = true }) {
      const pages = [];
      let nodeId = startNodeId;
      const safeFlags = flags && typeof flags === 'object' ? flags : {};

      for (let guard = 0; guard < 200 && nodeId; guard++) {
        const node = graph.nodes[nodeId];
        if (!node) break;

        if (node.type === 'router') {
          nodeId = resolveStoryRouterNext(node, safeFlags);
          continue;
        }

        const page = { ...node, _storyNodeId: nodeId, _storyStationId: stationId };
        if (typeof node.next === 'string') page._storyNextNodeId = node.next;

        if (page.type === 'menu' && page.storyChoice) {
          page.items = (Array.isArray(page.items) ? page.items : []).map(item => ({
            ...item,
            _storyNextNodeId: item && typeof item.next === 'string' ? item.next : null,
            _storySetFlags: item && item.setFlags && typeof item.setFlags === 'object' ? item.setFlags : null,
          }));
        }

        pages.push(page);

        if (stopAtChoice && page.type === 'menu' && page.storyChoice) break;
        nodeId = typeof node.next === 'string' ? node.next : null;
      }

      return pages;
    }

    function buildStorySessionPagesForStation(stationId, storyGraph) {
      const station = stationContent[stationId];
      const flags = (state.storySession && state.storySession.stationId === stationId && state.storySession.flags)
        ? state.storySession.flags
        : {};

      // Start from the story graph until the first choice (or ending).
      const pages = buildStoryPagesFromNode({
        stationId,
        graph: storyGraph,
        startNodeId: storyGraph.start,
        flags,
        stopAtChoice: true,
      });

      // Safety: if the graph is empty, fall back to legacy station pages.
      if (!Array.isArray(pages) || pages.length === 0) {
        return station && Array.isArray(station.pages) ? station.pages : null;
      }

      return pages;
    }

    function ensureStoryProgressEntry(stationId) {
      const id = String(stationId || '');
      state.storyProgress = normalizeStoryProgress(state.storyProgress);
      if (!state.storyProgress.stations[id]) {
        state.storyProgress.stations[id] = { endingsUnlocked: [], playCount: 0, compCorrect: 0, compTotal: 0 };
      }
      return state.storyProgress.stations[id];
    }

    function beginStorySessionIfNeeded(stationId) {
      const id = String(stationId || '');
      if (!isFoodStoryPilotStation(id)) {
        state.storySession = null;
        return;
      }

      const entry = ensureStoryProgressEntry(id);
      entry.playCount += 1;

      state.storySession = {
        stationId: id,
        flags: {},
        path: [],
        endingId: null,
        endingTitle: null,
        endingSummary: null,
        startedAt: getSyncNowMs(),
      };
    }

    function clearStorySession() {
      state.storySession = null;
    }

    function applyStoryChoiceSelection({ page, item }) {
      const stationId = String(state.currentStation || '');
      const graph = getFoodStoryGraph(stationId);
      if (!graph || !state.storySession || state.storySession.stationId !== stationId) return;
      if (!page || !page._storyNodeId) return;
      if (!item || !item._storyNextNodeId) return;

      // Update story flags and path for endings + recap.
      if (item._storySetFlags) {
        Object.assign(state.storySession.flags, item._storySetFlags);
      }
      state.storySession.path.push({
        nodeId: String(page._storyNodeId),
        choice: item && item.name ? String(item.name) : null,
        at: getSyncNowMs(),
      });

      // Replace everything after this choice with the chosen branch.
      const pages = getCurrentStationPages();
      const cutIndex = Math.max(0, Number(state.currentPage || 0) + 1);
      pages.splice(cutIndex);

      const branchPages = buildStoryPagesFromNode({
        stationId,
        graph,
        startNodeId: item._storyNextNodeId,
        flags: state.storySession.flags,
        stopAtChoice: true,
      });
      branchPages.forEach(p => pages.push(p));
      state.sessionPages = pages;
    }

    function isMathStation(stationId, station) {
      const id = String(stationId || '').toLowerCase();
      if (station && typeof station.mathFocus === 'string' && station.mathFocus.trim()) return true;

      const line = station && typeof station.line === 'string' ? station.line.trim().toUpperCase() : '';
      if (line === 'OA' || line === 'NBT' || line === 'MD' || line === 'G') return true;
      if (line === 'REVIEW' && id.startsWith('review_math')) return true;

      return (
        id.startsWith('oa_') ||
        id.startsWith('nbt_') ||
        id.startsWith('md_') ||
        id.startsWith('g_') ||
        id.startsWith('review_math')
      );
    }

    function buildSessionPagesForStation(stationId) {
      const station = stationContent[stationId];
      if (!station || !Array.isArray(station.pages)) return null;

      // Pilot mode: choose-your-adventure story stations use a branching story graph
      // instead of the legacy linear lesson pages.
      const storyGraph = getFoodStoryGraph(stationId);
      if (storyGraph) {
        return buildStorySessionPagesForStation(stationId, storyGraph);
      }

      const resolved = station.pages.map(page => {
        if (!page || !Array.isArray(page.variants) || page.variants.length === 0) return page;
        const variant = pickRandom(page.variants);
        if (!variant) return page;
        const merged = { ...page, ...variant };
        delete merged.variants;
        return merged;
      });

      // Link existing question pages to the most recent read page that contains their key sentence.
      const readCandidates = [];
      resolved.forEach((page, idx) => {
        if (!page || page.type !== 'read') return;
        const text = normalizeTextForMatch(getReadPageText(page));
        if (!text) return;
        readCandidates.push({ idx, text });
      });

      const linkedQuestionCounts = new Map();
      readCandidates.forEach(item => linkedQuestionCounts.set(item.idx, 0));

      resolved.forEach((page, idx) => {
        if (!page || page.type !== 'question') return;
        const keySentence = normalizeTextForMatch(page.passage || '');
        if (!keySentence) return;

        for (let j = readCandidates.length - 1; j >= 0; j--) {
          const candidate = readCandidates[j];
          if (candidate.idx >= idx) continue;
          if (!candidate.text.includes(keySentence)) continue;
          linkedQuestionCounts.set(candidate.idx, (linkedQuestionCounts.get(candidate.idx) || 0) + 1);
          break;
        }
      });

      // Build a coherent session flow:
      // - Resolve variants once per session
      // - Insert a quick, connected sight-word check the first time each focus sight word appears
      // - Ensure each reading passage gets at least 2 question opportunities
      const sessionPages = [];
      const seenFocusWords = new Set();
      const shouldAutoGenerateReadQuestions = !isMathStation(stationId, station);

      resolved.forEach((page, idx) => {
        sessionPages.push(page);
        if (!page || page.type !== 'read') return;
        if (!shouldAutoGenerateReadQuestions) return;

        let insertedQuestions = 0;
        if (page.sightWordFocus && page.autoSightWordQuestion !== false) {
          const focusWord = String(page.sightWordFocus || '').trim();
          const key = focusWord.toLowerCase();
          if (focusWord && !seenFocusWords.has(key)) {
            const check = buildSightWordCheckPage({
              station,
              sourceSentence: page.sentence || '',
              focusWord
            });
            if (check) {
              sessionPages.push(check);
              insertedQuestions += 1;
              seenFocusWords.add(key);
            }
          }
        }

        const existing = linkedQuestionCounts.get(idx) || 0;
        const total = existing + insertedQuestions;
        const needed = Math.max(0, MIN_QUESTIONS_PER_READING_PASSAGE - total);
        if (needed > 0) {
          const extras = buildExtraQuestionsForReadPage({ stationId, station, readPage: page, needed });
          extras.forEach(extra => sessionPages.push(extra));
        }
      });

      return sessionPages;
    }

    function splitSentenceIntoWords(sentence) {
      if (!sentence || typeof sentence !== 'string') return [];
      const matches = sentence.match(/\S+/g);
      return matches ? matches : [];
    }

    function getCurrentStationPages() {
      const station = stationContent[state.currentStation];
      if (!station) return [];
      const pages = Array.isArray(state.sessionPages) ? state.sessionPages : station.pages;
      return Array.isArray(pages) ? pages : [];
    }

    function getCurrentPage() {
      const pages = getCurrentStationPages();
      return pages[state.currentPage] || null;
    }

    // ===== BOOK CONTENT =====
    // EDUCATIONAL DESIGN PHILOSOPHY (Science of Reading aligned)
    //
    // FIVE PILLARS OF READING INSTRUCTION:
    // 1. PHONEMIC AWARENESS: Explicit sound-symbol teaching via teachWord feature
    // 2. PHONICS: Systematic progression from CVC to digraphs (SH, TH, CH)
    // 3. FLUENCY: "Read to Me" with word highlighting for modeling fluent reading
    // 4. VOCABULARY: Previewed words + sight word focus on each page
    // 5. COMPREHENSION: Recall questions linked to personal choices
    //
    // Progressive difficulty levels:
    // Level 1: CVC words, 4-5 word sentences (fruit, drink, bakery)
    //          - High-frequency sight words: I, see, a, the, is, my, want, like, can
    //          - Simple sentence structures
    // Level 2: Longer words, adjectives (pizza, ice cream)
    //          - 2-syllable words, compound words
    //          - More descriptive language
    // Level 3: Introduce digraphs - SH words (fish shop)
    //          - Explicit phonics: SH says "shh" like a secret
    //          - Word position awareness (start vs end)
    // Level 4: TH and CH digraphs (cheese shop, the noodle house)
    //          - Multiple digraphs in context
    //          - Longer passages with multiple sentences
    //
    // AUTISM-SPECIFIC ADAPTATIONS:
    // - Predictable story structure: Arrival -> Exploration -> Choice -> Enjoyment
    // - Literal language (no idioms)
    // - Visual supports (emoji images)
    // - Errorless learning (wrong answers guide to correct)
    // - Calm mode for sensory regulation

    // ===== FEEDBACK MESSAGES =====
    // Varied, encouraging messages for correct answers
    const correctFeedback = [
      { message: "Yes! Great job!", emoji: "star" },
      { message: "You got it! Amazing!", emoji: "celebrate" },
      { message: "That's right! Super!", emoji: "thumbsup" },
      { message: "Wow! You did it!", emoji: "wow" },
      { message: "Perfect! Well done!", emoji: "perfect" },
      { message: "Yes! You used the words!", emoji: "brain" },
      { message: "Hooray! You know it!", emoji: "party" },
      { message: "Great reading!", emoji: "book" }
    ];

    // Gentle, supportive messages for incorrect answers
    const incorrectFeedback = [
      { message: "Hmm, look at the words again. Try the {item}.", hint: "words" },
      { message: "Almost! Remember what you picked? It was the {item}.", hint: "memory" },
      { message: "Let's try again. You wanted the {item}.", hint: "retry" },
      { message: "Look carefully. The {item} is what you chose!", hint: "look" },
      { message: "Think back to your choice. It was the {item}!", hint: "think" }
    ];

    // Gentle, supportive messages for story-detail questions (not just "what did you pick?")
    const incorrectFeedbackStory = [
      { message: "Almost! Look back at the story. Try {item}.", hint: "story" },
      { message: "Let's check the hint sentence. The answer is {item}.", hint: "hint" },
      { message: "Good try. Remember the story detail: {item}.", hint: "remember" },
      { message: "Try again. The story says {item}.", hint: "story" },
      { message: "Look carefully. It's {item}.", hint: "look" }
    ];

    // Helper function to get random feedback
    function getRandomFeedback(isCorrect, itemName = '', context = 'choice') {
      if (isCorrect) {
        const feedback = correctFeedback[Math.floor(Math.random() * correctFeedback.length)];
        return feedback.message;
      } else {
        const bank = context === 'story' ? incorrectFeedbackStory : incorrectFeedback;
        const feedback = bank[Math.floor(Math.random() * bank.length)];
        return feedback.message.replace('{item}', itemName);
      }
    }

    const stationContent = {
      // ===== LEVEL 1: CVC WORDS, SIMPLE SENTENCES =====
      // Focus: High-frequency sight words (I, see, a, the, is, my, want, like, good, can)
      // Sentence length: 3-5 words
      // Story structure: Arrival -> Exploration -> Choice -> Enjoyment
      fruit: {
        name: 'Fruit Stand',
        icon: 'ðŸŽ',
        level: 1,
        floor: 3,
        stickers: ['ðŸŽ', 'ðŸŠ', 'ðŸŒ', 'â­'],
        // Level 1 Focus: CVC words (red, big) + high-frequency sight words
        // Phonics pattern: Short vowel sounds (a in apple, e in red)
        sightWords: ['I', 'see', 'a', 'the', 'is', 'my', 'want', 'like', 'can', 'good'],
        previewWords: [
          { word: 'apple', icon: 'ðŸŽ', isSightWord: false, phonicsNote: 'a-p-p-le' },
          { word: 'red', icon: 'ðŸ”´', isSightWord: false, phonicsNote: 'r-e-d (CVC)' },
          { word: 'want', icon: 'ðŸ‘†', isSightWord: true },
          { word: 'see', icon: 'ðŸ‘€', isSightWord: true }
        ],
        pages: [
          {
            type: 'read',
            image: 'ðŸš‚ðŸŽ',
            sentence: 'I am at the fruit stand. I see fruit on a big table. Red apples are in a bin. The apples are so red! Yellow bananas sit next to them. The bananas are so yellow! I can see oranges too. The fruit looks so good.',
            words: null,
            variants: [
              { sentence: 'I am at the fruit stand. I see fruit on the table. There is so much to see! Red apples are in a big bin. Yellow bananas sit next to them. I walk up close. The fruit looks so good.', words: null },
              { sentence: 'I am at the fruit stand. The fruit sits on the table. I look at all the colors! Red apples fill a big bin. Yellow bananas are next to them. I step up to see. The fruit looks so good.', words: null },
              { sentence: 'I am at the fruit stand. A table holds the fruit. I see so many kinds! Red apples are in a big bin. Yellow bananas sit by them. I walk up to the table. The fruit looks so good.', words: null }
            ],
            targetWords: ['I', 'am', 'at', 'the', 'fruit'],
            sightWordFocus: 'the',
            requireSightWordTap: true,
            readingTip: 'Tap the word the. Then find it in the sentence.'
          },
          {
            type: 'question',
            questionType: 'comprehension',
            questionMode: 'multipleChoice',
            passage: 'I am at the fruit stand.',
            question: 'Where does the story happen?',
            comprehensionHint: 'Read the sentence. What place is named?',
            variants: [
              { question: 'Where am I?', comprehensionHint: 'Read the sentence. What place is named?' },
              { question: 'What place am I at?', comprehensionHint: 'Read the first sentence again.' },
              { question: 'What is the setting?', comprehensionHint: 'The setting is where the story happens.' }
            ],
            answers: [
              { name: 'Fruit Stand', icon: 'ðŸŽ' },
              { name: 'Fruit Shop', icon: 'ðŸ›’' },
              { name: 'Fruit Store', icon: 'ðŸª' }
            ],
            correctAnswerName: 'Fruit Stand',
            successMessage: 'Yes! You found the setting.'
          },
          {
            type: 'read',
            image: 'ðŸŽðŸŠðŸŒ',
            sentence: 'I see the fruit. Red apples are big and round. Big oranges are next to them. Yellow bananas are long. All the fruit looks fresh! The red apples look best to me. I want to pick one.',
            words: null,
            variants: [
              { sentence: 'I see red apples. The red is so bright! I see big oranges. The oranges are so round! I see yellow bananas. The yellow is so pretty! I look at all the fruit. The apples look good. I want to get one.', words: null },
              { sentence: 'I see red apples. I like the red color! I see big oranges. The big ones look good! I see yellow bananas. The yellow is so nice! I count three kinds of fruit. The apples look the best. I want one.', words: null },
              { sentence: 'I see red apples. Red is my favorite! I see big oranges. They are so big and round! I see yellow bananas. Yellow is a happy color! The fruit looks good to me. I like the apples best. I want to eat one.', words: null }
            ],
            targetWords: ['see', 'red', 'apples', 'big', 'oranges', 'yellow', 'bananas'],
            sightWordFocus: 'see',
            readingTip: 'Notice the pattern. I see a color and a fruit. This helps us read faster.'
          },
          {
            type: 'question',
            questionType: 'comprehension',
            questionMode: 'multipleChoice',
            passage: 'I see yellow bananas.',
            question: 'Which fruit was yellow?',
            comprehensionHint: 'Find the color word. What fruit is next to it?',
            variants: [
              { question: 'What fruit was yellow in the story?', comprehensionHint: 'Read the sentence. Find the color word first.' },
              { question: 'Which fruit matches the words yellow bananas?', comprehensionHint: 'Read the sentence. Which fruit is yellow?' },
              { question: 'Yellow is a color. What fruit was yellow?', comprehensionHint: 'Two words go together. A color and a fruit.' }
            ],
            answers: [
              { name: 'Banana', icon: 'ðŸŒ' },
              { name: 'Lemon', icon: 'ðŸ‹' },
              { name: 'Mango', icon: 'ðŸ¥­' }
            ],
            correctAnswerName: 'Banana',
            successMessage: 'Yes! You remembered a detail from what you read.'
          },
          {
            type: 'read',
            image: 'ðŸ‘¦ðŸ¤”',
            sentence: 'I am hungry! My belly wants food. I want fruit. The fruit is fresh and good. I see apples. I see oranges. I see bananas. What will I pick? I think and think. I want the best one!',
            words: null,
            variants: [
              { sentence: 'I am hungry. I need a snack! I want to eat fruit. It looks so good. I think about what I like. Do I want red apples? Do I want big oranges? Do I want yellow bananas? I pick the one I like best.', words: null },
              { sentence: 'I am hungry. I can feel it! I want to eat fruit. The fruit is so nice. I take my time to choose. Red apples look good. Big oranges look good too. Yellow bananas look good also. I want to pick one now.', words: null },
              { sentence: 'I am hungry. My belly is empty! I want to eat fruit. The fruit smells good. I look at the table again. I see red apples. I see big oranges. I see yellow bananas. I think about what I want most.', words: null }
            ],
            targetWords: ['want', 'fruit', 'What'],
            sightWordFocus: 'want',
            readingTip: 'Tap want. Then find it in the sentence.'
          },
          {
            type: 'menu',
            prompt: 'Pick your fruit!',
            menuStory: 'The fruit looks so good. What fruit do you want?',
            variants: [
              { prompt: 'Choose one fruit.', menuStory: 'Read the choices. Then choose one fruit.' },
              { prompt: 'Which fruit will you buy?', menuStory: 'Think about the story: red apples, big oranges, yellow bananas.' },
              { prompt: 'Pick a fruit for your snack.', menuStory: 'Pick one fruit for your snack.' }
            ],
            items: [
              { name: 'Apple', icon: 'ðŸŽ', description: 'Red and round' },
              { name: 'Orange', icon: 'ðŸŠ', description: 'Big and juicy' },
              { name: 'Banana', icon: 'ðŸŒ', description: 'Yellow and sweet' }
            ]
          },
          {
            type: 'question',
            questionType: 'comprehension',
            questionMode: 'multipleChoice',
            passage: 'I see big oranges.',
            question: 'Which fruit was big?',
            comprehensionHint: 'Find the size word big.',
            variants: [
              { question: 'In the story, which fruit was big?', comprehensionHint: 'Read the sentence with big.' },
              { question: 'Which fruit matches the words big oranges?', comprehensionHint: 'Look for the size word big.' },
              { question: 'Big is a size word. What was big?', comprehensionHint: 'Big comes right before the fruit word.' }
            ],
            answers: [
              { name: 'Oranges', icon: 'ðŸŠ' },
              { name: 'Apples', icon: 'ðŸŽ' },
              { name: 'Bananas', icon: 'ðŸŒ' }
            ],
            correctAnswerName: 'Oranges',
            successMessage: 'Yes! You remembered which fruit was big.'
          },
          {
            type: 'read',
            image: 'ðŸ˜‹ðŸ‘¦',
            sentence: 'My fruit is so good! I hold it in my hand. I take a big bite. Yum! It is sweet and fresh. The juice drips down. I chew and chew. I am so happy! This is the best!',
            words: null,
            variants: [
              { sentence: 'My fruit is so good! I look at it first. I take a bite. Mmm! It is so fresh. The taste is just right. I take one more bite. I feel happy. I like my fruit a lot.', words: null },
              { sentence: 'My fruit is so good! I hold my fruit up. I take one bite. Wow! It is so yummy. The fruit is just what I wanted. I smile big. I feel happy. This is the best snack ever!', words: null },
              { sentence: 'My fruit is so good! I am so glad I picked it. I chew my fruit. Yes! It tastes so sweet. The fruit makes me feel good. I am full of joy. I feel happy. I want to come back soon!', words: null }
            ],
            targetWords: ['My', 'is', 'good', 'like', 'lot'],
            sightWordFocus: 'my',
            readingTip: 'My tells us something belongs to me. My fruit. My food. My book.'
          },
          {
            type: 'question',
            questionType: 'comprehension',
            questionMode: 'multipleChoice',
            passage: 'I feel happy.',
            question: 'How did I feel?',
            comprehensionHint: 'Look for the feeling word.',
            variants: [
              { question: 'What feeling word does the story use?', comprehensionHint: 'Find the word in the last sentence.' },
              { question: 'How do I feel at the end?', comprehensionHint: 'Read the last sentence. What feeling word is there?' },
              { question: 'What is my mood?', comprehensionHint: 'Mood means how you feel.' }
            ],
            answers: [
              { name: 'Happy', icon: 'ðŸ˜Š' },
              { name: 'Sad', icon: 'ðŸ˜¢' },
              { name: 'Scared', icon: 'ðŸ˜¨' }
            ],
            correctAnswerName: 'Happy',
            successMessage: 'Yes! You used the story to tell the feeling.'
          }
        ]
      },
      drink: {
        name: 'Drink Bar',
        icon: 'ðŸ¥¤',
        level: 1,
        floor: 3,
        stickers: ['ðŸ¥¤', 'ðŸ§ƒ', 'ðŸµ', 'â­'],
        // Level 1 Focus: CVC words (hot, cup) + reinforcing sight words from fruit
        // Phonics pattern: Short vowel sounds, rhyming (hot/lot, cup/up)
        sightWords: ['I', 'see', 'a', 'the', 'is', 'my', 'want', 'like', 'can', 'so'],
        previewWords: [
          { word: 'drink', icon: 'ðŸ¥¤', isSightWord: false, phonicsNote: 'd-r-i-nk' },
          { word: 'cold', icon: 'â„ï¸', isSightWord: false, phonicsNote: 'c-o-ld' },
          { word: 'hot', icon: 'ðŸ”¥', isSightWord: false, phonicsNote: 'h-o-t (CVC)' },
          { word: 'the', icon: 'ðŸ‘‰', isSightWord: true }
        ],
        pages: [
          {
            type: 'read',
            image: 'ðŸš‚ðŸ¥¤',
            sentence: 'I am at the drink bar. I see cups on a shelf. The cups are red and blue. It is hot outside! The sun is up. I am so thirsty. I want a cold drink.',
            words: null,
            variants: [
              { sentence: 'I am at the drink bar. I see tall cups on the shelf. The cups are red and blue. It is hot outside. I am so thirsty! The sun is up. I want a cold drink.', words: null },
              { sentence: 'I am at the drink bar. I see tall cups on the shelf. The cups are red and blue. The sun is hot today. I am so thirsty! I want a cold drink.', words: null },
              { sentence: 'I am at the drink bar. I see tall cups on the shelf. The cups are red and blue. I feel hot outside. I am so thirsty! The sun is up. I want a cold drink.', words: null }
            ],
            targetWords: ['I', 'am', 'at', 'the', 'drink'],
            sightWordFocus: 'I',
            requireSightWordTap: true,
            readingTip: 'I is always a capital letter. I am. I see. I want.'
          },
          {
            type: 'question',
            questionType: 'comprehension',
            questionMode: 'multipleChoice',
            passage: 'I want a cold drink.',
            question: 'What is this story mostly about?',
            comprehensionHint: 'Main idea means what it is mostly about. What do I want?',
            variants: [
              { question: 'What is the main idea?', comprehensionHint: 'Main idea means what it is mostly about.' },
              { question: 'What is this mostly about?', comprehensionHint: 'Think about what I want.' },
              { question: 'What is the main idea of the story?', comprehensionHint: 'Read the first sentence again.' }
            ],
            answers: [
              { name: 'Getting a cold drink', icon: 'ðŸ¥¤â„ï¸' },
              { name: 'Getting a hot drink', icon: 'ðŸ¥¤ðŸ”¥' },
              { name: 'Getting a sweet treat', icon: 'ðŸ°' }
            ],
            correctAnswerName: 'Getting a cold drink',
            successMessage: 'Yes! You found the main idea.'
          },
          {
            type: 'read',
            image: 'ðŸ¥¤ðŸ§ƒðŸ¥›',
            sentence: 'I see cold drinks. The drinks are in cups. The cups have ice. I see big cups and little cups. The drinks look so cold! They look so good. I want one!',
            words: null,
            variants: [
              { sentence: 'I see cold drinks. The ice is in the cups. They look so good! I see big cups. I see little cups. The drinks are on the shelf. I want a cold drink.', words: null },
              { sentence: 'I see cold drinks. The ice is in the cups. I see big cups. I see little cups. I see cups on the counter. The drinks look good to me.', words: null },
              { sentence: 'I see cold drinks. The ice is in the cups. They look so good! I see big cups. I see little cups. The drinks look good to me.', words: null }
            ],
            targetWords: ['see', 'cold', 'drinks', 'look', 'good'],
            sightWordFocus: 'see',
            readingTip: 'You know the word see from the fruit stand. Same word here.'
          },
          {
            type: 'question',
            questionType: 'comprehension',
            questionMode: 'multipleChoice',
            passage: 'I see cold drinks.',
            question: 'What did I see at the drink bar?',
            comprehensionHint: 'Read the sentence in the box.',
            variants: [
              { question: 'What do I see?', comprehensionHint: 'The answer is in the sentence.' },
              { question: 'What did I see?', comprehensionHint: 'Read the words after I see.' },
              { question: 'In the story, what did I see?', comprehensionHint: 'Look for I see and read the next words.' }
            ],
            answers: [
              { name: 'Cold drinks', icon: 'ðŸ¥¤â„ï¸' },
              { name: 'Hot drinks', icon: 'ðŸ¥¤ðŸ”¥' },
              { name: 'Big drinks', icon: 'ðŸ¥¤' }
            ],
            correctAnswerName: 'Cold drinks',
            successMessage: 'Great! You used the sentence to answer.'
          },
          {
            type: 'read',
            image: 'ðŸ‘¦ðŸ˜Šâ˜€ï¸',
            sentence: 'I am so hot. Hot and cold are opposites. I want a cold drink. I pick a cup with juice. The cup is cold. Ice is in the cup. I hold the cup. I take a sip. It is so good!',
            words: null,
            variants: [
              { sentence: 'I am so hot. Hot and cold are opposites. The sun is up. I want a cold drink. I pick a yummy juice. The ice makes the cup cold. I hold the cold cup. I take a sip. It is so good!', words: null },
              { sentence: 'I am so hot. Hot and cold are opposites. The sun is up. I want a cold drink. I pick a yummy juice. The ice makes the cup cold. My mouth feels dry. I take a sip. It is so good!', words: null },
              { sentence: 'I am so hot. Hot and cold are opposites. The sun is up. I want a cold drink. I pick a yummy juice. The ice makes the cup cold. I hold the cup. I take a sip. It is so good!', words: null }
            ],
            targetWords: ['am', 'hot', 'want', 'cold', 'drink'],
            sightWordFocus: 'want',
            readingTip: 'Hot and cold are opposites. Hot means warm. Cold means not warm.'
          },
          {
            type: 'question',
            questionType: 'comprehension',
            questionMode: 'multipleChoice',
            passage: 'Hot and cold are opposites.',
            question: 'What is the opposite of hot?',
            comprehensionHint: 'Opposite means very different.',
            variants: [
              { question: 'Which word means the opposite of hot?', comprehensionHint: 'Think about the opposite word.' },
              { question: 'Hot and cold are opposites. What is the opposite of hot?', comprehensionHint: 'Read the sentence again.' },
              { question: 'Choose the opposite.', comprehensionHint: 'Opposite means very different.' }
            ],
            answers: [
              { name: 'Cold', icon: 'â„ï¸' },
              { name: 'Wet', icon: 'ðŸ’§' },
              { name: 'Big', icon: 'ðŸ“' }
            ],
            correctAnswerName: 'Cold',
            successMessage: 'Yes! Cold is the opposite of hot.'
          },
          {
            type: 'menu',
            prompt: 'Pick your drink!',
            menuStory: 'It is so hot. A cold drink will be good!',
            variants: [
              { prompt: 'Choose a drink.', menuStory: 'Read each choice. Then pick one drink.' },
              { prompt: 'What drink will you get?', menuStory: 'Think about a hot day. Pick a drink that helps.' },
              { prompt: 'Pick a drink for the hot day.', menuStory: 'Choose one drink to help you cool down.' }
            ],
            items: [
              { name: 'Juice', icon: 'ðŸ§ƒ', description: 'Sweet and cold' },
              { name: 'Milk', icon: 'ðŸ¥›', description: 'Cold and creamy' },
              { name: 'Water', icon: 'ðŸ’§', description: 'Cold and fresh' }
            ]
          },
          {
            type: 'question',
            questionType: 'comprehension',
            questionMode: 'multipleChoice',
            passage: 'I am so hot.',
            question: 'Why did I want a cold drink?',
            comprehensionHint: 'The story tells the reason. Read the sentence again.',
            variants: [
              { question: 'What is the reason I want a cold drink?', comprehensionHint: 'Reason means why. Read the sentence again.' },
              { question: 'Why do I want a cold drink?', comprehensionHint: 'Read the sentence. What is the problem?' },
              { question: 'Why did I want a cold drink?', comprehensionHint: 'Find the reason in the sentence.' }
            ],
            answers: [
              { name: 'Because I was hot', icon: 'ðŸ”¥' },
              { name: 'Because I was cold', icon: 'â„ï¸' },
              { name: 'Because I was hungry', icon: 'ðŸ½ï¸' }
            ],
            correctAnswerName: 'Because I was hot',
            successMessage: 'Great! You used the story to answer why.'
          },
          {
            type: 'read',
            image: 'ðŸ˜‹â„ï¸',
            sentence: 'My drink is cold. My drink helps me. The ice is in my cup. I sip and sip. I am not hot now. I feel better! The drink is good. I am happy!',
            words: null,
            variants: [
              { sentence: 'My drink is cold. My drink helps me. The ice is in my cup. I am not hot now. I sip the juice. I feel better now. The drink is so good!', words: null },
              { sentence: 'My drink is cold. My drink helps me. The ice is in my cup. I sip it slowly. I am not hot now. I feel better. The drink is so good!', words: null },
              { sentence: 'My drink is cold. My drink helps me. The ice is in my cup. My body cools down. I am not hot now. I feel better now. The drink is so good!', words: null }
            ],
            targetWords: ['My', 'drink', 'is', 'good', 'like', 'lot'],
            sightWordFocus: 'is',
            readingTip: 'Is tells what something is. My drink is cold.'
          },
          {
            type: 'question',
            questionType: 'comprehension',
            questionMode: 'multipleChoice',
            passage: 'My drink helps me.',
            question: 'What helped me feel better?',
            comprehensionHint: 'Read the sentence. What helps me?',
            variants: [
              { question: 'What helped me?', comprehensionHint: 'Read the passage again.' },
              { question: 'In the story, what helped me?', comprehensionHint: 'Use the passage.' },
              { question: 'What made me feel better?', comprehensionHint: 'Look for what helps.' }
            ],
            answers: [
              { name: 'My drink', icon: 'ðŸ¥¤' },
              { name: 'My hat', icon: 'ðŸ§¢' },
              { name: 'My shoes', icon: 'ðŸ‘Ÿ' }
            ],
            correctAnswerName: 'My drink',
            successMessage: 'Yes! My drink helped me.'
          }
        ]
      },
      bakery: {
        name: 'Bakery',
        icon: 'ðŸ§',
        level: 1,
        floor: 3,
        stickers: ['ðŸ§', 'ðŸ°', 'ðŸ¥§', 'â­'],
        // Level 1 Focus: CVC words (bun, big) + introducing size words
        // Phonics pattern: Short vowel sounds, size comparisons (big/little)
        sightWords: ['I', 'see', 'a', 'the', 'is', 'my', 'want', 'like', 'can', 'so'],
        previewWords: [
          { word: 'cake', icon: 'ðŸ°', isSightWord: false, phonicsNote: 'c-a-ke (long a)' },
          { word: 'big', icon: 'ðŸ“', isSightWord: false, phonicsNote: 'b-i-g (CVC)' },
          { word: 'bun', icon: 'ðŸ¥¯', isSightWord: false, phonicsNote: 'b-u-n (CVC)' },
          { word: 'a', icon: '1ï¸âƒ£', isSightWord: true }
        ],
        pages: [
          {
            type: 'read',
            image: 'ðŸš‚ðŸ§',
            sentence: 'I am at the bakery! The door is open. I can smell fresh bread. It smells so good! The air is warm and sweet. I can see treats on a shelf. I want a sweet treat!',
            words: null,
            variants: [
              { sentence: 'I am at the bakery. The door is open. It smells so good! I can see treats. The air is warm and sweet. I want a sweet treat!', words: null },
              { sentence: 'I am at the bakery. The door is open. I smell warm bread. It smells so good! I can see treats. The air is warm and sweet. I want a sweet treat!', words: null },
              { sentence: 'I am at the bakery. The door is open. The air smells sweet. It smells so good! I can see treats. The air is warm and sweet. I want a sweet treat!', words: null }
            ],
            targetWords: ['I', 'am', 'the', 'bakery', 'smells', 'good'],
            sightWordFocus: 'the',
            requireSightWordTap: true,
            readingTip: 'A bakery is a shop that makes bread and cakes. It smells sweet!'
          },
          {
            type: 'question',
            questionType: 'comprehension',
            questionMode: 'multipleChoice',
            passage: 'I want a sweet treat!',
            question: 'What is this story mostly about?',
            comprehensionHint: 'Main idea means what it is mostly about. What do I want?',
            variants: [
              { question: 'What is the main idea?', comprehensionHint: 'Main idea means what it is mostly about.' },
              { question: 'What is this mostly about?', comprehensionHint: 'Think about what I want.' },
              { question: 'What is the main idea of the story?', comprehensionHint: 'Look for what I want.' }
            ],
            answers: [
              { name: 'Choosing a sweet treat', icon: 'ðŸ°' },
              { name: 'Smelling fresh bread', icon: 'ðŸž' },
              { name: 'Looking at treats', icon: 'ðŸ§' }
            ],
            correctAnswerName: 'Choosing a sweet treat',
            successMessage: 'Yes! You found the main idea.'
          },
          {
            type: 'read',
            image: 'ðŸ§ðŸ°ðŸ¥§',
            sentence: 'I look at all the treats. I see a big cake on the top shelf. I see little pies on a tray. I see warm buns in a basket. The buns smell so good! They all look yummy. What will I pick?',
            words: null,
            variants: [
              { sentence: 'I see a big cake. The cake is on the top shelf. I see little pies. The pies are on a tray. I see warm buns. The buns smell good. I want to pick one.', words: null },
              { sentence: 'I see a big cake. The cake is on the top shelf. I see little pies. The pies are on a tray. I see warm buns. I want to taste them.', words: null },
              { sentence: 'I see a big cake. The cake is on the top shelf. I see little pies. The pies are on a tray. I see warm buns. The bakery smells good.', words: null }
            ],
            targetWords: ['see', 'big', 'cake', 'little', 'pies', 'warm', 'buns'],
            sightWordFocus: 'a',
            readingTip: 'Big and little are size words. The cake is big. The pies are little.'
          },
          {
            type: 'question',
            questionType: 'comprehension',
            questionMode: 'multipleChoice',
            passage: 'I see little pies.',
            question: 'What was little?',
            comprehensionHint: 'Find the size word little.',
            variants: [
              { question: 'In the story, what was little?', comprehensionHint: 'Read the sentence with little.' },
              { question: 'Which food matches the words little pies?', comprehensionHint: 'Look for little. What food is little?' },
              { question: 'Little tells size. What was little?', comprehensionHint: 'Little comes right before the food word.' }
            ],
            answers: [
              { name: 'Pies', icon: 'ðŸ¥§' },
              { name: 'Cake', icon: 'ðŸ°' },
              { name: 'Buns', icon: 'ðŸ¥¯' }
            ],
            correctAnswerName: 'Pies',
            successMessage: 'Yes! You remembered the size word and the food.'
          },
          {
            type: 'read',
            image: 'ðŸ‘¦ðŸ˜',
            sentence: 'I want a sweet treat! A man at the shop can help me. I can get a big cake. I can get a little pie. I can get a warm bun. I like them all! What will I pick?',
            words: null,
            variants: [
              { sentence: 'I want a sweet treat. The man at the shop can help me. I can get cake. I can get pie. I can get a bun. I like them all! What will I pick?', words: null },
              { sentence: 'I want a sweet treat. The man at the shop can help me. I can get cake or pie. I can get a warm bun. I like them all! What will I pick?', words: null },
              { sentence: 'I want a sweet treat. The man at the shop can help me. I can get a bun. I can get pie. I can get cake. I like them all! What will I pick?', words: null }
            ],
            targetWords: ['want', 'sweet', 'treat', 'What', 'can', 'get'],
            sightWordFocus: 'can',
            readingTip: 'Can asks if I am able to do something. What can I get?'
          },
          {
            type: 'menu',
            prompt: 'Pick your treat!',
            menuStory: 'It all smells so good! What treat do you want?',
            variants: [
              { prompt: 'Choose a treat.', menuStory: 'Read each choice. Then choose one treat.' },
              { prompt: 'What treat will you get?', menuStory: 'Think about the story: big cake, little pies, warm buns.' },
              { prompt: 'Pick a sweet treat.', menuStory: 'Pick one sweet treat from the bakery.' }
            ],
            items: [
              { name: 'Cake', icon: 'ðŸ°', description: 'Big and soft' },
              { name: 'Pie', icon: 'ðŸ¥§', description: 'Sweet and yummy' },
              { name: 'Bun', icon: 'ðŸ¥¯', description: 'Warm and round' }
            ]
          },
          {
            type: 'question',
            questionType: 'comprehension',
            questionMode: 'multipleChoice',
            passage: 'It smells so good!',
            question: 'What did the bakery smell like?',
            comprehensionHint: 'Look for the describing words.',
            variants: [
              { question: 'How did the bakery smell?', comprehensionHint: 'Read the passage again.' },
              { question: 'Which words describe the smell?', comprehensionHint: 'Find the words that tell the smell.' },
              { question: 'Was the smell good or bad?', comprehensionHint: 'Use the story words.' }
            ],
            answers: [
              { name: 'So good', icon: 'ðŸ˜‹' },
              { name: 'So bad', icon: 'ðŸ¤¢' },
              { name: 'So cold', icon: 'â„ï¸' }
            ],
            correctAnswerName: 'So good',
            successMessage: 'Yes! You remembered the smell from the story.'
          },
          {
            type: 'read',
            image: 'ðŸ˜‹ðŸŽ‰',
            sentence: 'My treat is the best! I take a big bite. Mmm! It is soft and sweet. I am so happy! I smile big. I say thank you. The bakery is so good!',
            words: null,
            variants: [
              { sentence: 'My treat is the best! I take a bite. It is so soft and sweet. I am so happy! I smile big. I say thank you. The bakery is good!', words: null },
              { sentence: 'My treat is the best! I take a bite. It is so soft and sweet. I smile. I say thank you. The bakery is good!', words: null },
              { sentence: 'My treat is the best! I take a bite. It is so soft and sweet. I am so happy. I say thank you. The bakery is good!', words: null }
            ],
            targetWords: ['My', 'treat', 'is', 'best', 'am', 'happy'],
            sightWordFocus: 'my',
            readingTip: 'Best means the most good. My treat is the best.'
          },
          {
            type: 'question',
            questionType: 'comprehension',
            questionMode: 'multipleChoice',
            passage: 'I say thank you.',
            question: 'What did I say?',
            comprehensionHint: 'Read the sentence in the box.',
            variants: [
              { question: 'What words did I say at the end?', comprehensionHint: 'Find the words in the passage.' },
              { question: 'How did I show good manners?', comprehensionHint: 'Good manners are kind words.' },
              { question: 'Which words did I use?', comprehensionHint: 'Look for the two words I say.' }
            ],
            answers: [
              { name: 'Thank you', icon: 'ðŸ™' },
              { name: 'Hello', icon: 'ðŸ‘‹' },
              { name: 'Please', icon: 'ðŸ¥º' }
            ],
            correctAnswerName: 'Thank you',
            successMessage: 'Yes! You remembered the words you said.'
          }
        ]
      },

      // ===== LEVEL 2: LONGER WORDS, MORE ADJECTIVES =====
      // Focus: Compound words, descriptive adjectives, 2-syllable words
      // Sentence length: 5-8 words
      // More detail and emotion in stories
      // Building on Level 1 sight words + introducing new ones (to, some, have, very)
      pizza: {
        name: 'Pizza Place',
        icon: 'ðŸ•',
        level: 2,
        floor: 3,
        stickers: ['ðŸ•', 'ðŸ§€', 'ðŸ…', 'â­'],
        sightWords: ['I', 'see', 'want', 'to', 'eat', 'some', 'very', 'hot', 'my', 'this'],
        previewWords: [
          { word: 'pizza', icon: 'ðŸ•', isSightWord: false, phonicsNote: 'piz-za (2 syllables)' },
          { word: 'yummy', icon: 'ðŸ˜‹', isSightWord: false, phonicsNote: 'yum-my (2 syllables)' },
          { word: 'cheese', icon: 'ðŸ§€', isSightWord: false, phonicsNote: 'ch-ee-se (long e)' },
          { word: 'some', icon: 'ðŸ”¢', isSightWord: true }
        ],
        pages: [
          {
            type: 'read',
            image: 'ðŸš‚ðŸ•ðŸ”¥',
            sentence: 'I am at the pizza place! I can smell hot pizza. Hot pizza is baking in the oven. The yummy smell fills the whole room. It makes me want to eat. My tummy rumbles. I am so hungry! I cannot wait to eat pizza.',
            words: null,
            variants: [
              { sentence: 'I am at the pizza place. I can smell hot pizza. Hot pizza is cooking! The yummy smell fills the whole room. It makes me want to eat. My tummy starts to rumble. I am so hungry! I cannot wait to eat some pizza.', words: null },
              { sentence: 'I am at the pizza place. I can smell hot pizza. Hot pizza is baking! The yummy smell is all around me. It makes me want to eat. My tummy starts to growl. I am very hungry! I want to eat pizza now.', words: null },
              { sentence: 'I am at the pizza place today. I can smell hot pizza. Hot pizza is cooking in the oven! The yummy smell fills the whole room. It makes me want to eat. My tummy feels so hungry. I cannot wait to eat some pizza!', words: null }
            ],
            targetWords: ['am', 'pizza', 'place', 'can', 'smell', 'hot'],
            sightWordFocus: 'can',
            requireSightWordTap: true,
            readingTip: 'Pizza has two parts. Say piz-za slowly.'
          },
          {
            type: 'question',
            questionType: 'comprehension',
            questionMode: 'multipleChoice',
            question: 'What did I smell?',
            passage: 'I can smell hot pizza.',
            comprehensionHint: 'Read the sentence in the box.',
            variants: [
              { question: 'What smell did I notice?', comprehensionHint: 'Find the words that tell the smell.' },
              { question: 'Which words tell what I smelled?', comprehensionHint: 'Look for the words that tell the smell.' },
              { question: 'At the pizza place, what did I smell?', comprehensionHint: 'Use the passage.' }
            ],
            answers: [
              { name: 'Hot pizza', icon: 'ðŸ•ðŸ”¥' },
              { name: 'Hot bread', icon: 'ðŸžðŸ”¥' },
              { name: 'Hot soup', icon: 'ðŸ²ðŸ”¥' }
            ],
            correctAnswerName: 'Hot pizza',
            successMessage: 'Yes! You remembered what you smelled.'
          },
          {
            type: 'read',
            image: 'ðŸ•ðŸ§€ðŸ…',
            sentence: 'I see big pizzas on the counter! They have gooey cheese on top. The cheese is gooey. Red pepperoni circles sit on the cheese. The cheese bubbles and stretches. Steam rises up from the hot pizza. It is ready to eat!',
            words: null,
            variants: [
              { sentence: 'I see big yummy pizzas on the counter. They have gooey cheese on top. The cheese is gooey. Red pepperoni dots cover them. The cheese bubbles and melts. It looks so tasty! I can see steam rising up. The pizza is very hot and ready to eat.', words: null },
              { sentence: 'I see big yummy pizzas waiting for me. They have gooey cheese on top. The cheese is gooey. Red pepperoni is all over them. The cheese is bubbly and hot. It looks so good! Steam rises from the pizza. I want to eat it right now!', words: null },
              { sentence: 'I see big yummy pizzas on the table. They have gooey cheese on top. The cheese is gooey. Red pepperoni dots are on them. The cheese bubbles and stretches. It smells so good! Steam floats up from the pizza. They are hot and ready!', words: null }
            ],
            targetWords: ['see', 'big', 'yummy', 'pizzas', 'have', 'cheese', 'top', 'gooey'],
            sightWordFocus: 'have',
            readingTip: 'Have is a sight word. The pizza has cheese. They have cheese.'
          },
          {
            type: 'question',
            questionType: 'comprehension',
            questionMode: 'multipleChoice',
            question: 'How was the cheese?',
            passage: 'The cheese is gooey.',
            comprehensionHint: 'Find the describing word.',
            variants: [
              { question: 'Which word describes the cheese?', comprehensionHint: 'Look for the describing word in the passage.' },
              { question: 'What was the cheese like?', comprehensionHint: 'Read the sentence about cheese.' },
              { question: 'How did the cheese look?', comprehensionHint: 'Use the describing word in the sentence.' }
            ],
            answers: [
              { name: 'Gooey', icon: 'ðŸ§€ðŸ’§' },
              { name: 'Crunchy', icon: 'ðŸ§€ðŸª¨' },
              { name: 'Dry', icon: 'ðŸ§€ðŸŒµ' }
            ],
            correctAnswerName: 'Gooey',
            successMessage: 'Yes! You remembered what the story said.'
          },
          {
            type: 'read',
            image: 'ðŸ‘¦ðŸ¤¤',
            sentence: 'I want to eat pizza right now! My tummy is very hungry. It feels empty inside. The yummy smell makes me even hungrier. I pick up a big slice with my hands. The cheese stretches out long. I am ready for my first bite!',
            words: null,
            variants: [
              { sentence: 'I want to eat some pizza right now! My tummy is very hungry. It feels so empty inside. The yummy smell makes me want pizza even more. I pick up a big slice. The cheese stretches when I lift it up. I am ready to take my first bite!', words: null },
              { sentence: 'I want to eat some pizza today! My tummy is very hungry. It is so empty right now. The yummy pizza makes me want it more. I grab a big slice. The gooey cheese stretches out. I am ready to eat it now!', words: null },
              { sentence: 'I want to eat some pizza so much! My tummy is very hungry. It feels empty and rumbly. The good smell makes me even more hungry. I take a big slice. The cheese pulls and stretches. I cannot wait to taste it!', words: null }
            ],
            targetWords: ['want', 'to', 'eat', 'some', 'pizza', 'tummy', 'very', 'hungry'],
            sightWordFocus: 'to',
            readingTip: 'To is a helper word. I want to eat. I want to play.'
          },
          {
            type: 'menu',
            prompt: 'How much pizza do you want?',
            menuStory: 'The pizza smells so good! How hungry are you?',
            variants: [
              { prompt: 'Choose how much pizza.', menuStory: 'Read each choice. Then choose.' },
              { prompt: 'Pick your pizza size.', menuStory: 'Think about how hungry your tummy feels.' },
              { prompt: 'How many slices will you eat?', menuStory: 'Pick one answer.' }
            ],
            items: [
              { name: 'One slice', icon: 'ðŸ•', description: 'Just a little' },
              { name: 'Two slices', icon: 'ðŸ•ðŸ•', description: 'A good amount' },
              { name: 'Big pizza', icon: 'ðŸ•ðŸ•ðŸ•', description: 'Very hungry!' }
            ]
          },
          {
            type: 'question',
            questionType: 'comprehension',
            questionMode: 'multipleChoice',
            question: 'How did my tummy feel?',
            passage: 'My tummy is very hungry.',
            comprehensionHint: 'Read the sentence in the box.',
            variants: [
              { question: 'What words tell how my tummy felt?', comprehensionHint: 'Find the describing words.' },
              { question: 'How hungry was my tummy?', comprehensionHint: 'Look for the describing words.' },
              { question: 'What does the story say about my tummy?', comprehensionHint: 'Use the passage.' }
            ],
            answers: [
              { name: 'Very hungry', icon: 'ðŸ½ï¸' },
              { name: 'Very sleepy', icon: 'ðŸ˜´' },
              { name: 'Very cold', icon: 'â„ï¸' }
            ],
            correctAnswerName: 'Very hungry',
            successMessage: 'Yes! You remembered how the story described your tummy.'
          },
          {
            type: 'read',
            image: 'ðŸ˜‹ðŸ”¥ðŸ‘¦',
            sentence: 'My hot pizza is very yummy! I take a big bite. Mmm! The cheese is gooey and tasty. The pepperoni is a little spicy. Each bite makes me smile. Now my tummy feels full. I feel happy. This was the best pizza ever! I love pizza!',
            words: null,
            variants: [
              { sentence: 'My hot pizza is so very yummy! I take a big bite. The cheese is gooey and tasty. The pepperoni is spicy and good. Each bite makes me happy. Now my tummy feels full. I feel happy. This was the best pizza ever! I love pizza!', words: null },
              { sentence: 'My hot pizza tastes so yummy! I eat a big bite. The gooey cheese is so good. The pepperoni tastes spicy. Every bite makes me smile. Now my tummy feels full. I feel happy. This pizza was the very best! I love it so much.', words: null },
              { sentence: 'My hot pizza is very yummy! I munch a big bite. The cheese is gooey and cheesy. The red pepperoni is spicy. Each bite is so good! Now my tummy feels full. I feel happy. This was the yummiest pizza! I love eating pizza.', words: null }
            ],
            targetWords: ['hot', 'pizza', 'very', 'yummy', 'cheese', 'gooey', 'good', 'love', 'day'],
            sightWordFocus: 'very',
            readingTip: 'Very makes a word stronger. Very hot. Very yummy. Very good.'
          },
          {
            type: 'question',
            questionType: 'comprehension',
            questionMode: 'multipleChoice',
            question: 'How did my tummy feel at the end?',
            passage: 'Now my tummy feels full.',
            comprehensionHint: 'Read the last sentence.',
            variants: [
              { question: 'At the end, how did my tummy feel?', comprehensionHint: 'Find the last sentence.' },
              { question: 'Which word tells my tummy is not hungry anymore?', comprehensionHint: 'Look for the last word in the passage.' },
              { question: 'What happened at the end?', comprehensionHint: 'End means last.' }
            ],
            answers: [
              { name: 'Full', icon: 'ðŸ˜Œ' },
              { name: 'Very hungry', icon: 'ðŸ½ï¸' },
              { name: 'Very cold', icon: 'â„ï¸' }
            ],
            correctAnswerName: 'Full',
            successMessage: 'Yes! You remembered what happened at the end.'
          }
        ]
      },
      icecream: {
        name: 'Ice Cream',
        icon: 'ðŸ¦',
        level: 2,
        floor: 3,
        stickers: ['ðŸ¦', 'ðŸ¨', 'ðŸ§', 'â­'],
        // Level 2 Focus: Compound words (ice cream), color words, opposites (hot/cold)
        sightWords: ['I', 'see', 'want', 'to', 'eat', 'so', 'many', 'cold', 'my', 'this'],
        previewWords: [
          { word: 'ice cream', icon: 'ðŸ¦', isSightWord: false, phonicsNote: 'ice cream (compound word)' },
          { word: 'cold', icon: 'â„ï¸', isSightWord: false, phonicsNote: 'c-o-ld' },
          { word: 'sweet', icon: 'ðŸ¬', isSightWord: false, phonicsNote: 'sw-ee-t (long e)' },
          { word: 'many', icon: 'ðŸ”¢', isSightWord: true }
        ],
        pages: [
          {
            type: 'read',
            image: 'ðŸš‚ðŸ¦â„ï¸',
            sentence: 'I am at the ice cream shop! I open the big door and step inside. It is so cold inside! The freezers hum and keep everything frozen. I can see many colorful ice cream treats. They look yummy and sweet!',
            words: null,
            variants: [
              { sentence: 'I am at the ice cream shop. I open the big door. It is so cold inside! The freezers make the shop cold. I can see many colorful treats. They look so yummy and sweet!', words: null },
              { sentence: 'I am at the ice cream shop. I open the big door. It is so cold inside! The freezers make the shop cold. I can see many colorful treats. They look so yummy and sweet!', words: null },
              { sentence: 'I am at the ice cream shop. I open the big door. It is so cold inside! The freezers make the shop cold. I can see many colorful treats. They look so yummy and sweet!', words: null }
            ],
            targetWords: ['am', 'ice', 'cream', 'shop', 'It', 'is', 'cold', 'inside'],
            sightWordFocus: 'it',
            requireSightWordTap: true,
            readingTip: 'Ice cream is two words. Ice and cream.'
          },
          {
            type: 'question',
            questionType: 'comprehension',
            questionMode: 'multipleChoice',
            question: 'How did it feel inside the shop?',
            passage: 'It is so cold inside!',
            comprehensionHint: 'Read the words in the box.',
            variants: [
              { question: 'What word tells how it felt inside?', comprehensionHint: 'Find the feeling word.' },
              { question: 'Was it hot or cold inside?', comprehensionHint: 'Use the passage.' },
              { question: 'Inside the shop, how did it feel?', comprehensionHint: 'Look for the word that tells the feeling.' }
            ],
            answers: [
              { name: 'Cold', icon: 'â„ï¸' },
              { name: 'Hot', icon: 'ðŸ”¥' },
              { name: 'Wet', icon: 'ðŸ’§' }
            ],
            correctAnswerName: 'Cold',
            successMessage: 'Yes! You used the story to answer.'
          },
          {
            type: 'read',
            image: 'ðŸ¦ðŸ¨ðŸ§ðŸŒˆ',
            sentence: 'I see so many ice cream flavors! The tubs sit in a long row. There are many colors to choose from. Pink strawberry, brown chocolate, and white vanilla! Each flavor looks different and special. Some look creamy. Some look fruity. I want to taste them all!',
            words: null,
            variants: [
              { sentence: 'I see so many yummy ice creams! The tubs are in a row. There are many colors. Pink, brown, and white! Each flavor looks different. Some are creamy. Some are fruity. I want to taste them all!', words: null },
              { sentence: 'I see so many yummy ice creams! The tubs are in a row. I see many colors. Pink, brown, and white! Each flavor looks different. Some are creamy. Some are fruity. I want to taste them all!', words: null },
              { sentence: 'I see so many yummy ice creams! The tubs are in a row. Colors are everywhere. Pink, brown, and white! Each flavor looks different. Some are creamy. Some are fruity. I want to taste them all!', words: null }
            ],
            targetWords: ['see', 'so', 'many', 'yummy', 'ice', 'creams', 'There', 'colors', 'Pink', 'brown', 'white'],
            sightWordFocus: 'many',
            readingTip: 'Many means a lot. Many colors. Many ice creams.'
          },
          {
            type: 'question',
            questionType: 'comprehension',
            questionMode: 'multipleChoice',
            question: 'Which colors were in the story?',
            passage: 'Pink, brown, and white!',
            comprehensionHint: 'Read the color words.',
            variants: [
              { question: 'What colors does the story name?', comprehensionHint: 'Look at the last sentence.' },
              { question: 'Which choice matches the colors?', comprehensionHint: 'Choose the exact words.' },
              { question: 'Pick the colors from the passage.', comprehensionHint: 'Read the color words again.' }
            ],
            answers: [
              { name: 'Pink, brown, and white', icon: 'ðŸŒ¸ðŸ¤Žâšªï¸' },
              { name: 'Red, blue, and green', icon: 'ðŸ”´ðŸ”µðŸŸ¢' },
              { name: 'Purple, orange, and black', icon: 'ðŸŸ£ðŸŸ âš«ï¸' }
            ],
            correctAnswerName: 'Pink, brown, and white',
            successMessage: 'Great! You remembered the exact colors.'
          },
          {
            type: 'read',
            image: 'ðŸ‘¦ðŸ˜Šâ˜€ï¸',
            sentence: 'It is a very hot day outside. The bright sun is shining down. I want to eat a cold, sweet treat! Ice cream will help me cool down and feel better. I am excited to pick my favorite flavor!',
            words: null,
            variants: [
              { sentence: 'It is a hot day. The sun is shining outside. I want to eat a cold, sweet treat! Ice cream will help me cool down. I am excited to pick my favorite flavor!', words: null },
              { sentence: 'It is a hot day. The sun is shining outside. I want a cold, sweet treat. Ice cream will help me cool down. I am excited to pick my favorite flavor!', words: null },
              { sentence: 'It is a hot day. The sun is shining outside. A cold treat sounds good to me. Ice cream will help me cool down. I am excited to pick my favorite flavor!', words: null }
            ],
            targetWords: ['It', 'is', 'hot', 'day', 'want', 'to', 'eat', 'cold', 'sweet', 'treat'],
            sightWordFocus: 'to',
            readingTip: 'Hot and cold are opposites. Hot day and cold ice cream go together.'
          },
          {
            type: 'menu',
            prompt: 'Cone, cup, or bowl?',
            menuStory: 'How do you want your ice cream? Each way is yummy!',
            variants: [
              { prompt: 'Choose: cone, cup, or bowl.', menuStory: 'Read the choices. Then pick one.' },
              { prompt: 'How will you eat it?', menuStory: 'Pick one way to eat ice cream.' },
              { prompt: 'Pick your ice cream holder.', menuStory: 'Cone, cup, or bowl?' }
            ],
            items: [
              { name: 'Cone', icon: 'ðŸ¦', description: 'Crunchy outside' },
              { name: 'Cup', icon: 'ðŸ¨', description: 'Easy to eat' },
              { name: 'Bowl', icon: 'ðŸ§', description: 'Big and colorful' }
            ]
          },
          {
            type: 'question',
            questionType: 'comprehension',
            questionMode: 'multipleChoice',
            question: 'What kind of day was it?',
            passage: 'It is a hot day.',
            comprehensionHint: 'Read the sentence in the box.',
            variants: [
              { question: 'What does the story say about the day?', comprehensionHint: 'Look for the describing word.' },
              { question: 'Was the day hot or cold?', comprehensionHint: 'Use the passage.' },
              { question: 'What kind of day is it?', comprehensionHint: 'Find the word that describes the day.' }
            ],
            answers: [
              { name: 'A hot day', icon: 'â˜€ï¸' },
              { name: 'A cold day', icon: 'â„ï¸' },
              { name: 'A rainy day', icon: 'ðŸŒ§ï¸' }
            ],
            correctAnswerName: 'A hot day',
            successMessage: 'Great! You remembered a detail from the story.'
          },
          {
            type: 'read',
            image: 'ðŸ˜‹â„ï¸ðŸ‘…',
            sentence: 'My sweet ice cream is so cold and yummy! I take a big lick with my tongue. The flavor is perfect and delicious! It makes my tongue happy! I feel so much cooler now. This is the best treat on a hot, sunny day!',
            words: null,
            variants: [
              { sentence: 'My sweet ice cream is so cold and yummy! I take a lick. The flavor is perfect! It makes my tongue happy! I feel cooler now. This is the best treat on a sunny day!', words: null },
              { sentence: 'My sweet ice cream is so cold and yummy! I take a lick. The flavor is perfect! It makes my tongue happy! I feel cooler now. This is the best treat on a sunny day!', words: null },
              { sentence: 'My sweet ice cream is so cold and yummy! I take a lick. The flavor is perfect! It makes my tongue happy! I smile as I eat it. I feel cooler now. This is the best treat on a sunny day!', words: null }
            ],
            targetWords: ['sweet', 'ice', 'cream', 'is', 'cold', 'yummy', 'makes', 'tongue', 'happy'],
            sightWordFocus: 'makes',
            readingTip: 'Makes tells what something does. It makes you happy.'
          },
          {
            type: 'question',
            questionType: 'comprehension',
            questionMode: 'multipleChoice',
            question: 'What did the ice cream make happy?',
            passage: 'It makes my tongue happy!',
            comprehensionHint: 'Read the sentence. What part of me is happy?',
            variants: [
              { question: 'What was happy in the story?', comprehensionHint: 'Read the last words.' },
              { question: 'What did it make happy?', comprehensionHint: 'It means the ice cream.' },
              { question: 'What part of me felt happy?', comprehensionHint: 'Look for my and the body part.' }
            ],
            answers: [
              { name: 'My tongue', icon: 'ðŸ‘…' },
              { name: 'My shoes', icon: 'ðŸ‘Ÿ' },
              { name: 'My bed', icon: 'ðŸ›ï¸' }
            ],
            correctAnswerName: 'My tongue',
            successMessage: 'Yes! You remembered what the story said.'
          }
        ]
      },

      // ===== LEVEL 3: DIGRAPHS - SH WORDS =====
      // Focus: SH digraph in different positions (fish, shop, shrimp, wish, fresh, shell)
      // Explicit phonics instruction with teachWord
      // More complex sentences with SH words
      // Educational note: SH is often the first digraph taught because it's
      // highly consistent and appears in many common words
      fishshop: {
        name: 'Fish Shop',
        icon: 'ðŸŸ',
        level: 3,
        floor: 3,
        stickers: ['ðŸŸ', 'ðŸ¦', 'ðŸ ', 'â­'],
        digraphFocus: 'sh',
        sightWords: ['the', 'look', 'they', 'want', 'some', 'I', 'see', 'so', 'for', 'my'],
        previewWords: [
          { word: 'fish', icon: 'ðŸŸ', isSightWord: false, hasDigraph: true, digraphPosition: 'end' },
          { word: 'shop', icon: 'ðŸª', isSightWord: false, hasDigraph: true, digraphPosition: 'start' },
          { word: 'shrimp', icon: 'ðŸ¦', isSightWord: false, hasDigraph: true, digraphPosition: 'start' },
          { word: 'fresh', icon: 'âœ¨', isSightWord: false, hasDigraph: true, digraphPosition: 'end' }
        ],
        pages: [
          {
            type: 'read',
            image: 'ðŸš‚ðŸŸðŸª',
            sentence: 'I am at the fish shop! I can see fish on ice. The shop smells like the sea. S and H work together. SH makes the sh sound. Shop starts with SH!',
            words: null,
            variants: [
              { sentence: 'I am at the fish shop! I see so many fish. The shop smells fresh like the sea. S and H work together. SH makes the sh sound. Fish ends with SH!', words: null },
              { sentence: 'I am at the fish shop today! I can see fish everywhere. The shop smells like the sea. S and H work together. SH makes the sh sound. Shop starts with SH!', words: null },
              { sentence: 'I am at the fish shop now! Fish are on ice in the shop. It smells like the sea. S and H work together. SH makes the sh sound. Fish ends with SH!', words: null }
            ],
            targetWords: ['am', 'fish', 'shop', 'SH', 'sound', 'like', 'see', 'fresh', 'work', 'together'],
            teachWord: { word: 'shop', sound: 'sh', highlight: 'SH-op', position: 'start' },
            sightWordFocus: 'like',
            requireSightWordTap: true,
            readingTip: 'SH is one sound. SH makes the sh sound.'
          },
          {
            type: 'question',
            questionType: 'sightWord',
            questionMode: 'multipleChoice',
            passage: 'SH makes the sh sound.',
            question: 'What sound do the letters SH make?',
            comprehensionHint: 'Say the word shop. Listen for sh.',
            variants: [
              { question: 'What sound does SH make?', comprehensionHint: 'SH is one sound. Say shop.' },
              { question: 'Which sound is made by SH?', comprehensionHint: 'S and H together say sh.' },
              { question: 'In the word fish, what sound do SH make?', comprehensionHint: 'Fish ends with sh.' }
            ],
            answers: [
              { name: 'sh', icon: '' },
              { name: 'ch', icon: '' },
              { name: 'th', icon: '' }
            ],
            correctAnswerName: 'sh',
            successMessage: 'Yes! SH makes the sh sound.'
          },
          {
            type: 'read',
            image: 'ðŸŸðŸ âœ¨',
            sentence: 'The fish looks so fresh! The fresh fish shine in the shop. I see big fish and little fish on ice. The fish shells shine bright. Everything looks so fresh at this fish shop!',
            words: null,
            variants: [
              { sentence: 'The fish looks so fresh! I see big fish and little fish. They all shine!', words: null },
              { sentence: 'The fish looks so fresh! I see big fish and little fish. The fish can shine!', words: null },
              { sentence: 'The fish looks so fresh! I see big fish and little fish. Fresh fish can shine!', words: null }
            ],
            targetWords: ['fish', 'looks', 'fresh', 'see', 'big', 'little', 'They', 'shine'],
            teachWord: { word: 'fish', sound: 'sh', highlight: 'fi-SH', position: 'end' },
            sightWordFocus: 'looks',
            readingTip: 'Fish ends with SH! Listen: fi-SH. Fresh also ends with SH!'
          },
          {
            type: 'question',
            questionType: 'comprehension',
            questionMode: 'multipleChoice',
            question: 'How did the fish look?',
            passage: 'The fish looks so fresh!',
            comprehensionHint: 'Find the describing word.',
            variants: [
              { question: 'Which word describes the fish?', comprehensionHint: 'Read the sentence again.' },
              { question: 'What does the story say about the fish?', comprehensionHint: 'Look for the describing word.' },
              { question: 'How is the fish described?', comprehensionHint: 'Find the describing word.' }
            ],
            answers: [
              { name: 'Fresh', icon: 'âœ¨ðŸŸ' },
              { name: 'Dirty', icon: 'ðŸª£' },
              { name: 'Sleepy', icon: 'ðŸ˜´' }
            ],
            correctAnswerName: 'Fresh',
            successMessage: 'Yes! You remembered the describing word.'
          },
          {
            type: 'read',
            image: 'ðŸ¦ðŸ’•',
            sentence: 'I see pink shrimp in a shell! The fresh shrimp look so good. The shells are shiny and smooth. I wish I could have some shrimp!',
            words: null,
            variants: [
              { sentence: 'I see pink shrimp in a shell! The shrimp look so good. I wish I could have some!', words: null },
              { sentence: 'I see pink shrimp in a shell! I wish I could have some.', words: null },
              { sentence: 'I see pink shrimp in a shell! The shrimp look good. I wish I could try some!', words: null }
            ],
            targetWords: ['see', 'pink', 'shrimp', 'shell', 'look', 'good', 'wish', 'can', 'some'],
            teachWord: { word: 'shrimp', sound: 'sh', highlight: 'SH-rimp', position: 'start' },
            sightWordFocus: 'some',
            readingTip: 'Shrimp and shell start with SH. Fish and fresh end with SH.'
          },
          {
            type: 'question',
            questionType: 'comprehension',
            questionMode: 'multipleChoice',
            question: 'Where was the shrimp?',
            passage: 'I see pink shrimp in a shell!',
            comprehensionHint: 'Read the words in the box.',
            variants: [
              { question: 'Where do I see the shrimp?', comprehensionHint: 'Find the place words.' },
              { question: 'What tells where the shrimp was?', comprehensionHint: 'Look for the words in a. Then read the next word.' },
              { question: 'In the story, where was the shrimp?', comprehensionHint: 'Use the passage.' }
            ],
            answers: [
              { name: 'In a shell', icon: 'ðŸš' },
              { name: 'In a bowl', icon: 'ðŸ²' },
              { name: 'In a box', icon: 'ðŸ“¦' }
            ],
            correctAnswerName: 'In a shell',
            successMessage: 'Yes! You remembered where the shrimp was.'
          },
          {
            type: 'read',
            image: 'ðŸ‘¦ðŸŸðŸ¦',
            sentence: 'I wish for fish and shrimp. I wish for fresh fish from this shop! I wish for shrimp too. What should I get from the fish shop today? The fish looks so fresh and shiny. The shrimp in shells look good. I wish I could get both! Maybe I should get fish on a dish to share!',
            words: null,
            variants: [
              { sentence: 'I wish for fish and shrimp. I wish for fish from this shop. I wish for fresh shrimp too. What should I get from the fish shop today? The fish looks so good. The shrimp looks fresh. I wish I could get both of them. Maybe I should get fish in a dish!', words: null },
              { sentence: 'I wish for fish and shrimp. I wish for fish from the shop. I wish for fresh shrimp. What should I get today? The fish looks good. The shrimp looks fresh. I wish for both. I look at the shop menu.', words: null },
              { sentence: 'I wish for fish and shrimp. I wish for fish from this shop. I wish for shrimp. What should I get? The fish looks so good. The fresh shrimp looks good too. I wish I could get both. I think about what to get.', words: null }
            ],
            targetWords: ['wish', 'fish', 'shrimp', 'What', 'should', 'get', 'from', 'shop', 'fresh', 'dish'],
            teachWord: { word: 'wish', sound: 'sh', highlight: 'wi-SH', position: 'end' },
            sightWordFocus: 'from',
            readingTip: 'Count the SH words! Wish, fish, shrimp, shop. How many SH words?'
          },
          {
            type: 'menu',
            prompt: 'Pick from the fish shop!',
            menuStory: 'Everything at the shop is fresh! What do you wish for?',
            variants: [
              { prompt: 'Choose one thing from the shop.', menuStory: 'Read the choices. Then choose one.' },
              { prompt: 'What will you get?', menuStory: 'Think about what you wish for in the story.' },
              { prompt: 'Pick your food from the fish shop.', menuStory: 'Pick one thing to eat.' }
            ],
            items: [
              { name: 'Fish', icon: 'ðŸŸ', description: 'Fresh from the sea' },
              { name: 'Shrimp', icon: 'ðŸ¦', description: 'Pink and yummy' },
              { name: 'Crab', icon: 'ðŸ¦€', description: 'In a hard shell' }
            ]
          },
          {
            type: 'question',
            questionType: 'comprehension',
            questionMode: 'multipleChoice',
            question: 'What did I wish for?',
            passage: 'I wish for fish and shrimp.',
            comprehensionHint: 'Read the two wish sentences.',
            variants: [
              { question: 'Which two things did I wish for?', comprehensionHint: 'Look for the two wish words.' },
              { question: 'What do I wish to get?', comprehensionHint: 'Use the passage.' },
              { question: 'What does the character want from the shop?', comprehensionHint: 'Wish tells what you want.' }
            ],
            answers: [
              { name: 'Fish and shrimp', icon: 'ðŸŸðŸ¦' },
              { name: 'Fish and crab', icon: 'ðŸŸðŸ¦€' },
              { name: 'Shrimp and crab', icon: 'ðŸ¦ðŸ¦€' }
            ],
            correctAnswerName: 'Fish and shrimp',
            bonusQuestion: 'Can you find the SH sound in fish and shrimp?',
            successMessage: 'Yes! You remembered what the story said you wished for.'
          },
          {
            type: 'read',
            image: 'ðŸ˜‹ðŸŸâœ¨',
            sentence: 'My fresh fish is so good on this dish! The fish from the shop is the best I ever had. I wish for more. She got shrimp on her dish and it looks good too. The shrimp shells shine so bright. This shop is the best! I wish I could come back to this shop soon!',
            words: null,
            variants: [
              { sentence: 'My fresh fish is so good on this dish! The fish from the shop is the best. I wish for more. She got shrimp and her dish looks good too. The shells shine on her dish. This shop is the best! I wish I could come back soon!', words: null },
              { sentence: 'My fresh fish is so good on my dish! The fish from the shop is best. I wish for more. She got shrimp. Her dish looks good. The shells shine. This shop is the best! I wish I could come back!', words: null },
              { sentence: 'My fresh fish is so good! The fish from the shop is the best. I wish for more. She got shrimp on her dish. The shells shine bright. This shop is the best! I wish to come back soon!', words: null }
            ],
            targetWords: ['fresh', 'fish', 'is', 'good', 'wish', 'more', 'This', 'shop', 'best', 'dish', 'shrimp', 'She', 'shells', 'shine'],
            sightWordFocus: 'This',
            readingTip: 'You read many SH words. fish, fresh, wish, shop.'
          },
          {
            type: 'question',
            questionType: 'comprehension',
            questionMode: 'multipleChoice',
            question: 'What did I wish for?',
            passage: 'I wish for more.',
            comprehensionHint: 'What word completes the wish?',
            variants: [
              { question: 'In the story, what did I wish for?', comprehensionHint: 'Read the passage.' },
              { question: 'What does more mean here?', comprehensionHint: 'More means extra.' },
              { question: 'What did I want again?', comprehensionHint: 'Wish tells what you want.' }
            ],
            answers: [
              { name: 'More', icon: 'âž•' },
              { name: 'Less', icon: 'âž–' },
              { name: 'Nothing', icon: 'â­•' }
            ],
            correctAnswerName: 'More',
            successMessage: 'Yes! You remembered what you wished for.'
          }
          ,
          {
            type: 'question',
            questionType: 'comprehension',
            questionMode: 'multipleChoice',
            question: 'What did I think about the shop?',
            passage: 'This shop is the best!',
            comprehensionHint: 'The answer is in the sentence.',
            variants: [
              { question: 'How do I feel about the shop?', comprehensionHint: 'Look for the describing words about the shop.' },
              { question: 'What is my opinion of the shop?', comprehensionHint: 'Opinion means what you think.' },
              { question: 'What does the story say about the shop?', comprehensionHint: 'Use the passage.' }
            ],
            answers: [
              { name: 'It is the best', icon: '' },
              { name: 'It is noisy', icon: '' },
              { name: 'It is closed', icon: '' }
            ],
            correctAnswerName: 'It is the best',
            successMessage: 'Yes! You used the story to find the opinion.'
          }
        ]
      },

      // ===== LEVEL 4: TH AND CH DIGRAPHS =====
      // Focus: CH digraph (cheese, choose, lunch, chunk, sandwich)
      // Longer passages with multiple sentences
      // More comprehension and story elements
      cheese: {
        name: 'Cheese Shop',
        icon: 'ðŸ§€',
        level: 4,
        floor: 3,
        stickers: ['ðŸ§€', 'ðŸ¥ª', 'ðŸ”', 'â­'],
        digraphFocus: 'ch',
        sightWords: ['the', 'I', 'want', 'to', 'will', 'can', 'has', 'some', 'very', 'many'],
        previewWords: [
          { word: 'cheese', icon: 'ðŸ§€', isSightWord: false, hasDigraph: true, digraphPosition: 'start' },
          { word: 'choose', icon: 'ðŸ‘†', isSightWord: false, hasDigraph: true, digraphPosition: 'start' },
          { word: 'sandwich', icon: 'ðŸ¥ª', isSightWord: false, hasDigraph: true, digraphPosition: 'end' },
          { word: 'chunk', icon: 'ðŸ§±', isSightWord: false, hasDigraph: true, digraphPosition: 'start' }
        ],
        pages: [
          {
            type: 'read',
            image: 'ðŸš‚ðŸ§€ðŸª',
            sentence: 'I am at the cheese shop today! The CH sound is in cheese and chunk. C and H work together. CH makes the ch sound. It sounds like a choo choo train! I can hear CH in cheese, choose, chunk, and munch.',
            words: null,
            variants: [
              { sentence: 'I am at the cheese shop today! The CH sound is in cheese and chunk. C and H work together. CH makes the ch sound. It sounds like a choo choo train! I can hear CH in cheese, choose, chunk, and munch.', words: null },
              { sentence: 'I am at the cheese shop today! The CH sound is in cheese and chunk. C and H work together. CH makes the ch sound. It sounds like a choo choo train! I hear the CH sound in cheese and choose. I hear the CH sound in chunk and munch.', words: null },
              { sentence: 'I am at the cheese shop today! The CH sound is in cheese and chunk. C and H work together. CH makes the ch sound. It sounds like a choo choo train! I can hear the CH sound in cheese, choose, chunk, and munch.', words: null }
            ],
            targetWords: ['am', 'cheese', 'shop', 'CH', 'sound', 'like', 'choo', 'train', 'makes', 'chunk'],
            teachWord: { word: 'cheese', sound: 'ch', highlight: 'CH-eese', position: 'start' },
            sightWordFocus: 'like',
            requireSightWordTap: true,
            readingTip: 'CH is one sound. CH makes the ch sound.'
          },
          {
            type: 'question',
            questionType: 'sightWord',
            questionMode: 'multipleChoice',
            passage: 'CH makes the ch sound.',
            question: 'What sound do the letters CH make?',
            comprehensionHint: 'Say the word cheese. Listen for ch.',
            variants: [
              { question: 'What sound does CH make?', comprehensionHint: 'CH is one sound. Say cheese.' },
              { question: 'Which sound is made by CH?', comprehensionHint: 'C and H together say ch.' },
              { question: 'In the word chunk, what sound do CH make?', comprehensionHint: 'Chunk starts with ch.' }
            ],
            answers: [
              { name: 'ch', icon: '' },
              { name: 'sh', icon: '' },
              { name: 'th', icon: '' }
            ],
            correctAnswerName: 'ch',
            successMessage: 'Yes! CH makes the ch sound.'
          },
          {
            type: 'read',
            image: 'ðŸ§€ðŸ§€ðŸ§€ðŸŒˆ',
            sentence: 'I see big chunks of cheese on the shelf at this cheese shop! The shop has so many kinds to choose from. Some cheese is yellow and rich, and some cheese is white and soft. I can see tiny holes in one big chunk. A cheerful man at the shop gives me a chunk to try. I munch and chew the cheese. Yum! I want to choose one chunk to take home!',
            words: null,
            variants: [
              { sentence: 'I see big chunks of cheese on the shelf! The shop has so many kinds. Some cheese is yellow and rich, and some cheese is white and soft. I can see the holes in one big chunk. A nice man at the shop gives me a chunk to try. I munch on the cheese. I want to choose one to take home!', words: null },
              { sentence: 'I see big chunks of cheese on the shelf! The shop has so many kinds. Some cheese is yellow and rich, and some cheese is white and soft. I can see the holes in one big chunk. A nice man at the shop gives me a chunk to try. I munch on the cheese. I want to choose a kind.', words: null },
              { sentence: 'I see big chunks of cheese on the shelf! The shop has so many kinds. Some cheese is yellow and rich, and some cheese is white and soft. I can see the holes in one big chunk. A nice man at the shop gives me a chunk to try. I munch on the cheese. I look and choose one.', words: null }
            ],
            targetWords: ['see', 'chunks', 'cheese', 'shop', 'has', 'many', 'kinds', 'Some', 'yellow', 'white', 'want', 'choose'],
            teachWord: { word: 'chunks', sound: 'ch', highlight: 'CH-unks', position: 'start' },
            sightWordFocus: 'has',
            readingTip: 'Has tells what something has. The shop has many kinds.'
          },
          {
            type: 'question',
            questionType: 'comprehension',
            questionMode: 'multipleChoice',
            question: 'What colors were some cheese?',
            passage: 'Some cheese is yellow and rich, and some cheese is white and soft.',
            comprehensionHint: 'Read the two color sentences.',
            variants: [
              { question: 'Which colors does the story name?', comprehensionHint: 'Find the two color words.' },
              { question: 'What are two cheese colors?', comprehensionHint: 'Read the passage again.' },
              { question: 'Pick the colors from the passage.', comprehensionHint: 'Choose the exact words.' }
            ],
            answers: [
              { name: 'Yellow and white', icon: 'ðŸŸ¡âšªï¸' },
              { name: 'Pink and brown', icon: 'ðŸŒ¸ðŸ¤Ž' },
              { name: 'Red and green', icon: 'ðŸ”´ðŸŸ¢' }
            ],
            correctAnswerName: 'Yellow and white',
            successMessage: 'Great! You remembered the colors from the story.'
          },
          {
            type: 'read',
            image: 'ðŸ¥ªðŸ˜‹',
            sentence: 'I want to choose a cheese sandwich for lunch today! A sandwich has soft bread with chunks of cheese inside. A sandwich has bread and cheese. The man at the cheese shop will help me. He will choose the best cheese chunks for my sandwich. It will be very yummy and filling to munch on. I can eat each bite and chew it well. I will be so happy!',
            words: null,
            variants: [
              { sentence: 'I want a cheese sandwich for lunch today! A sandwich has soft bread and chunks of cheese. A sandwich has bread and cheese. The man will help me make my sandwich. He will choose the best cheese. It will be very yummy and filling. I can munch on it for my whole lunch. I can eat it all and feel happy!', words: null },
              { sentence: 'I want a cheese sandwich for lunch today! A sandwich has soft bread and chunks of cheese. A sandwich has bread and cheese. The man will help me make my sandwich. He will choose the best cheese. It will be very yummy and filling. I can eat it all and feel happy!', words: null },
              { sentence: 'I want a cheese sandwich for lunch today! A sandwich has soft bread and chunks of cheese. A sandwich has bread and cheese. The man will help me make my sandwich. He will choose the best cheese. It will be very yummy and filling. I can munch on it for my whole lunch.', words: null }
            ],
            targetWords: ['want', 'cheese', 'sandwich', 'lunch', 'has', 'bread', 'It', 'will', 'very', 'yummy', 'can', 'eat'],
            teachWord: { word: 'sandwich', sound: 'ch', highlight: 'sandwi-CH', position: 'end' },
            sightWordFocus: 'will',
            readingTip: 'Will tells what is going to happen. The man will help me.'
          },
          {
            type: 'question',
            questionType: 'comprehension',
            questionMode: 'multipleChoice',
            question: 'What does a sandwich have?',
            passage: 'A sandwich has bread and cheese.',
            comprehensionHint: 'Read the sentence in the box.',
            variants: [
              { question: 'Which foods are in the sandwich?', comprehensionHint: 'Look for two foods.' },
              { question: 'What does the story say a sandwich has?', comprehensionHint: 'Use the passage.' },
              { question: 'What two things does a sandwich have?', comprehensionHint: 'Find two foods in the sentence.' }
            ],
            answers: [
              { name: 'Bread and cheese', icon: 'ðŸ¥–ðŸ§€' },
              { name: 'Milk and tea', icon: 'ðŸ¥›ðŸµ' },
              { name: 'Fish and shrimp', icon: 'ðŸŸðŸ¦' }
            ],
            correctAnswerName: 'Bread and cheese',
            successMessage: 'Yes! You used the story to answer.'
          },
          {
            type: 'read',
            image: 'ðŸ‘¦ðŸ§€ðŸ‘¨â€ðŸ³',
            sentence: 'I will choose cheese today at the cheese shop! The cheerful man helps me pick which cheese to get. He shows me each chunk on the shelf. He gives me a big chunk. I try it and munch on it. I take a bite and chew. The cheese is so rich and good! I choose my favorite chunk right away. I say thank you very much to him. This cheese shop is the best in the whole town!',
            words: null,
            variants: [
              { sentence: 'I will choose cheese today! The nice man at the shop helps me pick. He shows me each chunk. He gives me a big chunk. I take a bite and munch. The cheese is so good! I choose my favorite chunk. I say thank you. The cheese shop is the best!', words: null },
              { sentence: 'I will choose cheese today! The nice man helps me pick. He shows me each chunk. He gives me a big chunk. I take a bite and munch. The cheese is so good! I choose my favorite chunk. I say thank you. The cheese shop is the best!', words: null },
              { sentence: 'I will choose cheese today! The man at the shop helps me pick. He shows me each chunk. He gives me a big chunk. I take a bite and munch. The cheese is so good! I choose my favorite chunk. The cheese shop is the best!', words: null }
            ],
            targetWords: ['will', 'choose', 'cheese', 'today', 'nice', 'man', 'shop', 'helps', 'gives', 'big', 'chunk', 'thank', 'much'],
            teachWord: { word: 'choose', sound: 'ch', highlight: 'CH-oose', position: 'start' },
            sightWordFocus: 'gives',
            readingTip: 'Gives means to hand something to someone. He gives me a chunk.'
          },
          {
            type: 'menu',
            prompt: 'What cheese dish do you want?',
            menuStory: 'The cheese shop has yummy foods! Which one will you choose?',
            variants: [
              { prompt: 'Choose a cheese dish.', menuStory: 'Read the choices. Then choose one.' },
              { prompt: 'What will you choose?', menuStory: 'Pick one cheese food.' },
              { prompt: 'Pick one cheese meal.', menuStory: 'Choose one option.' }
            ],
            items: [
              { name: 'Cheese', icon: 'ðŸ§€', description: 'Just cheese chunks' },
              { name: 'Sandwich', icon: 'ðŸ¥ª', description: 'Cheese in bread' },
              { name: 'Chips', icon: 'ðŸŸ', description: 'With cheese on top' }
            ]
          },
          {
            type: 'question',
            questionType: 'comprehension',
            questionMode: 'multipleChoice',
            question: 'What did the nice man give me?',
            passage: 'He gives me a big chunk.',
            comprehensionHint: 'Look for what he gives me.',
            variants: [
              { question: 'What did the man give me?', comprehensionHint: 'Read the words after gives me.' },
              { question: 'What did I get at the shop?', comprehensionHint: 'Use the passage.' },
              { question: 'What did the helper give me?', comprehensionHint: 'The helper is the nice man.' }
            ],
            answers: [
              { name: 'A big chunk', icon: 'ðŸ§±' },
              { name: 'A big cup', icon: 'ðŸ¥¤' },
              { name: 'A big cake', icon: 'ðŸ°' }
            ],
            correctAnswerName: 'A big chunk',
            bonusQuestion: 'Can you hear the CH sound in chunk?',
            successMessage: 'Great! You remembered what the man gave you.'
          },
          {
            type: 'read',
            image: 'ðŸ˜‹ðŸ§€ðŸŽ‰',
            sentence: 'My cheese sandwich is so yummy! I chose a good chunk of cheese for it. The cheese sandwich tastes very rich and good. I munch and chew each and every bite. The big chunk of cheese makes it extra delicious! I am so happy I chose to come to this cheese shop. I want to cheer and shout! I want to come back to this cheese shop soon!',
            words: null,
            variants: [
              { sentence: 'My cheese is so yummy! I chose a good chunk. The cheese sandwich tastes very good. I munch and chew each bite. The chunk of cheese makes it rich. I am so happy I chose this shop. I want to cheer! I want to come back to this cheese shop soon!', words: null },
              { sentence: 'My cheese is so yummy! I chose a good chunk. The cheese sandwich tastes very good. I munch and chew each bite. The chunk of cheese makes it rich. I want to cheer! I want to come back to this cheese shop soon!', words: null },
              { sentence: 'My cheese is so yummy! I chose a good chunk. The cheese sandwich tastes very good. I munch and chew each bite. I am so happy I chose this shop. I want to come back to this cheese shop soon!', words: null }
            ],
            targetWords: ['cheese', 'yummy', 'chose', 'good', 'sandwich', 'tastes', 'very', 'want', 'come', 'back', 'this', 'shop', 'soon'],
            sightWordFocus: 'come',
            readingTip: 'Come means to go to a place. I want to come back soon.'
          },
          {
            type: 'question',
            questionType: 'comprehension',
            questionMode: 'multipleChoice',
            question: 'What do I want to do soon?',
            passage: 'I want to come back to this cheese shop soon!',
            comprehensionHint: 'What does the character want to do?',
            variants: [
              { question: 'What does the character want to do next?', comprehensionHint: 'Look for what I want to do soon.' },
              { question: 'What do I want to do soon?', comprehensionHint: 'Read the passage again.' },
              { question: 'What is my plan?', comprehensionHint: 'Plan means what you want to do.' }
            ],
            answers: [
              { name: 'Come back', icon: 'â†©ï¸' },
              { name: 'Go to bed', icon: 'ðŸ›ï¸' },
              { name: 'Go home', icon: 'ðŸ ' }
            ],
            correctAnswerName: 'Come back',
            successMessage: 'Yes! You remembered what you wanted to do.'
          }
        ]
      },
      noodle: {
        name: 'Noodle House',
        icon: 'ðŸœ',
        level: 4,
        floor: 3,
        stickers: ['ðŸœ', 'ðŸ¥¢', 'ðŸ²', 'â­'],
        digraphFocus: 'th',
        sightWords: ['the', 'they', 'this', 'that', 'there', 'I', 'want', 'will', 'think', 'with'],
        previewWords: [
          { word: 'the', icon: 'ðŸ‘‰', isSightWord: true, hasDigraph: true, digraphPosition: 'start' },
          { word: 'this', icon: 'ðŸ‘†', isSightWord: true, hasDigraph: true, digraphPosition: 'start' },
          { word: 'thick', icon: 'ðŸ’ª', isSightWord: false, hasDigraph: true, digraphPosition: 'start' },
          { word: 'that', icon: 'ðŸ‘‡', isSightWord: true, hasDigraph: true, digraphPosition: 'start' }
        ],
        pages: [
          {
            type: 'read',
            image: 'ðŸš‚ðŸœðŸª',
            sentence: 'I am at the noodle house today! The TH sound is in the word the. The TH sound is in the word this. The TH sound is in the word that. TH makes the th sound. You make the TH sound with your tongue out a little. I can hear TH in the word they. I can hear TH in the word think.',
            words: null,
            variants: [
              { sentence: 'I am at the noodle house today! The TH sound is in the word the. The TH sound is in the word this. The TH sound is in the word that. TH makes the th sound. You make the TH sound with your tongue out a little. I can hear TH in the word they. I can hear TH in the word think.', words: null },
              { sentence: 'I am at the noodle house today! The TH sound is in the word the. The TH sound is in the word this. The TH sound is in the word that. TH makes the th sound. You make the TH sound with your tongue out a little. I can hear TH in the word think. I can hear TH in the word they.', words: null },
              { sentence: 'I am at the noodle house today! The TH sound is in the word this. The TH sound is in the word that. The TH sound is in the word the. TH makes the th sound. You make the TH sound with your tongue out a little. I can hear TH in the word they. I can hear TH in the word think.', words: null }
            ],
            targetWords: ['am', 'the', 'noodle', 'house', 'TH', 'sound', 'makes', 'with', 'your', 'tongue'],
            teachWord: { word: 'the', sound: 'th', highlight: 'TH-e', position: 'start' },
            sightWordFocus: 'with',
            requireSightWordTap: true,
            readingTip: 'Put your tongue out a little for TH. You make the sound with your tongue.'
          },
          {
            type: 'question',
            questionType: 'sightWord',
            questionMode: 'multipleChoice',
            question: 'What sound do the letters TH make?',
            passage: 'TH makes the th sound.',
            comprehensionHint: 'Say the word the. Listen for th.',
            variants: [
              { question: 'What sound does TH make?', comprehensionHint: 'TH is one sound. Say the.' },
              { question: 'Which sound is made by TH?', comprehensionHint: 'T and H together say th.' },
              { question: 'In the word this, what sound do TH make?', comprehensionHint: 'This starts with th.' }
            ],
            answers: [
              { name: 'th', icon: '' },
              { name: 'ch', icon: '' },
              { name: 'sh', icon: '' }
            ],
            correctAnswerName: 'th',
            successMessage: 'Yes! TH makes the th sound.'
          },
          {
            type: 'read',
            image: 'ðŸœðŸœðŸœðŸ’¨',
            sentence: 'I see the hot noodles at this noodle house! They sit in big bowls on the counter. The steam goes up in the air. The noodles smell so amazing! I think they will be very good! I can feel the warmth coming from the bowls. This shop makes the best noodles in the whole town!',
            words: null,
            variants: [
              { sentence: 'I see the hot noodles at the shop. They are in big bowls on the counter. The steam goes up in the air. The noodles smell so good! I think they will be very good! I can feel the warmth from the bowls. This shop makes the best noodles!', words: null },
              { sentence: 'I see the hot noodles at the shop. They are in big bowls on the counter. The steam goes up in the air. The noodles smell so good! I think they will be very good! I can feel the warmth from the bowls. This shop makes the best noodles!', words: null },
              { sentence: 'I see the hot noodles at the shop. The bowls are big and on the counter. The steam goes up in the air. The noodles smell so good! I think they will be very good! I can feel the warmth from the bowls. This shop makes the best noodles!', words: null }
            ],
            targetWords: ['see', 'the', 'hot', 'noodles', 'shop', 'They', 'big', 'bowls', 'steam', 'goes', 'air', 'think', 'will', 'very', 'good'],
            teachWord: { word: 'They', sound: 'th', highlight: 'TH-ey', position: 'start' },
            sightWordFocus: 'They',
            readingTip: 'They means more than one. They are in bowls. They smell good.'
          },
          {
            type: 'question',
            questionType: 'comprehension',
            questionMode: 'multipleChoice',
            question: 'Where did the steam go?',
            passage: 'The steam goes up in the air.',
            comprehensionHint: 'Read the sentence in the box.',
            variants: [
              { question: 'What happened to the steam?', comprehensionHint: 'Use the passage.' },
              { question: 'In the story, where did the steam go?', comprehensionHint: 'Look for the words up and air.' },
              { question: 'Where does the steam go?', comprehensionHint: 'Find the direction word.' }
            ],
            answers: [
              { name: 'Up in the air', icon: 'â¬†ï¸ðŸ’¨' },
              { name: 'Down on the floor', icon: 'â¬‡ï¸ðŸ§¹' },
              { name: 'Into the bowl', icon: 'ðŸ²' }
            ],
            correctAnswerName: 'Up in the air',
            successMessage: 'Yes! You remembered a detail from the story.'
          },
          {
            type: 'question',
            questionType: 'comprehension',
            questionMode: 'multipleChoice',
            question: 'What did I think about the noodles?',
            passage: 'I think they will be very good!',
            comprehensionHint: 'Read the words after I think.',
            variants: [
              { question: 'What do I think will happen?', comprehensionHint: 'Read the words after I think.' },
              { question: 'In the story, what did I think?', comprehensionHint: 'Use the passage.' },
              { question: 'What do I think?', comprehensionHint: 'Read the words after I think.' }
            ],
            answers: [
              { name: 'They will be very good', icon: '' },
              { name: 'They will be very cold', icon: '' },
              { name: 'They will be very bad', icon: '' }
            ],
            correctAnswerName: 'They will be very good',
            successMessage: 'Yes! You found what I thought.'
          },
          {
            type: 'read',
            image: 'ðŸ²ðŸ”¥ðŸ˜‹',
            sentence: 'This soup at the noodle house is so hot and delicious! I smell the yummy broth. The amazing smell fills the whole room. There are many good things floating in the soup. I see thick noodles and other things in there. The broth looks thick and very rich. I want to taste it right away! I want to eat it all with these chopsticks!',
            words: null,
            variants: [
              { sentence: 'This soup is so hot and good! I smell the yummy broth. The smell fills the air. There are many things in the soup. I see noodles and things floating. The broth looks thick and rich. I want to taste it! I want to eat it all with chopsticks!', words: null },
              { sentence: 'This soup is so hot and good! I smell the yummy broth. The smell fills the air. There are many things in the soup. I see noodles and things floating. The broth looks thick and rich. I want to eat it all with chopsticks!', words: null },
              { sentence: 'This soup is so hot and good! I smell the yummy broth. The smell fills the air. There are many things in the soup. I see noodles and things floating. The broth looks thick and rich. I want to taste it!', words: null }
            ],
            targetWords: ['This', 'soup', 'hot', 'good', 'smell', 'the', 'yummy', 'broth', 'There', 'many', 'things', 'want', 'eat'],
            teachWord: { word: 'This', sound: 'th', highlight: 'TH-is', position: 'start' },
            sightWordFocus: 'There',
            readingTip: 'There tells where something is. There are noodles in the soup.'
          },
          {
            type: 'question',
            questionType: 'comprehension',
            questionMode: 'multipleChoice',
            question: 'What did I smell?',
            passage: 'I smell the yummy broth.',
            comprehensionHint: 'Read the sentence in the box.',
            variants: [
              { question: 'What smell did I notice?', comprehensionHint: 'Find the words after smell.' },
              { question: 'In the story, what did I smell?', comprehensionHint: 'Use the passage.' },
              { question: 'What did I smell in the soup?', comprehensionHint: 'Look for broth.' }
            ],
            answers: [
              { name: 'Yummy broth', icon: 'ðŸ²' },
              { name: 'Yummy noodles', icon: 'ðŸœ' },
              { name: 'Yummy rice', icon: 'ðŸš' }
            ],
            correctAnswerName: 'Yummy broth',
            successMessage: 'Great! You found the right detail.'
          },
          {
            type: 'read',
            image: 'ðŸ‘¦ðŸœðŸ¥¢',
            sentence: 'I want that big bowl over there on the counter! The one with all the thick noodles inside. The noodles look thick and long. They are smooth and shiny in the broth. I think I will use chopsticks. I am very hungry right now! This is the perfect meal for me to eat!',
            words: null,
            variants: [
              { sentence: 'I want that bowl over there! The one with the thick noodles. The noodles look thick and long. They are smooth and shiny. I think I will use chopsticks. I am very hungry now! This is the perfect meal for me!', words: null },
              { sentence: 'I want that bowl over there! The one with the thick noodles. The noodles look thick and long. They are smooth and shiny. I think I will use chopsticks. This is the perfect meal for me!', words: null },
              { sentence: 'I want that bowl over there! The one with the thick noodles. The noodles look thick and long. They are smooth and shiny. I think I will use chopsticks. I am hungry now! This is the perfect meal for me!', words: null }
            ],
            targetWords: ['want', 'that', 'bowl', 'over', 'there', 'The', 'noodles', 'look', 'thick', 'long', 'think', 'will', 'chopsticks', 'very', 'hungry'],
            teachWord: { word: 'that', sound: 'th', highlight: 'TH-at', position: 'start' },
            sightWordFocus: 'think',
            readingTip: 'Think means to use your brain. I think I will use chopsticks.'
          },
          {
            type: 'question',
            questionType: 'comprehension',
            questionMode: 'multipleChoice',
            question: 'What will I use to eat the noodles?',
            passage: 'I think I will use chopsticks.',
            comprehensionHint: 'Read the sentence in the box.',
            variants: [
              { question: 'What will I use?', comprehensionHint: 'Look for the tool word.' },
              { question: 'In the story, what will I use to eat?', comprehensionHint: 'Use the passage.' },
              { question: 'What tool will I use?', comprehensionHint: 'Find the tool word.' }
            ],
            answers: [
              { name: 'Chopsticks', icon: 'ðŸ¥¢' },
              { name: 'A fork', icon: 'ðŸ´' },
              { name: 'My hands', icon: 'ðŸ¤²' }
            ],
            correctAnswerName: 'Chopsticks',
            bonusQuestion: 'Can you say the thick noodles and hear the TH sound?',
            successMessage: 'Yes! You remembered what the story said.'
          },
          {
            type: 'menu',
            prompt: 'Which yummy food do you want?',
            menuStory: 'The noodle house has many yummy things! What will you pick?',
            variants: [
              { prompt: 'Choose one food.', menuStory: 'Read the choices. Then choose one.' },
              { prompt: 'What will you eat?', menuStory: 'Pick one food from the noodle house.' },
              { prompt: 'Pick your meal.', menuStory: 'Choose one option.' }
            ],
            items: [
              { name: 'Noodles', icon: 'ðŸœ', description: 'Long and thick' },
              { name: 'Soup', icon: 'ðŸ²', description: 'Hot and yummy' },
              { name: 'Rice', icon: 'ðŸš', description: 'Soft and white' }
            ]
          },
          {
            type: 'question',
            questionType: 'comprehension',
            questionMode: 'multipleChoice',
            question: 'How did the noodles look?',
            passage: 'The noodles look thick and long.',
            comprehensionHint: 'Read the describing words.',
            variants: [
              { question: 'Which words describe the noodles?', comprehensionHint: 'Find the describing words in the passage.' },
              { question: 'In the story, how do the noodles look?', comprehensionHint: 'Use the passage.' },
              { question: 'What does the story say about the noodles?', comprehensionHint: 'Look for two describing words.' }
            ],
            answers: [
              { name: 'Thick and long', icon: 'ðŸ’ªðŸ“' },
              { name: 'Thin and long', icon: 'ðŸ“' },
              { name: 'Thick and short', icon: 'ðŸ’ª' }
            ],
            correctAnswerName: 'Thick and long',
            successMessage: 'Yes! You remembered how the story described the noodles.'
          },
          {
            type: 'read',
            image: 'ðŸ˜‹ðŸœðŸ‘¨â€ðŸ³',
            sentence: 'The noodles from this noodle house are so good! They are thick and very tasty. The warm broth fills my whole mouth with flavor. I slurp the long noodles with my chopsticks. I think this is the very best meal I have ever had! The cook at this shop made these noodles perfectly. I feel so happy and full! I want to thank the cook!',
            words: null,
            variants: [
              { sentence: 'The noodles are so good! They are thick and tasty. The broth is warm and fills my mouth. I slurp the noodles with my chopsticks. I think this is the best meal! The cook made this perfectly. I feel so happy! I want to thank the cook!', words: null },
              { sentence: 'The noodles are so good! They are thick and tasty. The broth is warm and fills my mouth. I slurp the noodles with my chopsticks. The cook made this perfectly. I feel so happy! I want to thank the cook!', words: null },
              { sentence: 'The noodles are so good! They are thick and tasty. The broth is warm and fills my mouth. I slurp the noodles with my chopsticks. I think this is the best meal! I feel so happy! I want to thank the cook!', words: null }
            ],
            targetWords: ['The', 'noodles', 'good', 'They', 'thick', 'tasty', 'think', 'this', 'the', 'best', 'meal', 'want', 'thank', 'cook'],
            sightWordFocus: 'thank',
            readingTip: 'Thank is what you say to be kind. I thank the cook.'
          },
          {
            type: 'question',
            questionType: 'comprehension',
            questionMode: 'multipleChoice',
            question: 'Who do I want to thank?',
            passage: 'I want to thank the cook!',
            comprehensionHint: 'Read the sentence in the box.',
            variants: [
              { question: 'Who does the story say I want to thank?', comprehensionHint: 'Use the passage.' },
              { question: 'Who do I want to thank?', comprehensionHint: 'Find the person word.' },
              { question: 'Who helped make the meal?', comprehensionHint: 'Think about who makes the meal.' }
            ],
            answers: [
              { name: 'The cook', icon: 'ðŸ‘¨â€ðŸ³' },
              { name: 'The train', icon: 'ðŸš‚' },
              { name: 'The bowl', icon: 'ðŸ²' }
            ],
            correctAnswerName: 'The cook',
            successMessage: 'Yes! You remembered who I want to thank.'
          }
        ]
      }
      ,
      // ===== NEW STATIONS (7 additional) =====

      // Red Bean Bread (Level 1 - CVC Consolidation)
      redbean: {
        name: 'Red Bean Bread',
        icon: 'ðŸž',
        level: 1,
        floor: 3,
        stickers: ['ðŸž', 'ðŸ«˜', 'ðŸ¥–', 'â­'],
        sightWords: ['I', 'see', 'a', 'the', 'is', 'my', 'want', 'like', 'can', 'good'],
        previewWords: [
          { word: 'red', icon: 'ðŸ”´', isSightWord: false, phonicsNote: 'r-e-d (CVC)' },
          { word: 'bean', icon: 'ðŸ«˜', isSightWord: false, phonicsNote: 'b-ea-n' },
          { word: 'bread', icon: 'ðŸž', isSightWord: false, phonicsNote: 'br-ea-d' },
          { word: 'want', icon: 'ðŸ‘†', isSightWord: true }
        ],
        pages: [
          { type: 'read', image: 'ðŸš‚ðŸž', sentence: 'I am at the red bean bread shop. I see fresh bread on the shelf. The bread is warm. It smells so good! I can see red beans inside. The beans are sweet.', words: null, targetWords: ['red', 'bean', 'bread', 'warm', 'sweet'], sightWordFocus: 'the', readingTip: 'Red bean bread is a popular treat in Taiwan!' },
          { type: 'question', questionType: 'comprehension', questionMode: 'multipleChoice', passage: 'I am at the red bean bread shop.', question: 'Where am I?', comprehensionHint: 'Find the name of the shop.', answers: [{ name: 'Red Bean Bread Shop', icon: 'ðŸž' }, { name: 'Fruit Stand', icon: 'ðŸŽ' }, { name: 'Pizza Place', icon: 'ðŸ•' }], correctAnswerName: 'Red Bean Bread Shop', successMessage: 'Yes! You found the setting.' },
          { type: 'read', image: 'ðŸžðŸ˜‹', sentence: 'I pick a big bun. The bun is soft and warm. I take a bite. Yum! The red beans are sweet inside. This is so good! I like red bean bread a lot.', words: null, targetWords: ['big', 'bun', 'soft', 'warm', 'bite', 'sweet'], sightWordFocus: 'like', readingTip: 'Notice the CVC words: big, bun, red, lot!' },
          { type: 'menu', prompt: 'Pick your bread!', menuStory: 'The bread looks so good. What will you pick?', items: [{ name: 'Red Bean Bun', icon: 'ðŸž', description: 'Sweet and soft' }, { name: 'Plain Roll', icon: 'ðŸ¥–', description: 'Simple and warm' }, { name: 'Sesame Bread', icon: 'ðŸ¥¯', description: 'Crunchy seeds' }] },
          { type: 'question', questionType: 'comprehension', questionMode: 'multipleChoice', passage: 'The red beans are sweet inside.', question: 'How do the red beans taste?', comprehensionHint: 'Find the taste word.', answers: [{ name: 'Sweet', icon: 'ðŸ¬' }, { name: 'Sour', icon: 'ðŸ‹' }, { name: 'Spicy', icon: 'ðŸŒ¶ï¸' }], correctAnswerName: 'Sweet', successMessage: 'Yes! The red beans are sweet!' }
        ]
      },

      // Bubble Tea (Level 2 - Compound Words)
      bubbletea: {
        name: 'Bubble Tea',
        icon: 'ðŸ§‹',
        level: 2,
        floor: 3,
        stickers: ['ðŸ§‹', 'ðŸ«§', 'ðŸ¥¤', 'â­'],
        sightWords: ['I', 'see', 'want', 'to', 'get', 'some', 'very', 'my', 'this', 'with'],
        previewWords: [
          { word: 'bubble', icon: 'ðŸ«§', isSightWord: false, phonicsNote: 'bub-ble (2 syllables)' },
          { word: 'tea', icon: 'ðŸµ', isSightWord: false, phonicsNote: 't-ea' },
          { word: 'tapioca', icon: 'âš«', isSightWord: false, phonicsNote: 'tap-i-o-ca (4 syllables)' },
          { word: 'want', icon: 'ðŸ‘†', isSightWord: true }
        ],
        pages: [
          { type: 'read', image: 'ðŸš‚ðŸ§‹', sentence: 'I am at the bubble tea shop. I see many cups with tea inside. The tea has bubbles at the bottom! The bubbles are tapioca pearls. They look so fun to drink!', words: null, targetWords: ['bubble', 'tea', 'cups', 'bubbles', 'tapioca', 'pearls'], sightWordFocus: 'with', readingTip: 'Bubble tea is a famous drink from Taiwan!' },
          { type: 'question', questionType: 'comprehension', questionMode: 'multipleChoice', passage: 'The bubbles are tapioca pearls.', question: 'What are the bubbles made of?', comprehensionHint: 'Find the word that tells what the bubbles are.', answers: [{ name: 'Tapioca pearls', icon: 'âš«' }, { name: 'Candy', icon: 'ðŸ¬' }, { name: 'Ice', icon: 'ðŸ§Š' }], correctAnswerName: 'Tapioca pearls', successMessage: 'Yes! Tapioca pearls are the bubbles!' },
          { type: 'read', image: 'ðŸ§‹ðŸ˜Š', sentence: 'I want to get some bubble tea. I pick milk tea with bubbles. The cup is cold in my hand. I sip the tea with a big straw. The bubbles pop in my mouth! This is so yummy!', words: null, targetWords: ['bubble', 'milk', 'tea', 'cold', 'straw', 'pop', 'mouth'], sightWordFocus: 'some', readingTip: 'Milk tea is two words. Milk and tea.' },
          { type: 'menu', prompt: 'Pick your bubble tea!', menuStory: 'So many flavors! What will you pick?', items: [{ name: 'Milk Tea', icon: 'ðŸ§‹', description: 'Classic and creamy' }, { name: 'Fruit Tea', icon: 'ðŸ“', description: 'Fresh and fruity' }, { name: 'Green Tea', icon: 'ðŸµ', description: 'Light and fresh' }] },
          { type: 'question', questionType: 'comprehension', questionMode: 'multipleChoice', passage: 'I sip the tea with a big straw.', question: 'How do I drink the tea?', comprehensionHint: 'Find the tool used for drinking.', answers: [{ name: 'With a straw', icon: 'ðŸ¥¤' }, { name: 'With a spoon', icon: 'ðŸ¥„' }, { name: 'With a cup', icon: 'â˜•' }], correctAnswerName: 'With a straw', successMessage: 'Yes! You use a big straw for bubble tea!' }
        ]
      },

      // Burger Joint (Level 2 - Action Words)
      burger: {
        name: 'Burger Joint',
        icon: 'ðŸ”',
        level: 2,
        floor: 3,
        stickers: ['ðŸ”', 'ðŸŸ', 'ðŸ¥¤', 'â­'],
        sightWords: ['I', 'see', 'want', 'to', 'eat', 'some', 'very', 'big', 'my', 'this'],
        previewWords: [
          { word: 'burger', icon: 'ðŸ”', isSightWord: false, phonicsNote: 'bur-ger (2 syllables)' },
          { word: 'fries', icon: 'ðŸŸ', isSightWord: false, phonicsNote: 'fr-ies' },
          { word: 'bite', icon: 'ðŸ˜‹', isSightWord: false, phonicsNote: 'b-i-te (silent e)' },
          { word: 'eat', icon: 'ðŸ½ï¸', isSightWord: true }
        ],
        pages: [
          { type: 'read', image: 'ðŸš‚ðŸ”', sentence: 'I am at the burger joint. I see big burgers on the menu. The burgers have meat and cheese. I also see fries! The fries are golden and crispy.', words: null, targetWords: ['burger', 'big', 'meat', 'cheese', 'fries', 'golden', 'crispy'], sightWordFocus: 'see', readingTip: 'Action words tell us what happens: see, eat, bite!' },
          { type: 'question', questionType: 'comprehension', questionMode: 'multipleChoice', passage: 'The fries are golden and crispy.', question: 'What are the fries like?', comprehensionHint: 'Find the words that describe the fries.', answers: [{ name: 'Golden and crispy', icon: 'ðŸŸ' }, { name: 'Cold and wet', icon: 'ðŸ’§' }, { name: 'Soft and white', icon: 'âšª' }], correctAnswerName: 'Golden and crispy', successMessage: 'Yes! The fries are golden and crispy!' },
          { type: 'read', image: 'ðŸ”ðŸ˜‹', sentence: 'I want to eat a big burger. I pick it up with my hands. I take a big bite. Mmm! The cheese is melty. The meat is juicy. I chew and chew. This is so good!', words: null, targetWords: ['eat', 'pick', 'bite', 'chew', 'melty', 'juicy'], sightWordFocus: 'eat', readingTip: 'Notice the action words: eat, pick, bite, chew!' },
          { type: 'menu', prompt: 'Pick your meal!', menuStory: 'Time to order! What will you pick?', items: [{ name: 'Burger', icon: 'ðŸ”', description: 'Big and juicy' }, { name: 'Fries', icon: 'ðŸŸ', description: 'Golden and crispy' }, { name: 'Both!', icon: 'ðŸ”ðŸŸ', description: 'A full meal' }] },
          { type: 'question', questionType: 'comprehension', questionMode: 'multipleChoice', passage: 'I take a big bite.', question: 'What action word tells how I eat?', comprehensionHint: 'Find the word that shows eating.', answers: [{ name: 'Bite', icon: 'ðŸ˜‹' }, { name: 'Sleep', icon: 'ðŸ˜´' }, { name: 'Run', icon: 'ðŸƒ' }], correctAnswerName: 'Bite', successMessage: 'Yes! Bite is the action word.' }
        ]
      },

      // Sushi Bar (Level 3 - sh digraph practice)
      sushi: {
        name: 'Sushi Bar',
        icon: 'ðŸ£',
        level: 3,
        floor: 3,
        stickers: ['ðŸ£', 'ðŸ±', 'ðŸ¥¢', 'â­'],
        digraphFocus: 'sh',
        sightWords: ['the', 'look', 'they', 'want', 'some', 'I', 'see', 'so', 'for', 'my'],
        previewWords: [
          { word: 'sushi', icon: 'ðŸ£', isSightWord: false, hasDigraph: true, digraphPosition: 'middle' },
          { word: 'fish', icon: 'ðŸŸ', isSightWord: false, hasDigraph: true, digraphPosition: 'end' },
          { word: 'fresh', icon: 'âœ¨', isSightWord: false, hasDigraph: true, digraphPosition: 'end' },
          { word: 'dish', icon: 'ðŸ½ï¸', isSightWord: false, hasDigraph: true, digraphPosition: 'end' }
        ],
        pages: [
          { type: 'read', image: 'ðŸš‚ðŸ£', sentence: 'I am at the sushi bar. I see fresh fish on a dish. The sushi looks so good! The fish shines in the light. I wish I could eat it all!', words: null, targetWords: ['sushi', 'fresh', 'fish', 'dish', 'shines', 'wish'], sightWordFocus: 'the', readingTip: 'Listen for the sh sound. sushi, fish, dish, shines, wish.' },
          { type: 'question', questionType: 'sightWord', questionMode: 'multipleChoice', passage: 'The fish shines in the light.', question: 'Which word ends with sh?', comprehensionHint: 'Say each word. Listen for sh at the end.', answers: [{ name: 'fish', icon: 'ðŸŸ' }, { name: 'shines', icon: 'âœ¨' }, { name: 'light', icon: 'ðŸ’¡' }], correctAnswerName: 'fish', successMessage: 'Yes! Fish ends with the sh sound.' },
          { type: 'read', image: 'ðŸ£ðŸ˜Š', sentence: 'I pick some sushi to share. The chef makes a fresh dish for me. I use chopsticks to eat. The fish is so fresh! I shall come back soon!', words: null, targetWords: ['sushi', 'share', 'fresh', 'dish', 'shall'], sightWordFocus: 'some', readingTip: 'Share and shall also have the sh sound.' },
          { type: 'menu', prompt: 'Pick your sushi!', menuStory: 'The sushi looks fresh! What will you pick?', items: [{ name: 'Fish Sushi', icon: 'ðŸ£', description: 'Fresh fish on rice' }, { name: 'Shrimp Roll', icon: 'ðŸ¦', description: 'Shrimp inside' }, { name: 'Veggie Roll', icon: 'ðŸ¥¬', description: 'Fresh vegetables' }] },
          { type: 'question', questionType: 'sightWord', questionMode: 'multipleChoice', passage: 'The sushi is fresh.', question: 'Which word has sh in the middle?', comprehensionHint: 'Say each word slowly. Listen for sh in the middle.', answers: [{ name: 'sushi', icon: 'ðŸ£' }, { name: 'fish', icon: 'ðŸŸ' }, { name: 'fresh', icon: 'âœ¨' }], correctAnswerName: 'sushi', successMessage: 'Yes! Sushi has sh in the middle.' }
        ]
      },

      // Chicken Hut (Level 3 - ch digraph practice)
      chicken: {
        name: 'Chicken Hut',
        icon: 'ðŸ—',
        level: 3,
        floor: 3,
        stickers: ['ðŸ—', 'ðŸ”', 'ðŸ³', 'â­'],
        digraphFocus: 'ch',
        sightWords: ['the', 'I', 'want', 'to', 'will', 'can', 'has', 'some', 'very', 'many'],
        previewWords: [
          { word: 'chicken', icon: 'ðŸ—', isSightWord: false, hasDigraph: true, digraphPosition: 'start' },
          { word: 'crunchy', icon: 'âœ¨', isSightWord: false, hasDigraph: true, digraphPosition: 'middle' },
          { word: 'munch', icon: 'ðŸ˜‹', isSightWord: false, hasDigraph: true, digraphPosition: 'end' },
          { word: 'choice', icon: 'ðŸ‘†', isSightWord: false, hasDigraph: true, digraphPosition: 'start' }
        ],
        pages: [
          { type: 'read', image: 'ðŸš‚ðŸ—', sentence: 'I am at the chicken hut. I see chicken cooking! The chicken is crunchy and golden. I can choose what I want. There are so many choices!', words: null, targetWords: ['chicken', 'crunchy', 'choose', 'choices'], sightWordFocus: 'the', readingTip: 'Listen for the ch sound. chicken, crunchy, choose, choices.' },
          { type: 'question', questionType: 'sightWord', questionMode: 'multipleChoice', passage: 'The chicken is crunchy.', question: 'Which word starts with the ch sound?', comprehensionHint: 'Say each word. Listen for ch at the start.', answers: [{ name: 'chicken', icon: 'ðŸ—' }, { name: 'golden', icon: 'âœ¨' }, { name: 'crunchy', icon: 'ðŸ”Š' }], correctAnswerName: 'chicken', successMessage: 'Yes! Chicken starts with the ch sound.' },
          { type: 'read', image: 'ðŸ—ðŸ˜Š', sentence: 'I choose a big piece of chicken. I munch on it. Crunch, crunch! It is so crunchy! Each bite is yummy. I chew and chew. This is the best chicken!', words: null, targetWords: ['choose', 'chicken', 'munch', 'crunch', 'crunchy', 'each', 'chew'], sightWordFocus: 'each', readingTip: 'Munch and crunch end with the ch sound.' },
          { type: 'menu', prompt: 'Make your choice!', menuStory: 'The chicken smells so good! What will you choose?', items: [{ name: 'Chicken Leg', icon: 'ðŸ—', description: 'Big and crunchy' }, { name: 'Chicken Wing', icon: 'ðŸ”', description: 'Small and crispy' }, { name: 'Chicken Chunks', icon: 'ðŸ–', description: 'Bite-sized pieces' }] },
          { type: 'question', questionType: 'sightWord', questionMode: 'multipleChoice', passage: 'I munch on the crunchy chicken.', question: 'Which word ends with ch?', comprehensionHint: 'Say each word slowly. Listen for ch at the end.', answers: [{ name: 'munch', icon: 'ðŸ˜‹' }, { name: 'chicken', icon: 'ðŸ—' }, { name: 'choose', icon: 'ðŸ‘†' }], correctAnswerName: 'munch', successMessage: 'Yes! Munch ends with the ch sound.' }
        ]
      },

      // Smoothie Stand (Level 4 - th digraph practice)
      smoothie: {
        name: 'Smoothie Stand',
        icon: 'ðŸ¥¤',
        level: 4,
        floor: 3,
        stickers: ['ðŸ¥¤', 'ðŸ“', 'ðŸ¥­', 'â­'],
        digraphFocus: 'th',
        sightWords: ['the', 'they', 'this', 'that', 'there', 'I', 'want', 'will', 'think', 'with'],
        previewWords: [
          { word: 'the', icon: 'ðŸ‘‰', isSightWord: true, hasDigraph: true, digraphPosition: 'start' },
          { word: 'this', icon: 'ðŸ‘†', isSightWord: true, hasDigraph: true, digraphPosition: 'start' },
          { word: 'thick', icon: 'ðŸ¥¤', isSightWord: false, hasDigraph: true, digraphPosition: 'start' },
          { word: 'smooth', icon: 'âœ¨', isSightWord: false, hasDigraph: true, digraphPosition: 'end' }
        ],
        pages: [
          { type: 'read', image: 'ðŸš‚ðŸ¥¤', sentence: 'I am at the smoothie stand. I see thick smoothies there. This one has mango. That one has berries. I think they all look good!', words: null, targetWords: ['the', 'thick', 'there', 'this', 'that', 'think', 'they'], sightWordFocus: 'there', readingTip: 'Listen for the th sound. the, thick, there, this, that, think, they.' },
          { type: 'question', questionType: 'sightWord', questionMode: 'multipleChoice', passage: 'This one has mango. That one has berries.', question: 'Which two words start with th?', comprehensionHint: 'Find the pointing words that start with th.', answers: [{ name: 'This and That', icon: 'ðŸ‘†' }, { name: 'One and Has', icon: '1ï¸âƒ£' }, { name: 'Mango and Berries', icon: 'ðŸ“' }], correctAnswerName: 'This and That', successMessage: 'Yes! This and that both start with th.' },
          { type: 'read', image: 'ðŸ¥¤ðŸ˜Š', sentence: 'I think I want this thick smoothie. The fruit is fresh. They blend it smooth. I drink it through a straw. Mmm! This is the best thing ever!', words: null, targetWords: ['think', 'this', 'thick', 'the', 'they', 'smooth', 'through', 'thing'], sightWordFocus: 'think', readingTip: 'Smooth and through end with the th sound.' },
          { type: 'menu', prompt: 'Pick your smoothie!', menuStory: 'They all look thick and yummy! What will you pick?', items: [{ name: 'Mango Smoothie', icon: 'ðŸ¥­', description: 'Thick and tropical' }, { name: 'Berry Smoothie', icon: 'ðŸ“', description: 'Sweet and smooth' }, { name: 'Banana Smoothie', icon: 'ðŸŒ', description: 'Creamy and thick' }] },
          { type: 'question', questionType: 'sightWord', questionMode: 'multipleChoice', passage: 'They blend it smooth.', question: 'Which word ends with th?', comprehensionHint: 'Say each word slowly. Listen for th at the end.', answers: [{ name: 'smooth', icon: 'âœ¨' }, { name: 'they', icon: 'ðŸ‘¥' }, { name: 'blend', icon: 'ðŸŒ€' }], correctAnswerName: 'smooth', successMessage: 'Yes! Smooth ends with the th sound.' }
        ]
      },

      // Tea House (Level 4 - th consolidation)
      teahouse: {
        name: 'Tea House',
        icon: 'ðŸµ',
        level: 4,
        floor: 3,
        stickers: ['ðŸµ', 'ðŸ«–', 'ðŸŒ¿', 'â­'],
        digraphFocus: 'th',
        sightWords: ['the', 'they', 'this', 'that', 'there', 'I', 'want', 'will', 'think', 'with'],
        previewWords: [
          { word: 'the', icon: 'ðŸ‘‰', isSightWord: true, hasDigraph: true, digraphPosition: 'start' },
          { word: 'with', icon: 'ðŸ¤', isSightWord: true, hasDigraph: true, digraphPosition: 'end' },
          { word: 'thank', icon: 'ðŸ™', isSightWord: false, hasDigraph: true, digraphPosition: 'start' },
          { word: 'both', icon: 'âœŒï¸', isSightWord: false, hasDigraph: true, digraphPosition: 'end' }
        ],
        pages: [
          { type: 'read', image: 'ðŸš‚ðŸµ', sentence: 'I am at the tea house in the mountains. The air is fresh up here. I can see the city far below. This is a peaceful place. I think I will stay for a while.', words: null, targetWords: ['the', 'this', 'think'], sightWordFocus: 'the', readingTip: 'Traditional tea houses in Taiwan are often in the mountains!' },
          { type: 'question', questionType: 'comprehension', questionMode: 'multipleChoice', passage: 'I am at the tea house in the mountains.', question: 'Where is the tea house?', comprehensionHint: 'Find where the tea house is located.', answers: [{ name: 'In the mountains', icon: 'â›°ï¸' }, { name: 'By the beach', icon: 'ðŸ–ï¸' }, { name: 'In the city', icon: 'ðŸ™ï¸' }], correctAnswerName: 'In the mountains', successMessage: 'Yes! The tea house is in the mountains!' },
          { type: 'read', image: 'ðŸµðŸ˜Š', sentence: 'The tea is warm with a nice smell. I drink it with both hands. I think this tea is the best! I thank the server. They smile at me. I feel thankful for this moment.', words: null, targetWords: ['the', 'with', 'both', 'think', 'this', 'thank', 'they', 'thankful'], sightWordFocus: 'with', readingTip: 'Thank and thankful both start with th.' },
          { type: 'menu', prompt: 'Pick your tea!', menuStory: 'The tea house has many teas. What will you pick?', items: [{ name: 'Green Tea', icon: 'ðŸµ', description: 'Light and fresh' }, { name: 'Oolong Tea', icon: 'ðŸ«–', description: 'Rich and smooth' }, { name: 'Milk Tea', icon: 'ðŸ¥›', description: 'Creamy and warm' }] },
          { type: 'question', questionType: 'sightWord', questionMode: 'multipleChoice', passage: 'I feel thankful for this moment.', question: 'Which word has th at the start?', comprehensionHint: 'Find the feeling word that starts with th.', answers: [{ name: 'thankful', icon: 'ðŸ™' }, { name: 'with', icon: 'ðŸ¤' }, { name: 'both', icon: 'âœŒï¸' }], correctAnswerName: 'thankful', successMessage: 'Yes! Thankful starts with the th sound.' }
        ]
      },
      practice: {
        name: 'Skill Practice',
        icon: 'ðŸ“š',
        level: 1,
        floor: 2,
        isPractice: true,
        stickers: ['ðŸ“š', 'â­', 'ðŸŒŸ', 'ðŸ†'],
        sightWords: [],
        previewWords: [],
        pages: []
      }
    };

    // ===== FOOD-ONLY PIVOT: PILOT STORY STATIONS =====
    // Mark non-pilot food stations as "coming soon" so only the pilot stories are clickable on the map.
    // (Practice station remains available from the Skills screen.)
    (function applyFoodStoryPilotAvailability() {
      try {
        Object.entries(stationContent).forEach(([id, station]) => {
          if (!station || typeof station !== 'object') return;
          if (station.isPractice) return;
          const isPilot = isFoodStoryPilotStation(id);
          station.comingSoon = !isPilot;
          station.isStory = isPilot;
        });
      } catch (e) {
        // Non-fatal
      }
    })();

    // ===== SPEECH SYNTHESIS (ElevenLabs TTS) =====
    let audioContext = null;
    let currentSource = null;
    let currentGainNode = null;
    let currentAudioKind = null; // 'guidance' | 'narration' | null
    let ttsRequestToken = 0;
    let audioResumePromise = null;
    let currentHtmlAudio = null;
    let currentHtmlAudioObjectUrl = null;
    let htmlAudioUnlocked = false;
    let htmlAudioUnlockPromise = null;
    let htmlAudioFadeRafId = null;
    const SILENT_WAV_DATA_URI = 'data:audio/wav;base64,UklGRgQCAABXQVZFZm10IBAAAAABAAEAQB8AAIA+AAACABAAZGF0YeABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=';
    // Cache key (lowercased text) -> { arrayBuffer, mimeType, outputFormat, wordTimings, decodedAudioBuffer }
    const audioCache = new Map();
    let ttsManifest = null;
    let ttsManifestPromise = null;

    async function loadTtsManifest() {
      if (ttsManifest) return ttsManifest;
      if (ttsManifestPromise) return ttsManifestPromise;

      ttsManifestPromise = (async () => {
        try {
          // Cache the manifest but allow revalidation so deployments can update it without hard refreshes.
          const resp = await fetch('assets/tts/manifest.json', { cache: 'no-cache' });
          if (!resp.ok) return null;
          const json = await resp.json();
          if (json && typeof json === 'object' && json.items && typeof json.items === 'object') {
            ttsManifest = json;
          }
        } catch (e) { }
        return ttsManifest;
      })();

      const result = await ttsManifestPromise;
      // If the manifest failed to load, allow a retry later.
      if (!ttsManifest) ttsManifestPromise = null;
      return result;
    }

    async function maybeLoadPrebuiltClip(cacheKey) {
      const manifest = await loadTtsManifest();
      const entry = manifest && manifest.items ? manifest.items[cacheKey] : null;
      if (!entry || !entry.file) return null;

      try {
        const resp = await fetch(entry.file, { cache: 'force-cache' });
        if (!resp.ok) return null;
        const arrayBuffer = await resp.arrayBuffer();
        const clip = {
          arrayBuffer,
          file: entry.file,
          mimeType: entry.mimeType || manifest.mimeType || 'audio/mpeg',
          outputFormat: entry.outputFormat || manifest.outputFormat || 'default',
          wordTimings: entry.wordTimings || null,
          decodedAudioBuffer: null
        };
        audioCache.set(cacheKey, clip);
        return clip;
      } catch (e) {
        return null;
      }
    }

    async function getPrebuiltClipMeta(cacheKey) {
      const manifest = await loadTtsManifest();
      const entry = manifest && manifest.items ? manifest.items[cacheKey] : null;
      if (!entry || !entry.file) return null;

      return {
        arrayBuffer: null,
        file: entry.file,
        mimeType: entry.mimeType || manifest.mimeType || 'audio/mpeg',
        outputFormat: entry.outputFormat || manifest.outputFormat || 'default',
        wordTimings: entry.wordTimings || null,
        decodedAudioBuffer: null
      };
    }

    // Initialize audio context on first user interaction
    function initAudioContext() {
      if (!audioContext) {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
      }
      return audioContext;
    }

    // Some mobile browsers require an <audio> element to be "unlocked" by a gesture as well.
    // We play a tiny silent WAV once (volume=0) so later HTMLAudioElement playback can work.
    function unlockHtmlAudioPlayback() {
      if (htmlAudioUnlocked) return;
      if (htmlAudioUnlockPromise) return;

      try {
        const a = new Audio();
        try { a.playsInline = true; } catch (e) { }
        try { a.setAttribute('playsinline', ''); } catch (e) { }
        a.preload = 'auto';
        a.src = SILENT_WAV_DATA_URI;
        a.volume = 0;

        const p = a.play();
        if (p && typeof p.then === 'function') {
          htmlAudioUnlockPromise = p
            .then(() => {
              try { a.pause(); } catch (e) { }
              try { a.currentTime = 0; } catch (e) { }
              htmlAudioUnlocked = true;
              htmlAudioUnlockPromise = null;
            })
            .catch(() => {
              // Try again on the next user gesture.
              htmlAudioUnlockPromise = null;
            });
          return;
        }

        try { a.pause(); } catch (e) { }
        try { a.currentTime = 0; } catch (e) { }
        htmlAudioUnlocked = true;
        htmlAudioUnlockPromise = null;
      } catch (e) {
        htmlAudioUnlockPromise = null;
      }
    }

    function shouldPreferHtmlAudioPlayback() {
      const ua = navigator.userAgent || '';
      const iOS =
        /iPad|iPhone|iPod/i.test(ua) ||
        (ua.includes('Mac') && typeof document !== 'undefined' && 'ontouchend' in document);
      const android = /Android/i.test(ua);
      const coarsePointer =
        typeof window !== 'undefined' &&
        typeof window.matchMedia === 'function' &&
        window.matchMedia('(pointer: coarse)').matches;
      return iOS || android || coarsePointer;
    }

    let audioUnlockAttempted = false;
    function unlockAudioContext() {
      const ctx = initAudioContext();
      if (!ctx) return null;

      unlockHtmlAudioPlayback();

      // On iOS Safari, AudioContext resume must be initiated from a user gesture.
      // Do not await here; just kick off resume during the gesture.
      if (ctx.state === 'suspended' || ctx.state === 'interrupted') {
        try {
          const p = ctx.resume();
          if (p && typeof p.then === 'function') {
            audioResumePromise = p;
            p.catch(() => {
              if (audioResumePromise === p) audioResumePromise = null;
            });
          }
        } catch (e) { }
      }

      // iOS sometimes requires a "real" source start to fully unlock audio.
      if (!audioUnlockAttempted) {
        try {
          const silentBuffer = ctx.createBuffer(1, 1, ctx.sampleRate || 44100);
          const source = ctx.createBufferSource();
          source.buffer = silentBuffer;
          source.connect(ctx.destination);
          const now = ctx.currentTime;
          source.start(now);
          source.stop(now + 0.01);
          audioUnlockAttempted = true;
        } catch (e) {
          // If this fails, we'll try again on the next user gesture.
          audioUnlockAttempted = false;
        }
      }

      return ctx;
    }

    async function ensureAudioContextReady(timeoutMs = 1200) {
      const ctx = initAudioContext();
      if (ctx.state !== 'suspended' && ctx.state !== 'interrupted') return ctx;

      try {
        // Prefer awaiting a resume() that was initiated from a user gesture.
        const resumePromise =
          audioResumePromise && typeof audioResumePromise.then === 'function'
            ? audioResumePromise
            : ctx.resume();

        if (resumePromise && typeof resumePromise.then === 'function') {
          audioResumePromise = resumePromise;
          resumePromise.catch(() => {
            if (audioResumePromise === resumePromise) audioResumePromise = null;
          });

          await Promise.race([
            resumePromise,
            new Promise(resolve => setTimeout(resolve, timeoutMs))
          ]);
        }
      } catch (e) { }

      return ctx;
    }

    function stopHtmlAudio() {
      if (htmlAudioFadeRafId !== null) {
        cancelAnimationFrame(htmlAudioFadeRafId);
        htmlAudioFadeRafId = null;
      }

      if (currentHtmlAudio) {
        try { currentHtmlAudio.pause(); } catch (e) { }
        try { currentHtmlAudio.currentTime = 0; } catch (e) { }
        try { currentHtmlAudio.src = ''; } catch (e) { }
        try { currentHtmlAudio.volume = 1; } catch (e) { }
        try { currentHtmlAudio.dataset.ttsToken = ''; } catch (e) { }
      }

      if (currentHtmlAudioObjectUrl) {
        try { URL.revokeObjectURL(currentHtmlAudioObjectUrl); } catch (e) { }
        currentHtmlAudioObjectUrl = null;
      }
    }

    // Returns audio metadata for timing synchronization, or null if no audio
    async function speak(text, playbackRate = 1.0, options = {}) {
      if (!state.soundEnabled) return null;
      const requestToken = ++ttsRequestToken;
      const isCancelled = () => requestToken !== ttsRequestToken;
      // If the learner triggers any narration, don't let delayed guidance interrupt it.
      cancelGuidancePlayback();
      // Best-effort unlock for mobile Safari (no-op on desktop).
      unlockAudioContext();

      const kind = options && typeof options.kind === 'string' ? options.kind : 'narration';
      const playOptions =
        options && typeof options === 'object' && options !== null
          ? { ...options, ttsToken: requestToken }
          : { ttsToken: requestToken };

      // Stop any currently playing audio (both Web Audio and SpeechSynthesis)
      if (currentSource) {
        try { currentSource.stop(); } catch (e) { }
        currentSource = null;
      }
      currentGainNode = null;
      stopHtmlAudio();
      // Also cancel browser speech synthesis to prevent voice overlap
      try { window.speechSynthesis.cancel(); } catch (e) { }
      currentAudioKind = null;

      // Check cache first
      const cacheKey = text.toLowerCase().trim();
      const preferHtmlAudio = shouldPreferHtmlAudioPlayback();
      if (audioCache.has(cacheKey)) {
        const cachedClip = audioCache.get(cacheKey);
        const canUseCached = preferHtmlAudio || (cachedClip && cachedClip.arrayBuffer);
        if (canUseCached) {
          if (isCancelled()) return null;
          try {
            currentAudioKind = kind;
            const meta = preferHtmlAudio
              ? await playTtsAudioViaHtmlAudio(cachedClip, playbackRate, playOptions)
              : await playTtsAudio(cachedClip, playbackRate, playOptions);
            if (isCancelled()) return null;
            return meta;
          } catch (e) {
            try {
              currentAudioKind = kind;
              const meta = preferHtmlAudio
                ? await playTtsAudio(cachedClip, playbackRate, playOptions)
                : await playTtsAudioViaHtmlAudio(cachedClip, playbackRate, playOptions);
              if (isCancelled()) return null;
              return meta;
            } catch (e2) {
              console.warn('Audio playback failed (cached). Falling back to SpeechSynthesis.', e2);
              if (isCancelled()) return null;
              currentAudioKind = kind;
              return fallbackSpeak(text, playbackRate);
            }
          }
        }
      }

      try {
        // On mobile, avoid an extra fetch round-trip: play directly from the prebuilt URL if present.
        if (preferHtmlAudio) {
          const metaClip = await getPrebuiltClipMeta(cacheKey);
          if (isCancelled()) return null;
          if (metaClip) {
            audioCache.set(cacheKey, metaClip);
            try {
              currentAudioKind = kind;
              const meta = await playTtsAudioViaHtmlAudio(metaClip, playbackRate, playOptions);
              if (isCancelled()) return null;
              return meta;
            } catch (e) {
              // Fall through to other paths.
            }
          }
        }

        // Try pre-generated audio (assets/tts/manifest.json) before calling the API.
        const prebuilt = await maybeLoadPrebuiltClip(cacheKey);
        if (isCancelled()) return null;
        if (prebuilt) {
          try {
            currentAudioKind = kind;
            const meta = preferHtmlAudio
              ? await playTtsAudioViaHtmlAudio(prebuilt, playbackRate, playOptions)
              : await playTtsAudio(prebuilt, playbackRate, playOptions);
            if (isCancelled()) return null;
            return meta;
          } catch (e) {
            try {
              currentAudioKind = kind;
              const meta = preferHtmlAudio
                ? await playTtsAudio(prebuilt, playbackRate, playOptions)
                : await playTtsAudioViaHtmlAudio(prebuilt, playbackRate, playOptions);
              if (isCancelled()) return null;
              return meta;
            } catch (e2) {
              console.warn('Audio playback failed (prebuilt). Falling back to SpeechSynthesis.', e2);
              if (isCancelled()) return null;
              currentAudioKind = kind;
              return fallbackSpeak(text, playbackRate);
            }
          }
        }

        // Call our TTS API
        const headers = { 'Content-Type': 'application/json' };
        try {
          const user = state.cloud && state.cloud.user;
          if (user && typeof user.getIdToken === 'function') {
            const token = await user.getIdToken();
            if (token) headers['Authorization'] = `Bearer ${token}`;
          }
        } catch (e) { }
        const response = await fetch('/api/tts', {
          method: 'POST',
          headers,
          body: JSON.stringify({
            text: text
          })
        });
        if (isCancelled()) return null;

        if (!response.ok) {
          console.error('TTS API error:', response.status);
          if (isCancelled()) return null;
          return fallbackSpeak(text, playbackRate);
        }

        const data = await response.json();
        if (isCancelled()) return null;

        if (data.audio) {
          const clip = {
            arrayBuffer: base64ToArrayBuffer(data.audio),
            mimeType: data.mimeType || 'audio/mpeg',
            outputFormat: data.outputFormat || 'default',
            wordTimings: data.wordTimings || null,
            decodedAudioBuffer: null
          };
          audioCache.set(cacheKey, clip);
          try {
            currentAudioKind = kind;
            const meta = preferHtmlAudio
              ? await playTtsAudioViaHtmlAudio(clip, playbackRate, playOptions)
              : await playTtsAudio(clip, playbackRate, playOptions);
            if (isCancelled()) return null;
            return meta;
          } catch (e) {
            try {
              currentAudioKind = kind;
              const meta = preferHtmlAudio
                ? await playTtsAudio(clip, playbackRate, playOptions)
                : await playTtsAudioViaHtmlAudio(clip, playbackRate, playOptions);
              if (isCancelled()) return null;
              return meta;
            } catch (e2) {
              console.warn('Audio playback failed. Falling back to SpeechSynthesis.', e2);
              if (isCancelled()) return null;
              currentAudioKind = kind;
              return fallbackSpeak(text, playbackRate);
            }
          }
        } else {
          if (isCancelled()) return null;
          currentAudioKind = kind;
          return fallbackSpeak(text, playbackRate);
        }

      } catch (error) {
        console.error('TTS error:', error);
        if (isCancelled()) return null;
        currentAudioKind = kind;
        return fallbackSpeak(text, playbackRate);
      }
    }

    function stopSpeech(options = {}) {
      ttsRequestToken++;
      const fadeMs = options && Number.isFinite(options.fadeMs) ? options.fadeMs : 0;

      // Stop Web Audio source
      if (currentSource) {
        const ctx = audioContext;
        const canFade =
          fadeMs > 0 &&
          ctx &&
          ctx.state !== 'closed' &&
          currentGainNode &&
          currentGainNode.gain &&
          typeof currentGainNode.gain.setValueAtTime === 'function';

        if (canFade) {
          try {
            const fadeSec = Math.max(0, fadeMs) / 1000;
            const now = ctx.currentTime;
            const current = Number.isFinite(currentGainNode.gain.value) ? currentGainNode.gain.value : 1;
            currentGainNode.gain.cancelScheduledValues(now);
            currentGainNode.gain.setValueAtTime(current, now);
            currentGainNode.gain.linearRampToValueAtTime(0, now + fadeSec);
            currentSource.stop(now + fadeSec + 0.02);
          } catch (e) {
            try { currentSource.stop(); } catch (err2) { }
          }
        } else {
          try { currentSource.stop(); } catch (e) { }
        }

        currentSource = null;
      }
      currentGainNode = null;

      if (fadeMs > 0 && currentHtmlAudio && currentHtmlAudio.src) {
        if (htmlAudioFadeRafId !== null) cancelAnimationFrame(htmlAudioFadeRafId);
        const audioEl = currentHtmlAudio;
        const startVol = Number.isFinite(audioEl.volume) ? audioEl.volume : 1;
        const startAt = performance.now();
        const tick = () => {
          if (audioEl !== currentHtmlAudio) {
            htmlAudioFadeRafId = null;
            return;
          }
          const t = (performance.now() - startAt) / fadeMs;
          if (t >= 1) {
            try { audioEl.volume = 0; } catch (e) { }
            stopHtmlAudio();
            try { audioEl.volume = startVol; } catch (e) { }
            htmlAudioFadeRafId = null;
            return;
          }
          try { audioEl.volume = Math.max(0, startVol * (1 - t)); } catch (e) { }
          htmlAudioFadeRafId = requestAnimationFrame(tick);
        };
        htmlAudioFadeRafId = requestAnimationFrame(tick);
      } else {
        stopHtmlAudio();
      }

      // Also cancel browser speech synthesis
      try { window.speechSynthesis.cancel(); } catch (e) { }
      currentAudioKind = null;
    }

    function setContinueEnabled(enabled) {
      const continueBtn = document.getElementById('continueBtn');
      if (!continueBtn) return;
      continueBtn.disabled = !enabled;
      continueBtn.setAttribute('aria-disabled', (!enabled).toString());
    }

    let sightWordGateAnnounceTimeoutId = null;
    let sightWordGateAnnounceToken = 0;

    function cancelSightWordGateAnnouncement() {
      sightWordGateAnnounceToken++;
      if (sightWordGateAnnounceTimeoutId) {
        clearTimeout(sightWordGateAnnounceTimeoutId);
        sightWordGateAnnounceTimeoutId = null;
      }
    }

	    function clearSightWordNudges() {
      const focusChip = document.getElementById('focusSightWord');
      if (focusChip) focusChip.classList.remove('gate-nudge');
      const display = document.getElementById('sentenceDisplay');
      if (display) {
        display.querySelectorAll('.word.gate-nudge').forEach(el => el.classList.remove('gate-nudge'));
      }
    }

	    function nudgeSightWordGate() {
	      if (!state.requiredSightWord || state.sightWordGateSatisfied) return;

	      state.sightWordGateWasNudged = true;

	      const focusLabel = document.getElementById('sightWordLabel');
	      const focusAction = document.getElementById('sightWordAction');

	      const displayWord = state.requiredSightWordDisplay || state.requiredSightWord;
	      if (focusLabel) focusLabel.textContent = 'Sight word';
	      if (focusAction) focusAction.textContent = 'Tap one to continue';

	      const gateRow = document.getElementById('sightWordGateRow');
	      const gateText = document.getElementById('sightWordGateText');
	      if (gateText && displayWord) {
	        gateText.textContent = `Tap ${displayWord} in the sentence one time. You can also tap it on the card.`;
	        gateText.style.display = 'block';
	        if (gateRow) gateRow.style.display = 'flex';
	      }

	      // After the learner tries Next and gets stuck, offer a skip button after a short delay.
	      if (!state.sightWordSkipTimeoutId) {
	        state.sightWordSkipTimeoutId = setTimeout(() => {
	          if (state.sightWordGateSatisfied) return;
	          const gateRow = document.getElementById('sightWordGateRow');
	          const skipBtn = document.getElementById('sightWordSkipBtn');
	          if (skipBtn) skipBtn.style.display = 'inline-flex';
	          if (gateRow) gateRow.style.display = 'flex';
	        }, 6000);
	      }

	      clearSightWordNudges();

      const focusChip = document.getElementById('focusSightWord');
      if (focusChip) {
        focusChip.classList.remove('gate-nudge');
        // Reflow to restart CSS animation
        // eslint-disable-next-line no-unused-expressions
        focusChip.offsetWidth;
        focusChip.classList.add('gate-nudge');
      }

      const display = document.getElementById('sentenceDisplay');
      if (display) {
        const focusWords = Array.from(display.querySelectorAll('.word.focus-word'));
        focusWords.forEach(el => {
          el.classList.remove('gate-nudge');
          // eslint-disable-next-line no-unused-expressions
          el.offsetWidth;
          el.classList.add('gate-nudge');
        });
      }
    }

    function nudgeForQuestionSupport() {
      const hintElement = document.getElementById('questionHint');
      if (hintElement && hintElement.textContent && hintElement.style.display === 'none') {
        hintElement.style.display = 'inline-block';
      }

      const targets = [
        document.getElementById('passageBox'),
        hintElement
      ].filter(Boolean);

      targets.forEach(el => {
        el.classList.remove('attention-nudge');
        // Reflow to restart CSS animation.
        // eslint-disable-next-line no-unused-expressions
        el.offsetWidth;
        el.classList.add('attention-nudge');
        setTimeout(() => el.classList.remove('attention-nudge'), 1600);
      });
    }

	    function clearSightWordGateUi() {
	      const gateRow = document.getElementById('sightWordGateRow');
	      const gateText = document.getElementById('sightWordGateText');
	      const skipBtn = document.getElementById('sightWordSkipBtn');
	      if (gateRow) gateRow.style.display = 'none';
	      if (gateText) gateText.textContent = '';
	      if (gateText) gateText.style.display = 'none';
	      if (skipBtn) skipBtn.style.display = 'none';
	    }

	    function clearSightWordGate() {
	      cancelSightWordGateAnnouncement();
	      state.sightWordGateWasNudged = false;
	      state.requiredSightWord = null;
	      state.requiredSightWordDisplay = null;
	      state.sightWordGateSatisfied = true;
	      if (state.sightWordSkipTimeoutId) {
	        clearTimeout(state.sightWordSkipTimeoutId);
	        state.sightWordSkipTimeoutId = null;
      }
      clearSightWordNudges();
      clearSightWordGateUi();
      setContinueEnabled(true);
    }

	    function armSightWordGate(focusSightWord) {
	      clearSightWordGate();
	      if (!focusSightWord) return;

	      state.requiredSightWord = focusSightWord.toLowerCase();
	      state.requiredSightWordDisplay = focusSightWord;
	      state.sightWordGateSatisfied = false;

	      // Keep the gate message hidden until the learner tries to press Next.
	      clearSightWordGateUi();

	      // Keep Next clickable; if pressed early we nudge the word instead of blocking the button.
	      setContinueEnabled(true);
	    }

	    function satisfySightWordGate() {
	      if (state.sightWordGateSatisfied) return false;
	      state.sightWordGateSatisfied = true;

	      const gateRow = document.getElementById('sightWordGateRow');
	      const gateText = document.getElementById('sightWordGateText');
	      if (gateText) {
	        gateText.textContent = 'Nice! One is enough. Press Next.';
	        gateText.style.display = 'block';
	        if (gateRow) gateRow.style.display = 'flex';
	      }

	      const sightWordFocus = document.getElementById('sightWordFocus');
	      if (sightWordFocus) sightWordFocus.classList.remove('gated');
	      const focusLabel = document.getElementById('sightWordLabel');
	      const focusAction = document.getElementById('sightWordAction');
	      if (focusLabel) focusLabel.textContent = 'Sight word';
	      if (focusAction) focusAction.textContent = 'Now press Next';

	      const continueBtn = document.getElementById('continueBtn');
	      if (continueBtn) {
	        continueBtn.classList.remove('gate-nudge');
	        // eslint-disable-next-line no-unused-expressions
	        continueBtn.offsetWidth;
	        continueBtn.classList.add('gate-nudge');
	        setTimeout(() => continueBtn.classList.remove('gate-nudge'), 900);
	      }

	      clearSightWordNudges();

	      const skipBtn = document.getElementById('sightWordSkipBtn');
	      if (skipBtn) skipBtn.style.display = 'none';

      if (state.sightWordSkipTimeoutId) {
        clearTimeout(state.sightWordSkipTimeoutId);
        state.sightWordSkipTimeoutId = null;
      }

	      setContinueEnabled(true);
	      return true;
	    }

    function skipSightWordGate() {
      satisfySightWordGate();
    }

    async function maybeAnnounceSightWordGateSatisfied({ afterSpeakPromise, afterSpeakToken } = {}) {
      if (!state.soundEnabled || !state.guidanceEnabled) return;
      if (!state.sightWordGateWasNudged) return;
      if (!state.requiredSightWord || !state.sightWordGateSatisfied) return;

      cancelSightWordGateAnnouncement();
      const tokenGuard = ++sightWordGateAnnounceToken;
      const stationGuard = state.currentStation;
      const pageGuard = state.currentPage;

      let meta = null;
      try {
        meta = afterSpeakPromise ? await afterSpeakPromise : null;
      } catch (e) {
        meta = null;
      }

      if (tokenGuard !== sightWordGateAnnounceToken) return;
      if (state.currentStation !== stationGuard || state.currentPage !== pageGuard) return;
      if (!state.requiredSightWord || !state.sightWordGateSatisfied) return;

      const durationMs = meta && Number.isFinite(meta.duration) ? meta.duration : 650;
      const delayMs = Math.min(2600, Math.max(200, durationMs + 140));

      sightWordGateAnnounceTimeoutId = setTimeout(() => {
        if (tokenGuard !== sightWordGateAnnounceToken) return;
        if (state.currentStation !== stationGuard || state.currentPage !== pageGuard) return;
        if (!state.requiredSightWord || !state.sightWordGateSatisfied) return;
        if (Number.isFinite(afterSpeakToken) && ttsRequestToken !== afterSpeakToken) return;

        const text =
          guidancePrompts &&
          guidancePrompts.lessons &&
          guidancePrompts.lessons.read &&
          guidancePrompts.lessons.read.sightGateSatisfied
            ? guidancePrompts.lessons.read.sightGateSatisfied
            : 'Nice! One is enough. Press Next.';
        speak(text, 1.08, { kind: 'guidance' });
      }, delayMs);
    }

    // Convert base64 to ArrayBuffer
    function base64ToArrayBuffer(base64) {
      const binaryString = atob(base64);
      const bytes = new Uint8Array(binaryString.length);
      for (let i = 0; i < binaryString.length; i++) {
        bytes[i] = binaryString.charCodeAt(i);
      }
      return bytes.buffer;
    }

    function analyzePcmForSilence(float32Array, sampleRate) {
      const windowSize = Math.max(1, Math.floor(sampleRate * 0.01)); // 10ms
      const windowCount = Math.ceil(float32Array.length / windowSize);
      const energies = new Float32Array(windowCount);

      for (let w = 0; w < windowCount; w++) {
        const start = w * windowSize;
        const end = Math.min(float32Array.length, start + windowSize);
        const len = Math.max(1, end - start);
        let sumSquares = 0;
        for (let i = start; i < end; i++) {
          const x = float32Array[i];
          sumSquares += x * x;
        }
        energies[w] = Math.sqrt(sumSquares / len);
      }

      const sorted = Array.from(energies).sort((a, b) => a - b);
      const pickPercentile = p => {
        if (sorted.length === 0) return 0;
        const idx = Math.min(sorted.length - 1, Math.max(0, Math.floor((sorted.length - 1) * p)));
        return sorted[idx] || 0;
      };

      const noiseFloor = pickPercentile(0.1);
      const p90 = pickPercentile(0.9);
      const dynamicRange = Math.max(1e-6, p90 - noiseFloor);

      let silenceThreshold = noiseFloor + dynamicRange * 0.08;
      silenceThreshold = Math.max(silenceThreshold, noiseFloor * 2, 0.0015);
      silenceThreshold = Math.min(silenceThreshold, 0.03);

      const silentWindows = new Array(windowCount);
      for (let w = 0; w < windowCount; w++) {
        silentWindows[w] = energies[w] < silenceThreshold;
      }

      // Smooth out single-window blips so a tiny spike doesn't destroy a pause.
      for (let w = 1; w < windowCount - 1; w++) {
        if (!silentWindows[w] && silentWindows[w - 1] && silentWindows[w + 1]) {
          silentWindows[w] = true;
          continue;
        }
        if (silentWindows[w] && !silentWindows[w - 1] && !silentWindows[w + 1]) {
          silentWindows[w] = false;
        }
      }

      let firstNonSilent = 0;
      while (firstNonSilent < windowCount && silentWindows[firstNonSilent]) {
        firstNonSilent++;
      }
      if (firstNonSilent >= windowCount) firstNonSilent = 0;

      let lastNonSilent = windowCount - 1;
      while (lastNonSilent >= 0 && silentWindows[lastNonSilent]) {
        lastNonSilent--;
      }
      if (lastNonSilent < 0) lastNonSilent = windowCount - 1;

      const leadingSilenceMs = (firstNonSilent * windowSize / sampleRate) * 1000;
      const trailingSilenceStartSample = Math.min(float32Array.length, (lastNonSilent + 1) * windowSize);
      const trailingSilenceMs = ((float32Array.length - trailingSilenceStartSample) / sampleRate) * 1000;

      const silenceMidpointsMs = [];
      const silenceSegmentsMs = [];
      const minRunWindows = 3; // >= 30ms
      let runStart = null;

      for (let w = 0; w <= windowCount; w++) {
        const isSilent = w < windowCount ? silentWindows[w] : false;

        if (isSilent) {
          if (runStart === null) runStart = w;
          continue;
        }

        if (runStart === null) continue;

        const runEnd = w - 1;
        const runLength = runEnd - runStart + 1;
        if (runLength >= minRunWindows) {
          const runStartSample = runStart * windowSize;
          const runEndSample = Math.min(float32Array.length, (runEnd + 1) * windowSize);

          silenceSegmentsMs.push({
            startMs: (runStartSample / sampleRate) * 1000,
            endMs: (runEndSample / sampleRate) * 1000
          });

          const midWindow = (runStart + runEnd + 1) / 2;
          const midSample = midWindow * windowSize;
          silenceMidpointsMs.push((midSample / sampleRate) * 1000);
        }
        runStart = null;
      }

      return { leadingSilenceMs, trailingSilenceMs, silenceMidpointsMs, silenceSegmentsMs };
    }

    function getPcmSampleRateFromOutputFormat(outputFormat, fallback = 24000) {
      const match = String(outputFormat || '').match(/pcm_(\d+)/i);
      const parsed = match ? Number.parseInt(match[1], 10) : Number.NaN;
      return Number.isFinite(parsed) ? parsed : fallback;
    }

    function decodeAudioDataCompat(ctx, arrayBuffer) {
      return new Promise((resolve, reject) => {
        try {
          const maybePromise = ctx.decodeAudioData(arrayBuffer, resolve, reject);
          if (maybePromise && typeof maybePromise.then === 'function') {
            maybePromise.then(resolve).catch(reject);
          }
        } catch (e) {
          reject(e);
        }
      });
    }

    // Fallback playback path using HTMLAudioElement (more reliable on some mobile browsers).
    // Returns timing metadata compatible with the existing word-highlighting system.
    async function playTtsAudioViaHtmlAudio(clip, playbackRate = 1.0, options = {}) {
      if (!clip || (!clip.arrayBuffer && !(clip.file && typeof clip.file === 'string'))) {
        throw new Error('Missing audio clip data');
      }

      const ttsToken = options && Number.isFinite(options.ttsToken) ? options.ttsToken : null;
      const tokenStr = ttsToken === null ? '' : String(ttsToken);
      const isCancelled = () => ttsToken !== null && ttsToken !== ttsRequestToken;
      if (isCancelled()) return null;

      unlockHtmlAudioPlayback();

      if (!currentHtmlAudio) {
        currentHtmlAudio = new Audio();
        try { currentHtmlAudio.playsInline = true; } catch (e) { }
        try { currentHtmlAudio.setAttribute('playsinline', ''); } catch (e) { }
        currentHtmlAudio.preload = 'auto';
      }

      stopHtmlAudio();

      const mimeType = String(clip.mimeType || '').trim() || 'audio/mpeg';
      let src = '';

      if (clip.file && typeof clip.file === 'string') {
        src = clip.file;
      } else {
        const blob = new Blob([clip.arrayBuffer], { type: mimeType });
        currentHtmlAudioObjectUrl = URL.createObjectURL(blob);
        src = currentHtmlAudioObjectUrl;
      }

      currentHtmlAudio.src = src;
      currentHtmlAudio.playbackRate = playbackRate;
      currentHtmlAudio.volume = 1;
      try { currentHtmlAudio.dataset.ttsToken = tokenStr; } catch (e) { }
      try { currentHtmlAudio.currentTime = 0; } catch (e) { }

      const audioEl = currentHtmlAudio;
      const playPromise = audioEl.play();
      if (playPromise && typeof playPromise.then === 'function') {
        await playPromise;
      }
      if (isCancelled()) {
        const stillOwner = ttsToken !== null && audioEl && audioEl.dataset && audioEl.dataset.ttsToken === tokenStr;
        if (stillOwner) stopHtmlAudio();
        return null;
      }

      // Scale word timings to match playbackRate (timestamps are for rate=1.0).
      let wordTimings = null;
      if (clip.wordTimings && Array.isArray(clip.wordTimings.startMs) && Array.isArray(clip.wordTimings.endMs)) {
        const scale = 1 / playbackRate;
        wordTimings = {
          words: Array.isArray(clip.wordTimings.words) ? clip.wordTimings.words.slice() : [],
          startMs: clip.wordTimings.startMs.map(ms => (Number.isFinite(ms) ? ms * scale : ms)),
          endMs: clip.wordTimings.endMs.map(ms => (Number.isFinite(ms) ? ms * scale : ms))
        };
      }

      let durationMs = null;
      if (wordTimings && Array.isArray(wordTimings.endMs) && wordTimings.endMs.length) {
        const last = wordTimings.endMs[wordTimings.endMs.length - 1];
        if (Number.isFinite(last)) durationMs = Math.max(0, last);
      }
      if (!Number.isFinite(durationMs)) {
        const durSec = audioEl.duration;
        if (Number.isFinite(durSec) && durSec > 0) durationMs = durSec * 1000;
      }
      if (!Number.isFinite(durationMs)) durationMs = 2500;

      return {
        duration: durationMs,
        source: null,
        audioEl,
        ctx: null,
        startTime: null,
        outputStartPerfMs: null,
        outputLatencySec: 0,
        leadingSilenceMs: 0,
        trailingSilenceMs: 0,
        silenceMidpointsMs: [],
        silenceSegmentsMs: [],
        wordTimings,
        timingOffsetMs: 0
      };
    }

    // Play TTS audio using Web Audio API (supports mp3/wav decode + optional PCM-L16).
    // Returns timing metadata for word highlighting.
    async function playTtsAudio(clip, playbackRate = 1.0, options = {}) {
      const ttsToken = options && Number.isFinite(options.ttsToken) ? options.ttsToken : null;
      const isCancelled = () => ttsToken !== null && ttsToken !== ttsRequestToken;
      const ctx = await ensureAudioContextReady();
      if (isCancelled()) return null;
      if (!ctx || ctx.state === 'closed') {
        throw new Error('AudioContext not available');
      }
      if (ctx.state === 'suspended' || ctx.state === 'interrupted') {
        throw new Error(`AudioContext not running (${ctx.state})`);
      }

      if (!clip || !clip.arrayBuffer) {
        throw new Error('Missing audio clip data');
      }

      const mimeType = String(clip.mimeType || '').toLowerCase();
      const outputFormat = String(clip.outputFormat || 'default');

      let audioBuffer = clip.decodedAudioBuffer || null;
      if (!audioBuffer) {
        const isPcm =
          mimeType.startsWith('audio/l16') ||
          outputFormat.toLowerCase().startsWith('pcm');

        if (isPcm) {
          const sampleRate = getPcmSampleRateFromOutputFormat(outputFormat, 24000);
          const int16Array = new Int16Array(clip.arrayBuffer);

          const float32Array = new Float32Array(int16Array.length);
          for (let i = 0; i < int16Array.length; i++) {
            float32Array[i] = int16Array[i] / 32768.0;
          }

          audioBuffer = ctx.createBuffer(1, float32Array.length, sampleRate);
          audioBuffer.getChannelData(0).set(float32Array);
        } else {
          // Decode encoded audio (default ElevenLabs output is MP3).
          const decodeBuffer = clip.arrayBuffer.slice(0);
          audioBuffer = await decodeAudioDataCompat(ctx, decodeBuffer);
          if (isCancelled()) return null;
        }

        clip.decodedAudioBuffer = audioBuffer;
      }

      let analysis = null;
      if (options && options.analyze) {
        const channel = audioBuffer.getChannelData(0);
        analysis = analyzePcmForSilence(channel, audioBuffer.sampleRate);
        const scale = 1 / playbackRate;
        analysis.leadingSilenceMs *= scale;
        analysis.trailingSilenceMs *= scale;
        analysis.silenceMidpointsMs = analysis.silenceMidpointsMs.map(ms => ms * scale);
        analysis.silenceSegmentsMs = analysis.silenceSegmentsMs.map(segment => ({
          startMs: segment.startMs * scale,
          endMs: segment.endMs * scale
        }));
      }

      if (isCancelled()) return null;
      // Schedule slightly ahead for consistent sync.
      const source = ctx.createBufferSource();
      source.buffer = audioBuffer;
      source.playbackRate.value = playbackRate;
      const gainNode = ctx.createGain();
      gainNode.gain.value = 1;
      source.connect(gainNode);
      gainNode.connect(ctx.destination);
      const startTime = ctx.currentTime + 0.05;
      source.start(startTime);
      currentSource = source;
      currentGainNode = gainNode;

      let outputStartPerfMs = null;
      if (typeof ctx.getOutputTimestamp === 'function') {
        try {
          const ts = ctx.getOutputTimestamp();
          if (ts && typeof ts.contextTime === 'number' && typeof ts.performanceTime === 'number') {
            outputStartPerfMs = ts.performanceTime + (startTime - ts.contextTime) * 1000;
          }
        } catch (e) { }
      }

      // Fallback is a conservative guess for devices/browsers that don't expose latency.
      let outputLatencySec = 0.05;
      if (typeof ctx.outputLatency === 'number' && Number.isFinite(ctx.outputLatency)) {
        outputLatencySec = ctx.outputLatency;
      } else if (typeof ctx.baseLatency === 'number' && Number.isFinite(ctx.baseLatency)) {
        outputLatencySec = ctx.baseLatency;
      }

      // Scale word timings to match playbackRate (timestamps are for rate=1.0).
      let wordTimings = null;
      if (clip.wordTimings && Array.isArray(clip.wordTimings.startMs) && Array.isArray(clip.wordTimings.endMs)) {
        const scale = 1 / playbackRate;
        wordTimings = {
          words: Array.isArray(clip.wordTimings.words) ? clip.wordTimings.words.slice() : [],
          startMs: clip.wordTimings.startMs.map(ms => (Number.isFinite(ms) ? ms * scale : ms)),
          endMs: clip.wordTimings.endMs.map(ms => (Number.isFinite(ms) ? ms * scale : ms))
        };
      }

      // If the encoded audio contains padding/leading silence, shift timestamps so word 0
      // starts when speech actually starts (helps MP3 encoder delay on some devices).
      let timingOffsetMs = 0;
      if (analysis && wordTimings && wordTimings.startMs && wordTimings.startMs.length > 0) {
        const firstStart = wordTimings.startMs[0];
        if (Number.isFinite(firstStart) && Number.isFinite(analysis.leadingSilenceMs)) {
          const delta = analysis.leadingSilenceMs - firstStart;
          if (Number.isFinite(delta) && Math.abs(delta) <= 500) {
            timingOffsetMs = delta;
          }
        }
      }

      const duration = (audioBuffer.duration / playbackRate) * 1000; // in ms
      return {
        duration,
        source,
        ctx,
        startTime,
        outputStartPerfMs,
        outputLatencySec,
        leadingSilenceMs: analysis ? analysis.leadingSilenceMs : 0,
        trailingSilenceMs: analysis ? analysis.trailingSilenceMs : 0,
        silenceMidpointsMs: analysis ? analysis.silenceMidpointsMs : [],
        silenceSegmentsMs: analysis ? analysis.silenceSegmentsMs : [],
        wordTimings,
        timingOffsetMs
      };
    }

    // Fallback to browser speech synthesis
    // Returns { duration } estimate in ms
    function fallbackSpeak(text, rate = 1.0) {
      if (!state.soundEnabled) return null;

      window.speechSynthesis.cancel();

      const utterance = new SpeechSynthesisUtterance(text);
      utterance.rate = rate;
      utterance.pitch = 1.1;
      utterance.volume = 1;

      const voices = window.speechSynthesis.getVoices();
      const preferredVoice = voices.find(v =>
        v.name.includes('Samantha') ||
        v.name.includes('Google US English') ||
        v.name.includes('Microsoft Zira')
      );
      if (preferredVoice) {
        utterance.voice = preferredVoice;
      }

      window.speechSynthesis.speak(utterance);

      // Estimate duration: ~150ms per character at normal speed, adjusted for rate
      const estimatedDuration = (text.length * 150) / rate;
      return { duration: estimatedDuration };
    }

    // ===== AUDIO PRE-LOADING =====
    // Pre-fetch likely-needed audio with throttling (avoids mobile stutter + network contention).
    let stationPreloadToken = 0;
    const ttsPreloadTasks = new Map(); // cacheKey -> { cacheKey, priority, storeInMemory, token }
    let ttsPreloadInFlight = 0;
    let ttsPreloadPumpScheduled = false;
    const warmedAudioUrls = new Set();

    function getTtsPreloadConcurrency() {
      const conn = navigator.connection || navigator.mozConnection || navigator.webkitConnection || null;
      const effectiveType = conn && typeof conn.effectiveType === 'string' ? conn.effectiveType : '';
      const slow = effectiveType === 'slow-2g' || effectiveType === '2g';
      if (slow) return 1;
      return shouldPreferHtmlAudioPlayback() ? 2 : 4;
    }

    function scheduleTtsPreloadPump() {
      if (ttsPreloadPumpScheduled) return;
      ttsPreloadPumpScheduled = true;

      const run = () => {
        ttsPreloadPumpScheduled = false;
        pumpTtsPreloadQueue();
      };

      if (typeof requestIdleCallback === 'function') {
        requestIdleCallback(run, { timeout: 900 });
      } else {
        setTimeout(run, 0);
      }
    }

    function enqueueTtsPreload(cacheKey, { priority = 0, token = null, storeInMemory = false } = {}) {
      const key = String(cacheKey || '').toLowerCase().trim();
      if (!key) return;

      const existing = ttsPreloadTasks.get(key);
      if (existing) {
        existing.priority = Math.max(existing.priority, priority);
        existing.storeInMemory = existing.storeInMemory || !!storeInMemory;
        if (token !== null && token !== undefined) existing.token = token;
      } else {
        ttsPreloadTasks.set(key, {
          cacheKey: key,
          priority: priority,
          storeInMemory: !!storeInMemory,
          token: token
        });
      }

      scheduleTtsPreloadPump();
    }

    async function runTtsPreloadTask(task) {
      if (!task) return;
      if (task.token !== null && task.token !== undefined && task.token !== stationPreloadToken) return;

      const shouldStoreInMemory = !!task.storeInMemory && task.cacheKey.includes(' ');

      if (shouldStoreInMemory) {
        const cached = audioCache.get(task.cacheKey);
        if (cached && cached.arrayBuffer) return;
      }

      const manifest = await loadTtsManifest();
      const entry = manifest && manifest.items ? manifest.items[task.cacheKey] : null;
      if (!entry || !entry.file) return;

      if (shouldStoreInMemory) {
        await maybeLoadPrebuiltClip(task.cacheKey);
        return;
      }

      const url = entry.file;
      if (warmedAudioUrls.has(url)) return;
      warmedAudioUrls.add(url);
      try {
        const resp = await fetch(url, { cache: 'force-cache' });
        if (!resp.ok) return;
        // Consume the body so it can be stored in the HTTP cache.
        await resp.arrayBuffer();
      } catch (e) { }
    }

    function pumpTtsPreloadQueue() {
      const max = getTtsPreloadConcurrency();
      while (ttsPreloadInFlight < max && ttsPreloadTasks.size > 0) {
        let bestKey = null;
        let bestTask = null;
        for (const [key, task] of ttsPreloadTasks.entries()) {
          if (!bestTask || task.priority > bestTask.priority) {
            bestTask = task;
            bestKey = key;
          }
        }
        if (!bestTask) return;
        ttsPreloadTasks.delete(bestKey);
        ttsPreloadInFlight++;
        runTtsPreloadTask(bestTask)
          .catch(() => { })
          .finally(() => {
            ttsPreloadInFlight--;
            scheduleTtsPreloadPump();
          });
      }
    }

    function enqueueTextsForPreload(texts, { priority = 0, token = null, storeInMemory = false } = {}) {
      if (!Array.isArray(texts)) return;
      texts.forEach(text => {
        const normalized = typeof text === 'string' ? text.trim() : '';
        if (!normalized) return;
        enqueueTtsPreload(normalized.toLowerCase().trim(), { priority, token, storeInMemory });
      });
    }

    function collectPageTextsForPreload(page) {
      const out = [];
      const add = t => {
        if (!t || typeof t !== 'string') return;
        const s = t.trim();
        if (s) out.push(s);
      };

      if (!page || typeof page !== 'object') return out;

      if (page.sentence) add(page.sentence);
      if (page.passage) add(page.passage);
      if (page.question) add(page.question);
      if (page.prompt) add(page.prompt);
      if (page.menuStory) add(page.menuStory);
      if (page.comprehensionHint) add(page.comprehensionHint);
      if (page.successMessage) add(page.successMessage);

      if (page.sightWordFocus) add(page.sightWordFocus);
      if (Array.isArray(page.targetWords)) page.targetWords.forEach(w => add(w));

      const wordList = Array.isArray(page.words) ? page.words : splitSentenceIntoWords(page.sentence || '');
      if (Array.isArray(wordList) && wordList.length) {
        wordList.forEach(word => {
          const cleanWord = String(word).replace(/[.,!?;:]$/g, '').trim();
          add(cleanWord);
        });
      }

      if (Array.isArray(page.items)) page.items.forEach(item => add(item && item.name));
      if (Array.isArray(page.answers)) page.answers.forEach(a => add(a && a.name));

      return out;
    }

    function preloadUpcomingLessonAudio({ pages = null, currentIndex = null } = {}) {
      const lessonPages = Array.isArray(pages) ? pages : getCurrentStationPages();
      if (!Array.isArray(lessonPages) || lessonPages.length === 0) return;

      const idx = Number.isFinite(currentIndex) ? currentIndex : state.currentPage;
      const token = stationPreloadToken;
      const storeInMemory = !shouldPreferHtmlAudioPlayback();

      const currentPage = lessonPages[idx];
      const nextPage = lessonPages[idx + 1];
      if (currentPage) {
        enqueueTextsForPreload(collectPageTextsForPreload(currentPage), { priority: 95, token, storeInMemory });
      }
      if (nextPage) {
        enqueueTextsForPreload(collectPageTextsForPreload(nextPage), { priority: 70, token, storeInMemory });
      }
    }

    // Pre-fetch likely-needed station audio during the train ride.
    async function preloadStationAudio(stationId, pagesOverride = null) {
      const station = stationContent[stationId];
      if (!station) return;

      stationPreloadToken++;
      const token = stationPreloadToken;
      const storeInMemory = !shouldPreferHtmlAudioPlayback();

      const addText = (text, priority) => {
        if (!text || typeof text !== 'string') return;
        const normalized = text.trim();
        if (!normalized) return;
        enqueueTtsPreload(normalized.toLowerCase().trim(), { priority, token, storeInMemory });
      };

      // Preview words are used immediately on Warmup.
      if (Array.isArray(station.previewWords)) {
        station.previewWords.forEach(item => addText(item && item.word, 90));
      }

      // Small, likely-used labels (helps dynamic guidance like "Next stop: Smoothie Stand.").
      if (station && station.name) addText(String(station.name), 95);

      // Prioritize the first few pages (what the student will see soon).
      const pages = Array.isArray(pagesOverride) ? pagesOverride : station.pages;
      if (Array.isArray(pages)) {
        pages.slice(0, 4).forEach((page, index) => {
          const basePriority = index === 0 ? 85 : index === 1 ? 65 : 45;
          collectPageTextsForPreload(page).forEach(t => addText(t, basePriority));
        });
      }

      // Also kick a small preload for the soonest page transitions.
      preloadUpcomingLessonAudio({ pages, currentIndex: 0 });
    }

    // ===== BUDDY CHARACTER MANAGEMENT =====
    // Controls when the cute bubble tea buddy appears instead of header

    // Screens where the header should show (buddy hidden)
    const headerScreens = ['welcomeScreen', 'skillsScreen'];

    // Screens where the buddy should show (header hidden)
    const buddyScreens = ['mrtScreen', 'mrtRideScreen', 'elevatorScreen', 'warmupScreen', 'restaurantScreen'];

    function updateBuddyVisibility(screenId) {
      const header = document.querySelector('.header');
      const buddyContainer = document.getElementById('buddyContainer');
      const buddyMenu = document.getElementById('buddyMenu');
      const buddyMenuOverlay = document.getElementById('buddyMenuOverlay');

      if (!header || !buddyContainer) return;

      // Determine which mode to show
      const showBuddy = buddyScreens.includes(screenId);
      const showHeader = headerScreens.includes(screenId);

      if (showBuddy) {
        // Show buddy, hide header
        header.classList.add('buddy-mode');
        buddyContainer.classList.add('visible');
      } else {
        // Show header, hide buddy
        header.classList.remove('buddy-mode');
        buddyContainer.classList.remove('visible');
        // Also close the menu if open
        closeBuddyMenu();
      }
    }

    function openBuddyMenu() {
      const buddyMenu = document.getElementById('buddyMenu');
      const buddyMenuOverlay = document.getElementById('buddyMenuOverlay');
      const buddyCharacter = document.getElementById('buddyCharacter');

      if (buddyMenu && buddyMenuOverlay) {
        buddyMenu.classList.add('open');
        buddyMenuOverlay.classList.add('open');
      }

      // Pulse animation on buddy
      if (buddyCharacter) {
        buddyCharacter.classList.add('tapped');
        setTimeout(() => buddyCharacter.classList.remove('tapped'), 500);
      }

      // Update audio button state
      updateBuddyAudioButton();
    }

    function closeBuddyMenu() {
      const buddyMenu = document.getElementById('buddyMenu');
      const buddyMenuOverlay = document.getElementById('buddyMenuOverlay');

      if (buddyMenu && buddyMenuOverlay) {
        buddyMenu.classList.remove('open');
        buddyMenuOverlay.classList.remove('open');
      }
    }

    function toggleBuddyMenu() {
      const buddyMenu = document.getElementById('buddyMenu');
      if (buddyMenu && buddyMenu.classList.contains('open')) {
        closeBuddyMenu();
      } else {
        openBuddyMenu();
      }
    }

    function updateBuddyAudioButton() {
      const audioBtn = document.getElementById('buddyMenuAudio');
      if (!audioBtn) return;

      const isOn = !state.isMuted;
      audioBtn.classList.toggle('audio-on', isOn);

      const iconSpan = audioBtn.querySelector('.menu-icon');
      if (iconSpan) {
        iconSpan.textContent = isOn ? 'ðŸ”Š' : 'ðŸ”‡';
      }
    }

    // Initialize welcome screen train animation with synchronized doors
    function initWelcomeTrainAnimation() {
      const platformDoors = document.getElementById('platformDoors');
      const welcomeTrain = document.getElementById('welcomeTrain');
      const welcomeScreen = document.getElementById('welcomeScreen');

      if (!platformDoors || !welcomeTrain || !welcomeScreen) return;

      // Animation timing (based on 16s total animation)
      // 0-18%: Train arriving (0-2.88s)
      // 18-70%: Train stopped (2.88s-11.2s)
      // 70-100%: Train departing (11.2s-16s)
      const ANIMATION_DURATION = 16000; // 16 seconds
      const TRAIN_ARRIVES = 2900;       // 18% - train stops
      const DOORS_OPEN_DELAY = 400;     // Brief pause after train stops
      const DOORS_STAY_OPEN = 5500;     // Doors open for 5.5 seconds
      const DOORS_CLOSE = TRAIN_ARRIVES + DOORS_OPEN_DELAY + DOORS_STAY_OPEN; // ~8.8s
      const TRAIN_DEPARTS = 11200;      // 70% - train starts moving

      let animationTimer = null;
      let doorSequenceRunning = false;

	      function runDoorSequence() {
	        if (doorSequenceRunning) return;
	        doorSequenceRunning = true;

	        // Ensure doors start closed
	        platformDoors.classList.remove('doors-open');

	        // Schedule door opening (after train arrives and pauses)
	        const openDoorsTimer = setTimeout(() => {
	          if (!welcomeScreen.classList.contains('active')) return;
	          platformDoors.classList.add('doors-open');
	        }, TRAIN_ARRIVES + DOORS_OPEN_DELAY);

	        // Schedule door closing (before train departs)
	        const closeDoorsTimer = setTimeout(() => {
	          if (!welcomeScreen.classList.contains('active')) return;
	          platformDoors.classList.remove('doors-open');
	        }, DOORS_CLOSE);

        // Schedule next cycle
        animationTimer = setTimeout(() => {
          doorSequenceRunning = false;
          if (welcomeScreen.classList.contains('active')) {
            runDoorSequence();
          }
        }, ANIMATION_DURATION);
      }

	      function startAnimation() {
	        // Reset train animation
	        welcomeTrain.style.animation = 'none';
	        welcomeTrain.offsetHeight; // Trigger reflow
	        welcomeTrain.style.animation = '';

	        // Reset door states
	        platformDoors.classList.remove('doors-open');
	        doorSequenceRunning = false;

	        // Start door sequence
	        runDoorSequence();
	      }

      function stopAnimation() {
        if (animationTimer) {
          clearTimeout(animationTimer);
          animationTimer = null;
        }
        doorSequenceRunning = false;
      }

      // Start animation on page load if welcome screen is active
      if (welcomeScreen.classList.contains('active')) {
        startAnimation();
      }

      // Watch for screen changes
      const observer = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
          if (mutation.attributeName === 'class') {
            if (welcomeScreen.classList.contains('active')) {
              startAnimation();
            } else {
              stopAnimation();
            }
          }
        });
      });

      observer.observe(welcomeScreen, { attributes: true });
    }

    // Initialize buddy event listeners
    function initBuddyCharacter() {
      const buddyCharacter = document.getElementById('buddyCharacter');
      const buddyMenuOverlay = document.getElementById('buddyMenuOverlay');
      const buddyMenuHome = document.getElementById('buddyMenuHome');
      const buddyMenuSkills = document.getElementById('buddyMenuSkills');
      const buddyMenuAudio = document.getElementById('buddyMenuAudio');
      const buddyMenuSettings = document.getElementById('buddyMenuSettings');

      // Toggle menu on buddy click
      if (buddyCharacter) {
        buddyCharacter.addEventListener('click', toggleBuddyMenu);
        buddyCharacter.addEventListener('keydown', (e) => {
          if (e.key === 'Enter' || e.key === ' ') {
            e.preventDefault();
            toggleBuddyMenu();
          }
        });
      }

      // Close menu on overlay click
      if (buddyMenuOverlay) {
        buddyMenuOverlay.addEventListener('click', closeBuddyMenu);
      }

      // Menu item: Home (back to map)
      if (buddyMenuHome) {
        buddyMenuHome.addEventListener('click', () => {
          closeBuddyMenu();
          // Use the same "leave story" flow as the main Home button so
          // station click lockout + pending timers are cleared.
          goHome();
        });
      }

      // Menu item: Skills
      if (buddyMenuSkills) {
        buddyMenuSkills.addEventListener('click', () => {
          closeBuddyMenu();
          goToScreen('skillsScreen');
        });
      }

      // Menu item: Audio toggle
      if (buddyMenuAudio) {
        buddyMenuAudio.addEventListener('click', () => {
          // Toggle mute state (same as header audio button)
          state.isMuted = !state.isMuted;
          localStorage.setItem('isMuted', String(state.isMuted));
          updateSoundButton();
          updateBuddyAudioButton();

          if (state.isMuted) {
            stopAllAudio();
          }
        });
      }

      // Menu item: Settings
      if (buddyMenuSettings) {
        buddyMenuSettings.addEventListener('click', () => {
          closeBuddyMenu();
          const settingsModal = document.getElementById('settingsModal');
          if (settingsModal) settingsModal.classList.add('active');
        });
      }
    }

    // ===== SCREEN NAVIGATION =====
    function updateHomeButtonState() {
      const homeBtn = document.getElementById('homeBtn');
      if (!homeBtn) return;
      const isHomeScreen = state.currentScreen === 'welcomeScreen' || state.currentScreen === 'mrtScreen' || state.currentScreen === 'skillsScreen';
      homeBtn.disabled = isHomeScreen;
      homeBtn.style.opacity = isHomeScreen ? '0.6' : '1';
    }

	    function goToScreen(screenId) {
	      // Navigation should always stop any in-progress narration from the previous screen.
	      cancelGuidancePlayback();
	      stopSpeech({ fadeMs: 140 });
	      try { cancelSentenceHighlight(); } catch (e) { }
	      try { cancelPassageHighlight(); } catch (e) { }
	      // Hide all screens
	      document.querySelectorAll('.screen').forEach(screen => {
	        screen.classList.remove('active');
	      });

      // Show target screen
      const targetScreen = document.getElementById(screenId);
      if (targetScreen) {
        targetScreen.classList.add('active');
        state.currentScreen = screenId;
        updateHomeButtonState();
        updateBuddyVisibility(screenId);
        playScreenGuidance(screenId);
      }
    }

    // ===== MRT STATION SELECTION =====

    // Station theme configurations
    const stationThemes = {
      // Red Line (Level 1)
      fruit: {
        themeClass: 'theme-fruit',
        floaters: ['ðŸŽ', 'ðŸŠ', 'ðŸŒ', 'ðŸ‡', 'ðŸ“'],
        sceneImage: 'assets/train_scenes/taipei_101_day.jpeg'
      },
      drink: {
        themeClass: 'theme-drink',
        floaters: ['ðŸ¥¤', 'ðŸ§ƒ', 'ðŸ¥›', 'ðŸ’§', 'ðŸ«§'],
        sceneImage: 'assets/train_scenes/taipei_riverside.png'
      },
      bakery: {
        themeClass: 'theme-bakery',
        floaters: ['ðŸ§', 'ðŸ°', 'ðŸ¥§', 'ðŸª', 'ðŸ¥'],
        sceneImage: 'assets/train_scenes/taipei_temple.jpeg'
      },
      redbean: {
        themeClass: 'theme-redbean',
        floaters: ['ðŸž', 'ðŸ«˜', 'ðŸ¥–', 'ðŸ¥', 'âœ¨'],
        sceneImage: 'assets/train_scenes/taipei_redbean_bakery.jpeg'
      },
      // Blue Line (Level 2)
      pizza: {
        themeClass: 'theme-pizza',
        floaters: ['ðŸ•', 'ðŸ§€', 'ðŸ…', 'ðŸŒ¿', 'ðŸ«“'],
        sceneImage: 'assets/train_scenes/taipei_night_market.png'
      },
      bubbletea: {
        themeClass: 'theme-bubbletea',
        floaters: ['ðŸ§‹', 'ðŸ«§', 'ðŸ¥¤', 'âœ¨', 'ðŸ’œ'],
        sceneImage: 'assets/train_scenes/taipei_bubble_tea.jpeg'
      },
      burger: {
        themeClass: 'theme-burger',
        floaters: ['ðŸ”', 'ðŸŸ', 'ðŸ¥¤', 'ðŸ§…', 'ðŸ¥¬'],
        sceneImage: 'assets/train_scenes/taipei_burger.jpeg'
      },
      icecream: {
        themeClass: 'theme-icecream',
        floaters: ['ðŸ¦', 'ðŸ¨', 'ðŸ§', 'ðŸŒˆ', 'âœ¨'],
        sceneImage: 'assets/train_scenes/taipei_mountain.jpeg'
      },
      // Green Line (Level 3)
      fishshop: {
        themeClass: 'theme-fishshop',
        floaters: ['ðŸŸ', 'ðŸ¦', 'ðŸ ', 'ðŸ¦€', 'ðŸŒŠ'],
        sceneImage: 'assets/train_scenes/taipei_mrt_elevated.png'
      },
      sushi: {
        themeClass: 'theme-sushi',
        floaters: ['ðŸ£', 'ðŸ±', 'ðŸ¥¢', 'ðŸ¥', 'ðŸŒ¸'],
        sceneImage: 'assets/train_scenes/taipei_sushi.jpeg'
      },
      cheese: {
        themeClass: 'theme-cheese',
        floaters: ['ðŸ§€', 'ðŸ¥ª', 'ðŸ”', 'ðŸ§ˆ', 'âœ¨'],
        sceneImage: 'assets/train_scenes/taipei_harbor.png'
      },
      chicken: {
        themeClass: 'theme-chicken',
        floaters: ['ðŸ—', 'ðŸ”', 'ðŸ³', 'ðŸŒ¶ï¸', 'âœ¨'],
        sceneImage: 'assets/train_scenes/taipei_chicken.png'
      },
      // Orange Line (Level 4)
      noodle: {
        themeClass: 'theme-noodle',
        floaters: ['ðŸœ', 'ðŸ²', 'ðŸ¥¢', 'ðŸŒ¶ï¸', 'ðŸ’¨'],
        sceneImage: 'assets/train_scenes/taipei_park.png'
      },
      smoothie: {
        themeClass: 'theme-smoothie',
        floaters: ['ðŸ¥¤', 'ðŸ“', 'ðŸ¥­', 'ðŸŒ', 'ðŸŒ´'],
        sceneImage: 'assets/train_scenes/taipei_smoothie.jpeg'
      },
      teahouse: {
        themeClass: 'theme-teahouse',
        floaters: ['ðŸµ', 'ðŸ«–', 'ðŸŒ¿', 'ðŸƒ', 'âœ¨'],
        sceneImage: 'assets/train_scenes/taipei_teahouse.png'
      }
    };

    // Animate the map train to a target station (path-based, smooth, on-track)
    const MRT_MAP_HUB_POS = { x: 250, y: 320 };
    const MRT_MAP_TRAIN_OFFSET_PX = 0; // 0 = center on the line (no "to the side" drift)
    let mapTrainMotionToken = 0;
    let mapTrainMotionRafId = null;
    const mapTrainLengthCache = new Map(); // key -> length

    function cancelMapTrainMotion() {
      mapTrainMotionToken++;
      if (mapTrainMotionRafId !== null) {
        cancelAnimationFrame(mapTrainMotionRafId);
        mapTrainMotionRafId = null;
      }
    }

    function clampNumber(value, min, max) {
      if (!Number.isFinite(value)) return min;
      return Math.min(max, Math.max(min, value));
    }

    function easeInOutCubic(t) {
      const x = clampNumber(t, 0, 1);
      return x < 0.5 ? 4 * x * x * x : 1 - Math.pow(-2 * x + 2, 3) / 2;
    }

    function getMrtLinePathId(line) {
      if (line === 'red') return 'mrtLinePathRed';
      if (line === 'blue') return 'mrtLinePathBlue';
      if (line === 'green') return 'mrtLinePathGreen';
      if (line === 'orange') return 'mrtLinePathOrange';
      return null;
    }

    function findMrtLinePathElement(line, root = document) {
      const id = getMrtLinePathId(line);
      if (!id) return null;
      if (root && root.nodeType === 9) return root.getElementById(id); // document
      if (root && typeof root.querySelector === 'function') return root.querySelector(`#${id}`);
      return null;
    }

    function getClosestLengthOnPath(pathEl, x, y) {
      if (!pathEl || typeof pathEl.getTotalLength !== 'function' || typeof pathEl.getPointAtLength !== 'function') return null;
      const d = pathEl.getAttribute('d') || '';
      const cacheKey = `${pathEl.id || 'path'}:${d}:${x},${y}`;
      if (mapTrainLengthCache.has(cacheKey)) return mapTrainLengthCache.get(cacheKey);

      let total = null;
      try {
        total = pathEl.getTotalLength();
      } catch (e) {
        return null;
      }
      const targetX = Number(x);
      const targetY = Number(y);
      if (!Number.isFinite(total) || !Number.isFinite(targetX) || !Number.isFinite(targetY)) return null;

      // Coarse scan.
      let bestLen = 0;
      let bestDist2 = Infinity;
      const step = Math.max(3, total / 220); // ~200 samples
      for (let l = 0; l <= total; l += step) {
        let p = null;
        try {
          p = pathEl.getPointAtLength(l);
        } catch (e) {
          return null;
        }
        const dx = p.x - targetX;
        const dy = p.y - targetY;
        const dist2 = dx * dx + dy * dy;
        if (dist2 < bestDist2) {
          bestDist2 = dist2;
          bestLen = l;
        }
      }

      // Refine around the best length (progressively smaller window).
      let window = step * 1.5;
      for (let i = 0; i < 6; i++) {
        const start = clampNumber(bestLen - window, 0, total);
        const end = clampNumber(bestLen + window, 0, total);
        const fineStep = Math.max(0.5, window / 12);
        for (let l = start; l <= end; l += fineStep) {
          let p = null;
          try {
            p = pathEl.getPointAtLength(l);
          } catch (e) {
            return null;
          }
          const dx = p.x - targetX;
          const dy = p.y - targetY;
          const dist2 = dx * dx + dy * dy;
          if (dist2 < bestDist2) {
            bestDist2 = dist2;
            bestLen = l;
          }
        }
        window *= 0.45;
      }

      mapTrainLengthCache.set(cacheKey, bestLen);
      return bestLen;
    }

    function computeTrainPoseOnPath(pathEl, len, directionSign = 1) {
      if (!pathEl || typeof pathEl.getTotalLength !== 'function' || typeof pathEl.getPointAtLength !== 'function') return null;
      let total = null;
      try {
        total = pathEl.getTotalLength();
      } catch (e) {
        return null;
      }
      const clamped = clampNumber(len, 0, total);
      const delta = 1.5 * (directionSign >= 0 ? 1 : -1);
      const sample = clampNumber(clamped + delta, 0, total);
      let p = null;
      let p2 = null;
      try {
        p = pathEl.getPointAtLength(clamped);
        p2 = pathEl.getPointAtLength(sample);
      } catch (e) {
        return null;
      }
      if (!p || !p2) return null;
      const dx = p2.x - p.x;
      const dy = p2.y - p.y;
      const mag = Math.hypot(dx, dy) || 1;
      const ux = dx / mag;
      const uy = dy / mag;

      // Optional offset perpendicular to the line (kept at 0 by default so the train rides directly on the track).
      const nx = -uy;
      const ny = ux;
      const offsetX = nx * MRT_MAP_TRAIN_OFFSET_PX;
      const offsetY = ny * MRT_MAP_TRAIN_OFFSET_PX;

      const angle = (Math.atan2(dy, dx) * 180) / Math.PI;
      return {
        x: p.x + offsetX,
        y: p.y + offsetY,
        angle,
        ux,
        uy,
      };
    }

    function setMapTrainTransform(trainEl, pose) {
      if (!trainEl || !pose) return;
      const x = Number.isFinite(pose.x) ? pose.x : 0;
      const y = Number.isFinite(pose.y) ? pose.y : 0;
      const angle = Number.isFinite(pose.angle) ? pose.angle : 0;
      trainEl.setAttribute('transform', `translate(${x.toFixed(2)}, ${y.toFixed(2)}) rotate(${angle.toFixed(2)})`);
    }

    function setMapTrainLine(trainEl, line) {
      if (!trainEl) return;
      Array.from(trainEl.classList).forEach(cls => {
        if (cls.startsWith('line-')) trainEl.classList.remove(cls);
      });
      if (line) trainEl.classList.add(`line-${line}`);
    }

    function setMapTrainMotionShadow(trainEl, ux, uy) {
      if (!trainEl || !Number.isFinite(ux) || !Number.isFinite(uy)) return;
      // Trail opposite direction of travel.
      const dx = -ux;
      const dy = -uy;
      const s1x = (dx * 6).toFixed(2);
      const s1y = (dy * 6).toFixed(2);
      const s2x = (dx * 12).toFixed(2);
      const s2y = (dy * 12).toFixed(2);
      trainEl.style.filter =
        `drop-shadow(0 3px 6px rgba(0, 0, 0, 0.28)) ` +
        `drop-shadow(${s1x}px ${s1y}px 7px rgba(0, 0, 0, 0.16)) ` +
        `drop-shadow(${s2x}px ${s2y}px 10px rgba(0, 0, 0, 0.10))`;
    }

    function clearMapTrainMotionShadow(trainEl) {
      if (!trainEl) return;
      trainEl.style.filter = '';
    }

    function animateTrainAlongPathSegment({ trainEl, pathEl, fromLen, toLen, durationMs, routeToken }) {
      if (!trainEl || !pathEl) return Promise.resolve(false);
      let total = null;
      try {
        total = pathEl.getTotalLength();
      } catch (e) {
        return Promise.resolve(false);
      }
      const startLen = clampNumber(fromLen, 0, total);
      const endLen = clampNumber(toLen, 0, total);
      const dir = endLen >= startLen ? 1 : -1;
      const startAt = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
      const duration = clampNumber(durationMs, 200, 1800);
      let prevAngle = null;

      return new Promise(resolve => {
        const tick = now => {
          if (routeToken !== mapTrainMotionToken) {
            mapTrainMotionRafId = null;
            resolve(false);
            return;
          }
          if (!document.body.contains(trainEl)) {
            mapTrainMotionRafId = null;
            resolve(false);
            return;
          }

          const tRaw = ((now - startAt) / duration);
          const t = clampNumber(tRaw, 0, 1);
          const eased = easeInOutCubic(t);
          const len = startLen + (endLen - startLen) * eased;
          const pose = computeTrainPoseOnPath(pathEl, len, dir);
          if (!pose) {
            mapTrainMotionRafId = null;
            resolve(false);
            return;
          }

          // Gentle "suspension" lift (subtle; helps it feel less robotic).
          pose.y += Math.sin(eased * Math.PI) * -0.35;

          // Smooth rotation across the -180/180 seam.
          if (Number.isFinite(pose.angle)) {
            if (prevAngle !== null) {
              let a = pose.angle;
              while (a - prevAngle > 180) a -= 360;
              while (a - prevAngle < -180) a += 360;
              pose.angle = a;
            }
            prevAngle = pose.angle;
          }
          setMapTrainTransform(trainEl, pose);
          setMapTrainMotionShadow(trainEl, pose.ux, pose.uy);

          if (t < 1) {
            mapTrainMotionRafId = requestAnimationFrame(tick);
            return;
          }
          mapTrainMotionRafId = null;
          resolve(true);
        };

        mapTrainMotionRafId = requestAnimationFrame(tick);
      });
    }

    function animateMapTrainToStation(targetStationId, callback) {
      const train = document.getElementById('mapTrain');
      if (!train) {
        if (callback) callback();
        return;
      }

      // Station position data (must match generateMRTMap)
	      const stationPositions = {
	        // Red Line
	        fruit: { x: 250, y: 50, line: 'red' },
	        drink: { x: 250, y: 115, line: 'red' },
	        bakery: { x: 250, y: 180, line: 'red' },
	        redbean: { x: 250, y: 245, line: 'red' },
	        hub: { x: 250, y: 320, line: 'red' },
	        // Blue Line
	        pizza: { x: 50, y: 320, line: 'blue' },
	        bubbletea: { x: 140, y: 320, line: 'blue' },
	        burger: { x: 360, y: 320, line: 'blue' },
        icecream: { x: 450, y: 320, line: 'blue' },
        // Green Line
        fishshop: { x: 170, y: 410, line: 'green' },
        sushi: { x: 110, y: 480, line: 'green' },
        cheese: { x: 60, y: 550, line: 'green' },
        chicken: { x: 30, y: 620, line: 'green' },
        // Orange Line
        noodle: { x: 330, y: 410, line: 'orange' },
        smoothie: { x: 390, y: 490, line: 'orange' },
        teahouse: { x: 450, y: 570, line: 'orange' }
      };

      const targetPos = stationPositions[targetStationId];
      if (!targetPos) {
        if (callback) callback();
        return;
      }

      // Cancel any in-flight train motion (e.g., if the map was regenerated).
      cancelMapTrainMotion();
      const routeToken = ++mapTrainMotionToken;

      const currentStationId = state.mapTrainStation;
      const currentPos = currentStationId ? stationPositions[currentStationId] : null;

      const moveToPoseAndFinish = () => {
        setMapTrainLine(train, targetPos.line);
        const pathEl = findMrtLinePathElement(targetPos.line);
        if (pathEl) {
          const stationLen = getClosestLengthOnPath(pathEl, targetPos.x, targetPos.y);
          const hubLen = getClosestLengthOnPath(pathEl, MRT_MAP_HUB_POS.x, MRT_MAP_HUB_POS.y);
          const dir = (stationLen !== null && hubLen !== null && hubLen < stationLen) ? -1 : 1;
          if (stationLen !== null) {
            const pose = computeTrainPoseOnPath(pathEl, stationLen, dir);
            setMapTrainTransform(train, pose);
          } else {
            train.setAttribute('transform', `translate(${targetPos.x}, ${targetPos.y})`);
          }
        } else {
          train.setAttribute('transform', `translate(${targetPos.x}, ${targetPos.y})`);
        }
        clearMapTrainMotionShadow(train);
        state.mapTrainStation = targetStationId;
        if (callback) callback();
      };

      // If we don't know where the train is, just snap to the target (first render).
      if (!currentPos) {
        train.classList.remove('idle');
        train.classList.add('moving');
        moveToPoseAndFinish();
        train.classList.remove('moving');
        train.classList.add('idle');
        return;
      }

      const startLine = currentPos.line;
      const endLine = targetPos.line;
      const sameLine = startLine === endLine;

      const run = async () => {
        // Anticipation before departure.
        train.classList.remove('idle');
        train.classList.remove('arriving');
        train.classList.add('anticipating');
        await new Promise(r => setTimeout(r, 260));
        if (routeToken !== mapTrainMotionToken) return;

        train.classList.remove('anticipating');
        train.classList.add('moving');

        const segments = [];
        if (sameLine) {
          segments.push({ line: startLine, from: currentPos, to: targetPos });
        } else {
          segments.push({ line: startLine, from: currentPos, to: MRT_MAP_HUB_POS });
          segments.push({ line: endLine, from: MRT_MAP_HUB_POS, to: targetPos, pauseBeforeMs: 140 });
        }

        for (let i = 0; i < segments.length; i++) {
          if (routeToken !== mapTrainMotionToken) return;
          const seg = segments[i];
          if (seg.pauseBeforeMs) await new Promise(r => setTimeout(r, seg.pauseBeforeMs));
          if (routeToken !== mapTrainMotionToken) return;

          setMapTrainLine(train, seg.line);
          const pathEl = findMrtLinePathElement(seg.line);
          if (!pathEl) continue;

          const fromLen = getClosestLengthOnPath(pathEl, seg.from.x, seg.from.y);
          const toLen = getClosestLengthOnPath(pathEl, seg.to.x, seg.to.y);
          if (fromLen === null || toLen === null) continue;

          const travelPx = Math.abs(toLen - fromLen);
          const durationMs = clampNumber(320 + travelPx * 4.2, 420, 1400);
          const ok = await animateTrainAlongPathSegment({
            trainEl: train,
            pathEl,
            fromLen,
            toLen,
            durationMs,
            routeToken,
          });
          if (!ok) return;
        }

        // Arrival bounce.
        train.classList.remove('moving');
        clearMapTrainMotionShadow(train);
        train.classList.add('arriving');
        state.mapTrainStation = targetStationId;

        setTimeout(() => {
          if (routeToken !== mapTrainMotionToken) return;
          train.classList.remove('arriving');
          train.classList.add('idle');
          if (callback) callback();
        }, 800);
      };

      run();
    }

    // Calculate waypoints for train journey following the actual track
    function calculateTrainWaypoints(currentPos, targetPos, currentStationId, targetStationId, stationPositions, HUB) {
      const waypoints = [];

      // Check if we need to change lines
      const needsLineChange = currentPos.line !== targetPos.line;

      if (needsLineChange) {
        // Route through hub: current â†’ hub â†’ target

        // 1. Current station to hub
        const waypointsToHub = getWaypointsAlongLine(currentPos, HUB, currentPos.line, currentStationId, 'hub', stationPositions);
        waypoints.push(...waypointsToHub);

        // 2. Hub to target station
        const waypointsFromHub = getWaypointsAlongLine(HUB, targetPos, targetPos.line, 'hub', targetStationId, stationPositions);
        waypoints.push(...waypointsFromHub);

      } else {
        // Same line: direct route with waypoints
        const directWaypoints = getWaypointsAlongLine(currentPos, targetPos, currentPos.line, currentStationId, targetStationId, stationPositions);
        waypoints.push(...directWaypoints);
      }

      return waypoints;
    }

    // Get waypoints along a specific line
    function getWaypointsAlongLine(startPos, endPos, lineType, startStationId, endStationId, stationPositions) {
      const waypoints = [];

      if (lineType === 'red') {
        // Red line is vertical - simple linear interpolation
        const steps = Math.abs(endPos.y - startPos.y) / 15; // One waypoint every 15px
        const numSteps = Math.max(2, Math.ceil(steps));

        for (let i = 1; i <= numSteps; i++) {
          const t = i / numSteps;
          waypoints.push({
            x: startPos.x,
            y: startPos.y + (endPos.y - startPos.y) * t,
            line: lineType
          });
        }

      } else if (lineType === 'blue') {
        // Blue line is horizontal - simple linear interpolation
        const steps = Math.abs(endPos.x - startPos.x) / 15; // One waypoint every 15px
        const numSteps = Math.max(2, Math.ceil(steps));

        for (let i = 1; i <= numSteps; i++) {
          const t = i / numSteps;
          waypoints.push({
            x: startPos.x + (endPos.x - startPos.x) * t,
            y: startPos.y,
            line: lineType
          });
        }

      } else if (lineType === 'green') {
        // Green line follows the curved path
        // Path: M 250 320 L 250 360 Q 250 380, 220 400 L 170 410 L 110 480 L 60 550 L 30 620
        const greenPath = [
          { x: 250, y: 320 },  // Hub
          { x: 250, y: 360 },  // Straight down
          { x: 220, y: 400 },  // Curve end
          { x: 170, y: 410 },  // Fish Shop
          { x: 110, y: 480 },  // Sushi
          { x: 60, y: 550 },   // Cheese
          { x: 30, y: 620 }    // Chicken
        ];

        waypoints.push(...interpolateAlongPath(greenPath, startPos, endPos, 15));

      } else if (lineType === 'orange') {
        // Orange line follows the curved path
        // Path: M 250 320 L 250 360 Q 250 380, 280 400 L 330 410 L 390 490 L 450 570
        const orangePath = [
          { x: 250, y: 320 },  // Hub
          { x: 250, y: 360 },  // Straight down
          { x: 280, y: 400 },  // Curve end
          { x: 330, y: 410 },  // Noodle
          { x: 390, y: 490 },  // Smoothie
          { x: 450, y: 570 }   // Tea House
        ];

        waypoints.push(...interpolateAlongPath(orangePath, startPos, endPos, 15));
      }

      return waypoints;
    }

    // Interpolate points along a path
    function interpolateAlongPath(pathPoints, startPos, endPos, stepSize) {
      const waypoints = [];

      // Find start and end indices in the path
      let startIdx = pathPoints.findIndex(p => Math.abs(p.x - startPos.x) < 5 && Math.abs(p.y - startPos.y) < 5);
      let endIdx = pathPoints.findIndex(p => Math.abs(p.x - endPos.x) < 5 && Math.abs(p.y - endPos.y) < 5);

      if (startIdx === -1) startIdx = 0;
      if (endIdx === -1) endIdx = pathPoints.length - 1;

      // Determine direction
      const direction = endIdx > startIdx ? 1 : -1;

      // Interpolate between consecutive path points
      for (let i = startIdx; direction > 0 ? i < endIdx : i > endIdx; i += direction) {
        const p1 = pathPoints[i];
        const p2 = pathPoints[i + direction];

        const dx = p2.x - p1.x;
        const dy = p2.y - p1.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        const steps = Math.max(1, Math.ceil(distance / stepSize));

        for (let j = 0; j <= steps; j++) {
          const t = j / steps;
          waypoints.push({
            x: p1.x + dx * t,
            y: p1.y + dy * t
          });
        }
      }

      // Always end at the exact target position
      waypoints.push({ x: endPos.x, y: endPos.y });

      return waypoints;
    }

    // Animate train through waypoints sequentially
    function animateTrainThroughWaypoints(train, waypoints, finalLine, callback) {
      if (waypoints.length === 0) {
        if (callback) callback();
        return;
      }

      let currentWaypointIndex = 0;
      const baseSpeed = 90; // ms per waypoint - express train speed!

      // Smooth cubic-bezier for that modern metro feel
      const easing = 'cubic-bezier(0.4, 0, 0.2, 1)';

      function moveToNextWaypoint() {
        if (currentWaypointIndex >= waypoints.length) {
          // Update final line color
          Array.from(train.classList).forEach(cls => {
            if (cls.startsWith('line-')) train.classList.remove(cls);
          });
          train.classList.add(`line-${finalLine}`);

          if (callback) callback();
          return;
        }

        const waypoint = waypoints[currentWaypointIndex];
        const targetX = waypoint.x;
        const targetY = waypoint.y - 36; // Train sits above the track

        // Update line color if specified
        if (waypoint.line) {
          Array.from(train.classList).forEach(cls => {
            if (cls.startsWith('line-')) train.classList.remove(cls);
          });
          train.classList.add(`line-${waypoint.line}`);
        }

        // Use smooth cubic-bezier easing for fluid, natural movement
        train.style.transition = `transform ${baseSpeed}ms ${easing}`;
        train.setAttribute('transform', `translate(${targetX}, ${targetY})`);

        currentWaypointIndex++;

        // Move to next waypoint
        setTimeout(moveToNextWaypoint, baseSpeed);
      }

      moveToNextWaypoint();
    }

    // Clear all station transition state and visual feedback
	    function clearStationTransitionState() {
	      state.isTransitioningToStation = false;

      // Remove boarding class from map
      const mrtMap = document.querySelector('.mrt-map');
      if (mrtMap) {
        mrtMap.classList.remove('boarding');
      }

      // Remove selected class from all stations
      document.querySelectorAll('.mrt-station.selected').forEach(el => {
        el.classList.remove('selected');
      });

      // Remove any leftover ripple elements
	      document.querySelectorAll('.mrt-selection-ripple').forEach(el => el.remove());
	    }

	    function restartRideSceneAnimations(options = {}) {
	      const direction = options.direction === 'return' ? 'return' : 'outbound';
	      const rideScreen = document.getElementById('mrtRideScreen');
	      if (rideScreen) rideScreen.classList.toggle('returning', direction === 'return');

	      const train = document.getElementById('mrtTrain') || document.querySelector('#mrtRideScreen .mrt-train');
	      if (train) {
	        train.style.animation = 'none';
	        train.offsetHeight; // Trigger reflow
	        train.style.animation = 'mrt-glide 7.5s linear infinite';
	        train.style.animationDirection = direction === 'return' ? 'reverse' : 'normal';
	      }

	      const floaters = document.querySelectorAll('.floater');
	      floaters.forEach(floater => {
	        floater.style.animation = 'none';
	        floater.offsetHeight;
	        floater.style.animation = 'floater-drift 4s ease-in-out infinite';
	        floater.style.animationDirection = direction === 'return' ? 'reverse' : 'normal';
	      });
	    }

	    function selectStation(stationId) {
	      // Prevent double-clicking stations while transitioning
	      if (state.isTransitioningToStation) {
	        console.log('Station click ignored - already transitioning');
	        return;
	      }

	      // New journey: allow the map train to depart from the hub/last position.
	      state.mapTrainAtHub = false;

	      // Lock station clicks
	      state.isTransitioningToStation = true;

      // Add visual feedback - boarding state on map
      const mrtMap = document.querySelector('.mrt-map');
      if (mrtMap) {
        mrtMap.classList.add('boarding');
      }

      // Mark selected station with animation
      const selectedStationEl = document.querySelector(`.mrt-station[data-station="${stationId}"]`);
      if (selectedStationEl) {
        // Remove selected class from any previous selection
        document.querySelectorAll('.mrt-station.selected').forEach(el => el.classList.remove('selected'));
        selectedStationEl.classList.add('selected');

        // Add ripple effect circles for visual feedback
        const svgNS = 'http://www.w3.org/2000/svg';
        const ripple1 = document.createElementNS(svgNS, 'circle');
        ripple1.setAttribute('class', 'mrt-selection-ripple');
        ripple1.setAttribute('cx', '0');
        ripple1.setAttribute('cy', '0');
        ripple1.setAttribute('r', '18');
        selectedStationEl.insertBefore(ripple1, selectedStationEl.firstChild);

        const ripple2 = document.createElementNS(svgNS, 'circle');
        ripple2.setAttribute('class', 'mrt-selection-ripple');
        ripple2.setAttribute('cx', '0');
        ripple2.setAttribute('cy', '0');
        ripple2.setAttribute('r', '18');
        selectedStationEl.insertBefore(ripple2, selectedStationEl.firstChild);

        // Clean up ripples after animation completes
        setTimeout(() => {
          ripple1.remove();
          ripple2.remove();
        }, 1000);
      }

      state.currentStation = stationId;
      state.currentPage = 0;
      state.currentOrder = null;
      beginStorySessionIfNeeded(stationId);
      state.sessionPages = buildSessionPagesForStation(stationId);

      // Enable immersive storybook mode for stories with immersiveMode flag
      const storyGraph = getFoodStoryGraph(stationId);
      if (storyGraph && storyGraph.immersiveMode) {
        document.body.classList.add('storybook-mode');
      } else {
        document.body.classList.remove('storybook-mode');
      }

      saveProgress();

      const stationForLog = stationContent[stationId];
      logCloudEvent('station_started', {
        stationId,
        stationName: stationForLog && stationForLog.name ? stationForLog.name : null,
      });

      if (state.stationTransitionTimeoutId) {
        clearTimeout(state.stationTransitionTimeoutId);
        state.stationTransitionTimeoutId = null;
      }

      // Animate the map train to this station first
      animateMapTrainToStation(stationId, async () => {
        // Start preloading audio in background during train ride (~6 seconds)
        preloadStationAudio(stationId, state.sessionPages);

        // Preload station images during train ride for instant display
        if (stationImages[stationId]) {
          preloadImage(stationImages[stationId]);
        }
        if (stationIcons[stationId]) {
          preloadImage(stationIcons[stationId]);
        }
        // Preload the elevator door reveal scenes so the doors can open instantly.
        preloadElevatorScenesForStation(stationId);

        const station = stationContent[stationId];
        const theme = stationThemes[stationId];
        const rideScreen = document.getElementById('mrtRideScreen');

        // Preload the train scene background image BEFORE showing the screen
        // This prevents the flash where SVG background shows before the image loads
        if (theme && theme.sceneImage) {
          try {
            await Promise.race([
              preloadImage(theme.sceneImage),
              new Promise(resolve => setTimeout(resolve, 500)) // Fallback timeout
            ]);
          } catch (e) {
            // Image failed to load, continue anyway
          }
        }

        // Update destination banner
        document.getElementById('destinationName').textContent = station.name;
        const rideIconEl = document.getElementById('rideIcon');
        if (rideIconEl) rideIconEl.textContent = '';

        // Remove all theme classes and apply new one
        rideScreen.className = 'screen mrt-ride-screen';
        if (theme) {
          rideScreen.classList.add(theme.themeClass);

          // Update floating elements with themed emojis
          const floatersContainer = document.getElementById('themedFloaters');
          floatersContainer.innerHTML = '';
        }

	        // Show MRT ride animation
	        goToScreen('mrtRideScreen');
	        restartRideSceneAnimations({ direction: 'outbound' });

	        // After the ride, show elevator (give a bit more time to enjoy the train)
	        state.stationTransitionTimeoutId = setTimeout(() => {
          goToScreen('elevatorScreen');
          showElevatorAtFloor(1, { openDoors: false });
          const doors = document.getElementById('elevatorDoors');
          if (doors) setTimeout(() => doors.classList.add('doors-open'), 250);
          state.stationTransitionTimeoutId = null;
        }, 6000);
      }); // End of animateMapTrainToStation callback
    }

    async function goHome() {
      const settingsModal = document.getElementById('settingsModal');
      const profilesModal = document.getElementById('profilesModal');
      const dashboardModal = document.getElementById('dashboardModal');
      const wasSettingsOpen = !!(settingsModal && settingsModal.classList.contains('active'));
      const wasProfilesOpen = !!(profilesModal && profilesModal.classList.contains('active'));
      const wasDashboardOpen = !!(dashboardModal && dashboardModal.classList.contains('active'));

      const isInLessonFlow =
        state.currentScreen === 'mrtRideScreen' ||
        state.currentScreen === 'elevatorScreen' ||
        state.currentScreen === 'warmupScreen' ||
        state.currentScreen === 'restaurantScreen';

      if (isInLessonFlow && state.currentStation) {
        const ok = await showConfirmModal({
          title: 'Leave this story?',
          message: 'Go back to the station map? You will leave this story.',
          confirmText: 'Go to map',
          cancelText: 'Stay here',
          danger: false,
        });
        if (!ok) return;
      }

      if (wasSettingsOpen) closeSettings();
      if (wasProfilesOpen) closeProfiles();
      if (wasDashboardOpen) closeDashboard();
      closeBuddyMenu();

      // Persist any in-flight progress + last position before resetting the session state.
	      saveProgress();

	      stopSpeech();
	      cancelElevatorAutoFlow();
	      clearSightWordGate();

      if (state.stationTransitionTimeoutId) {
        clearTimeout(state.stationTransitionTimeoutId);
        state.stationTransitionTimeoutId = null;
      }

      // Clear station transition state and visual feedback
      clearStationTransitionState();

	      state.currentStation = null;
	      state.currentOrder = null;
	      state.currentPage = 0;
	      state.currentFloor = 1;
	      state.sessionPages = null;
	      state.storySession = null;
	      state.lessonElevatorPlan = null;
	      state.lessonElevatorSegmentByPage = null;
	      state.lessonElevatorVisitedSegments = null;
	      state.lessonElevatorActiveSegment = 0;
	      state.practiceSkillId = null;
	      state.practiceCorrect = 0;
	      state.practiceFirstTryCorrect = 0;
	      state.practiceTotal = 0;

      // Exit immersive storybook mode when leaving lesson
      document.body.classList.remove('storybook-mode');

      generateMRTMap();
      goToScreen('mrtScreen');
    }

    // ===== ELEVATOR =====
    const elevatorDoorScenes = {
      lobby: 'assets/elevator_scenes/lobby.jpg',
      warmup: {
        fruit: 'assets/elevator_scenes/fruit_warmup.jpg',
        drink: 'assets/elevator_scenes/drink_warmup.jpg',
        bakery: 'assets/elevator_scenes/bakery_warmup.jpg',
        pizza: 'assets/elevator_scenes/pizza_warmup.jpg',
        icecream: 'assets/elevator_scenes/icecream_warmup.jpg',
        fishshop: 'assets/elevator_scenes/fishshop_warmup.jpg',
        cheese: 'assets/elevator_scenes/cheese_warmup.jpg',
        noodle: 'assets/elevator_scenes/noodle_warmup.jpg'
      },
      restaurant: {
        fruit: 'assets/elevator_scenes/fruit_restaurant.jpg',
        drink: 'assets/elevator_scenes/drink_restaurant.jpg',
        bakery: 'assets/elevator_scenes/bakery_restaurant.jpg',
        pizza: 'assets/elevator_scenes/pizza_restaurant.jpg',
        icecream: 'assets/elevator_scenes/icecream_restaurant.jpg',
        fishshop: 'assets/elevator_scenes/fishshop_restaurant.jpg',
        cheese: 'assets/elevator_scenes/cheese_restaurant.jpg',
        noodle: 'assets/elevator_scenes/noodle_restaurant.jpg'
      }
    };

    // Some stations reuse assets; fall back to a "base" station so the elevator doors never open to a blank screen.
	    const elevatorDoorSceneFallbackStations = {
	      redbean: 'bakery',
	      bubbletea: 'drink',
	      burger: 'pizza',
	      sushi: 'fishshop',
	      chicken: 'cheese',
	      smoothie: 'drink',
	      teahouse: 'noodle',
	      practice: null,
	    };

	    const ELEVATOR_STYLE_COUNT = 10;
	    const ELEVATOR_PASSAGE_SCENE_POOL = [
	      'assets/train_scenes/taipei_101_day.jpeg',
	      'assets/train_scenes/taipei_night_market.png',
	      'assets/train_scenes/taipei_mrt_elevated.png',
	      'assets/train_scenes/taipei_temple.jpeg',
	      'assets/train_scenes/taipei_riverside.png',
	      'assets/train_scenes/taipei_harbor.png',
	      'assets/train_scenes/taipei_park.png',
	      'assets/train_scenes/taipei_mountain.jpeg',
	      'assets/train_scenes/taipei_bubble_tea.jpeg',
	      'assets/train_scenes/taipei_redbean_bakery.jpeg'
	    ];

	    let activeElevatorFlow = null;

	    function pickElevatorPassageSceneUrl(index) {
	      const pool = ELEVATOR_PASSAGE_SCENE_POOL;
	      if (!Array.isArray(pool) || pool.length === 0) return null;
	      const i = Math.abs(Number(index) || 0) % pool.length;
	      return pool[i] || null;
	    }

	    let elevatorPassageScenesPreloaded = false;
	    function preloadElevatorPassageScenesOnce() {
	      if (elevatorPassageScenesPreloaded) return;
	      elevatorPassageScenesPreloaded = true;
	      ELEVATOR_PASSAGE_SCENE_POOL.forEach(src => {
	        if (!src) return;
	        preloadImage(src).catch(() => { });
	      });
	    }

	    function getElevatorDoorSceneUrl(stationId, floor) {
	      if (activeElevatorFlow && activeElevatorFlow.doorSceneUrl) {
	        return activeElevatorFlow.doorSceneUrl;
	      }
	      if (floor === 1) return elevatorDoorScenes.lobby || null;

	      const key = floor === 2 ? 'warmup' : floor === 3 ? 'restaurant' : null;
	      if (!key) {
	        if (floor >= 4) return pickElevatorPassageSceneUrl(floor - 4) || elevatorDoorScenes.lobby || null;
	        return elevatorDoorScenes.lobby || null;
	      }

      const direct = elevatorDoorScenes[key] && stationId ? elevatorDoorScenes[key][stationId] : null;
      if (direct) return direct;

      const fallbackStation = stationId ? (elevatorDoorSceneFallbackStations[stationId] || null) : null;
      const fallback = fallbackStation ? (elevatorDoorScenes[key] && elevatorDoorScenes[key][fallbackStation]) : null;
      if (fallback) return fallback;

      // Final fallback so the door window is never empty.
      return elevatorDoorScenes.lobby || null;
    }

    function setElevatorDoorScene(stationId, floor) {
      const doorWindow = document.getElementById('doorWindow');
      if (!doorWindow) return;

      const url = getElevatorDoorSceneUrl(stationId, floor);
      if (url) {
        // Keep a gradient fallback in case the image fails to load.
        doorWindow.style.backgroundImage =
          `url('${url}'), linear-gradient(180deg, #FFF8E7 0%, #FFF0D4 50%, #FFE8C4 100%)`;
        doorWindow.dataset.sceneReady = '1';
        doorWindow.dataset.sceneFloor = String(floor);
        doorWindow.dataset.sceneStation = stationId || '';
      } else {
        doorWindow.style.backgroundImage = '';
        doorWindow.dataset.sceneReady = '0';
        doorWindow.dataset.sceneFloor = '';
        doorWindow.dataset.sceneStation = '';
      }
    }

	    function preloadElevatorScenesForStation(stationId) {
	      preloadElevatorPassageScenesOnce();
	      const warmup = getElevatorDoorSceneUrl(stationId, 2);
	      const restaurant = getElevatorDoorSceneUrl(stationId, 3);
	      if (warmup) preloadImage(warmup).catch(() => { });
	      if (restaurant) preloadImage(restaurant).catch(() => { });
	    }

    let elevatorInMotion = false;

    function setElevatorControlsEnabled(enabled) {
      document.querySelectorAll('.floor-btn').forEach(btn => {
        btn.disabled = !enabled;
      });
    }

    function showElevatorAtFloor(floor, options = {}) {
      const openDoors = options.openDoors !== false;

      state.currentFloor = floor;

      const display = document.getElementById('floorDisplay');
      if (display) display.textContent = toVisualFloor(floor);

      document.querySelectorAll('.floor-btn').forEach(btn => btn.classList.remove('active'));
      const floorBtn = document.getElementById(`floor${floor}Btn`);
      if (floorBtn) floorBtn.classList.add('active');

      const doors = document.getElementById('elevatorDoors');
      if (doors) doors.classList.toggle('doors-open', openDoors);

      setElevatorDoorScene(state.currentStation, floor);
      setElevatorControlsEnabled(true);
      elevatorInMotion = false;
    }

    // Helper: Convert internal floor number to visual string
    // n > 0: "1", "2", "3"...
    // n <= 0: "B1", "B2", "B3"...
    function toVisualFloor(n) {
      if (n > 0) return String(n);
      return 'B' + (Math.abs(n) + 1);
    }

	    // Helper: Generate a logical sequential path with an excursion (pivot)
	    function generateElevatorSequence(start, end, options = {}) {
	      const mode = options && options.mode ? options.mode : 'scenic';
	      const startNum = Number(start);
	      const endNum = Number(end);

	      // Quick mode: short, direct ride for frequent in-lesson transitions.
	      if (mode === 'quick') {
	        if (!Number.isFinite(startNum) || !Number.isFinite(endNum)) {
	          const safeEnd = Number.isFinite(endNum) ? endNum : 1;
	          return [toVisualFloor(safeEnd)];
	        }
	        if (startNum === endNum) return [toVisualFloor(endNum)];

	        const sequence = [];
	        const step = endNum > startNum ? 1 : -1;
	        let current = startNum;
	        const maxSteps = Math.min(14, Math.abs(endNum - startNum) + 6);

	        for (let i = 0; i < maxSteps && current !== endNum; i++) {
	          sequence.push(toVisualFloor(current));
	          current += step;
	        }
	        sequence.push(toVisualFloor(endNum));
	        return sequence;
	      }

	      const sequence = [];

	      // 1. Choose a Pivot Floor to make the journey long/interesting
	      // 50% chance of going deep (Basement), 50% chance of going high (Sky)
	      // Basement range: -3 to 0 (B4 to B1)
	      // High range: 30 to 50
	      let pivot;
      if (Math.random() > 0.5) {
        // Go High
        pivot = Math.floor(Math.random() * 21) + 30; // 30-50
      } else {
        // Go Deep
        pivot = -Math.floor(Math.random() * 4); // 0 to -3 (B1-B4)
      }

      // 2. Generate path: Start -> Pivot
      let current = start;
      // Go towards pivot
      while (current !== pivot) {
        sequence.push(toVisualFloor(current));
        current += (pivot > current) ? 1 : -1;
      }

      // 3. Generate path: Pivot -> End
      // Go towards end (reset current to pivot logic flow)
      while (current !== end) {
        sequence.push(toVisualFloor(current));
        current += (end > current) ? 1 : -1;
      }

      // Ensure specific target is added effectively by the loop or explicitly at end
      sequence.push(toVisualFloor(end));

      return sequence;
    }

	    function selectFloor(floor) {
	      if (floor === state.currentFloor) return;
	      if (elevatorInMotion) return;
	      elevatorInMotion = true;
	      setElevatorControlsEnabled(false);

	      // Update button states
	      document.querySelectorAll('.floor-btn').forEach(btn => btn.classList.remove('active'));
	      const floorBtn = document.getElementById(`floor${floor}Btn`);
	      if (floorBtn) floorBtn.classList.add('active');

	      // Get elevator elements
	      const display = document.getElementById('floorDisplay');
	      const doors = document.getElementById('elevatorDoors');
	      const shaft = document.getElementById('elevatorShaft');
      if (!display || !doors || !shaft) {
        elevatorInMotion = false;
        setElevatorControlsEnabled(true);
        return;
      }

      // Close doors with slower animation
      doors.classList.remove('doors-open');
      // Removed auto-play: speak('Doors closing');

	      // Start elevator movement after doors close (1.5s for door close animation)
	      const flowMode = activeElevatorFlow && activeElevatorFlow.mode ? activeElevatorFlow.mode : 'scenic';
	      const doorCloseMs = flowMode === 'quick' ? 750 : 1500;
	      const stepIntervalMs = flowMode === 'quick' ? 60 : 90;
	      const arrivalDelayMs = flowMode === 'quick' ? 520 : 800;
	      setTimeout(() => {
	        // Add elevator movement shake effect
	        shaft.classList.add('moving');
	        // Add new elevator-moving class for light streaks
	        shaft.classList.add('elevator-moving');
	        // Add particles for themed styles (6, 7, 8)
	        shaft.classList.add('with-particles');

	        // Add changing class for LED flicker effect
	        display.classList.add('changing');
	        // Add floor-pulse class for enhanced pulse effect
	        display.classList.add('floor-pulse');

	        // Generate the random sequence for the digital display effect
	        const rideSequence = generateElevatorSequence(state.currentFloor, floor, { mode: flowMode });
	        let seqIndex = 0;

	        // Faster interval for "digital scrolling" effect (100ms)
	        const interval = setInterval(() => {
          if (seqIndex >= rideSequence.length) {
            clearInterval(interval);
            state.currentFloor = floor;
            display.textContent = toVisualFloor(floor); // Ensure final is correct
            display.classList.remove('changing', 'floor-pulse');

            // Remove movement effects and add arrival animation
            shaft.classList.remove('elevator-moving', 'with-particles');
            setTimeout(() => {
              shaft.classList.remove('moving');
              // Add joy hop arrival animation
              shaft.classList.add('arrived');
              setTimeout(() => {
                shaft.classList.remove('arrived');
              }, 600);
            }, 300);

            // Add chime effect to floor display
            display.classList.add('chime');
            setTimeout(() => {
              display.classList.remove('chime');
            }, 800);

	            // Open doors after elevator stops (800ms delay for realism)
	            setTimeout(() => {
	              setElevatorDoorScene(state.currentStation, floor);
	              doors.classList.add('doors-open');
	              elevatorInMotion = false;
	              // Removed auto-play: speak(`Floor ${floor}. Doors opening.`);

	              const flow = activeElevatorFlow;
	              if (flow && flow.targetFloor === floor) {
	                const token = flow.token;
	                const afterDoorMs = Number.isFinite(flow.afterDoorMs) ? flow.afterDoorMs : 3100;
	                setTimeout(() => {
	                  if (!activeElevatorFlow || activeElevatorFlow.token !== token) return;
	                  const onArrive = activeElevatorFlow.onArrive;
	                  const cleanup = activeElevatorFlow.onCleanup;
	                  activeElevatorFlow = null;
	                  setElevatorAutoMode(false);
	                  if (typeof cleanup === 'function') cleanup();
	                  if (typeof onArrive === 'function') onArrive();
	                }, Math.max(0, afterDoorMs));
	              }

	              // Floor 2: Word Warm-Up
	              if (floor === 2) {
	                setTimeout(() => {
	                  showWarmup();
	                }, 1800);
	                return;
	              }

              // Floor 3: Food Stop (reading + activities)
              // Extended delay (1800 + 1500 = 3300ms) so user can enjoy the destination scene
              if (floor === 3) {
                setTimeout(() => {
                  showRestaurant();
                }, 3300);
                return;
              }

	              // Unlock controls if just visiting Lobby (Floor 1)
	              if (floor === 1) {
	                setElevatorControlsEnabled(true);
	              }

	            }, arrivalDelayMs);
	            return;
	          }

          // Update display with next in sequence
          display.textContent = rideSequence[seqIndex];
          seqIndex++;

	        }, stepIntervalMs); // 90ms per floor for smoother, readable scrolling
	      }, doorCloseMs);
	    }

	    function setElevatorStyleIndex(styleIndex) {
	      const screen = document.getElementById('elevatorScreen');
	      if (!screen) return;
	      for (let i = 1; i <= ELEVATOR_STYLE_COUNT; i++) {
	        screen.classList.remove(`elevator-style-${i}`);
	      }
	      const safe = (Math.abs(Number(styleIndex) || 0) % ELEVATOR_STYLE_COUNT) + 1;
	      screen.classList.add(`elevator-style-${safe}`);
	    }

	    function setElevatorAutoMode(enabled, options = {}) {
	      const screen = document.getElementById('elevatorScreen');
	      if (!screen) return;
	      screen.classList.toggle('elevator-auto-mode', !!enabled);

	      const titleEl = screen.querySelector('.panel-title');
	      if (!titleEl) return;
	      if (enabled) {
	        titleEl.textContent = options.title || 'Goingâ€¦';
	      } else {
	        titleEl.textContent = 'Pick a Floor';
	      }
	    }

	    function cancelElevatorAutoFlow() {
	      activeElevatorFlow = null;
	      setElevatorAutoMode(false);
	    }

	    function startElevatorAutoTrip(options = {}) {
	      const targetFloor = Number(options.targetFloor);
	      if (!Number.isFinite(targetFloor)) return;
	      if (targetFloor === state.currentFloor) {
	        if (typeof options.onArrive === 'function') options.onArrive();
	        return;
	      }

	      state.elevatorTripCounter = (Number(state.elevatorTripCounter) || 0) + 1;
	      const styleIndex = Number.isFinite(options.styleIndex) ? options.styleIndex : (state.elevatorTripCounter - 1);
	      setElevatorStyleIndex(styleIndex);

	      const token = `${Date.now()}_${Math.random().toString(16).slice(2)}`;
	      activeElevatorFlow = {
	        token,
	        targetFloor,
	        doorSceneUrl: options.doorSceneUrl || null,
	        mode: options.mode || 'quick',
	        afterDoorMs: Number.isFinite(options.afterDoorMs) ? options.afterDoorMs : 3100,
	        onArrive: typeof options.onArrive === 'function' ? options.onArrive : null,
	        onCleanup: typeof options.onCleanup === 'function' ? options.onCleanup : null,
	      };

	      setElevatorAutoMode(true, { title: options.title || `Floor ${toVisualFloor(targetFloor)}` });
	      goToScreen('elevatorScreen');

	      // Start with doors open briefly so the learner "steps in", then travel.
	      showElevatorAtFloor(state.currentFloor, { openDoors: true });
	      setTimeout(() => {
	        if (state.currentScreen !== 'elevatorScreen') return;
	        if (!activeElevatorFlow || activeElevatorFlow.token !== token) return;
	        selectFloor(targetFloor);
	      }, 420);
	    }

    // Diverse floor sequences for elevator journeys
    // Each journey picks a random sequence, floors flow logically
    // Floor range: B4 (-3) to Floor 10 (9) for shorter lesson elevator scenes
    const ELEVATOR_FLOOR_JOURNEYS = [
      // Ground to upper floors
      [0, 3, 6, 9],
      [1, 4, 7, 9],
      [0, 2, 5, 8],
      [1, 3, 5, 7, 9],
      [0, 4, 8],
      // Basement explorations (B4=-3, B3=-2, B2=-1)
      [-3, -1, 2, 5],
      [-2, 0, 3, 6],
      [-1, 1, 4, 7],
      [-3, -2, -1, 0, 2],
      [-2, 1, 5, 9],
      // Mixed adventures
      [0, 5, -1, 3, 8],
      [2, 7, -2, 4, 9],
      [-1, 3, 7, 1, 5],
      [0, -3, 2, 6, 9],
      [-2, 4, 8, 0, 5],
      // Quick hops
      [0, 3, 6],
      [1, 5, 9],
      [-1, 2, 6],
      [0, 4, 9],
      [-2, 3, 7],
    ];

	    function buildLessonElevatorPlanForPages(stationId, pages) {
	      if (!Array.isArray(pages) || pages.length === 0) return null;

	      const starts = new Set([0]);
	      const firstReadIndex = pages.findIndex(p => p && p.type === 'read');
	      if (firstReadIndex > 0) starts.add(firstReadIndex);
	      if (firstReadIndex !== -1) {
	        for (let i = firstReadIndex + 1; i < pages.length; i++) {
	          if (pages[i] && pages[i].type === 'read') starts.add(i);
	        }
	      }

	      const sortedStarts = Array.from(starts).sort((a, b) => a - b);
	      const segments = [];
	      const segmentByPage = new Array(pages.length).fill(0);

	      // Pick a random floor journey for this lesson
	      const journeyIndex = Math.floor(Math.random() * ELEVATOR_FLOOR_JOURNEYS.length);
	      const floorJourney = ELEVATOR_FLOOR_JOURNEYS[journeyIndex];

	      sortedStarts.forEach((startIndex, idx) => {
	        const endIndex = (idx + 1 < sortedStarts.length) ? (sortedStarts[idx + 1] - 1) : (pages.length - 1);
	        const segmentIndex = segments.length;
	        // Use diverse floor from journey, cycling if more segments than floors
	        const floor = floorJourney[segmentIndex % floorJourney.length];
	        const baseScene = getElevatorDoorSceneUrl(stationId, 3);
	        const sceneUrl = segmentIndex === 0 ? baseScene : pickElevatorPassageSceneUrl(segmentIndex - 1);
	        const styleIndex = segmentIndex % ELEVATOR_STYLE_COUNT;

	        segments.push({ segmentIndex, startIndex, endIndex, floor, sceneUrl, styleIndex });
	        for (let i = startIndex; i <= endIndex; i++) segmentByPage[i] = segmentIndex;
	      });

	      return { segments, segmentByPage };
	    }

	    function applyLessonSceneForSegment(segment) {
	      const restaurantScreen = document.getElementById('restaurantScreen');
	      if (restaurantScreen) {
	        if (segment && segment.sceneUrl) {
	          restaurantScreen.style.setProperty('--restaurant-scene-image', `url('${segment.sceneUrl}')`);
	        } else {
	          restaurantScreen.style.setProperty('--restaurant-scene-image', 'none');
	        }
	      }

	      const chip = document.getElementById('lessonFloorChip');
	      if (chip) {
	        const floor = segment && Number.isFinite(segment.floor) ? segment.floor : state.currentFloor;
	        chip.textContent = `Floor ${toVisualFloor(floor)}`;
	      }
	    }

	    function resetLessonElevatorFlowForStation(stationId) {
	      const station = stationId && stationContent ? stationContent[stationId] : null;
	      // Story pilot: keep the lesson scene stable (no mid-story elevator trips).
	      if (station && station.isStory) {
	        state.lessonElevatorPlan = null;
	        state.lessonElevatorSegmentByPage = null;
	        state.lessonElevatorVisitedSegments = new Set([0]);
	        state.lessonElevatorActiveSegment = 0;

	        const floor = Number.isFinite(station.floor) ? station.floor : 3;
	        const sceneUrl = getElevatorDoorSceneUrl(stationId, 3);
	        applyLessonSceneForSegment({ floor, sceneUrl, styleIndex: 0 });
	        return;
	      }

	      const pages = getCurrentStationPages();
	      const plan = buildLessonElevatorPlanForPages(stationId, pages);
	      state.lessonElevatorPlan = plan;
	      state.lessonElevatorSegmentByPage = plan ? plan.segmentByPage : null;
	      state.lessonElevatorVisitedSegments = new Set([0]);
	      state.lessonElevatorActiveSegment = 0;
	      const seg0 = plan && Array.isArray(plan.segments) ? plan.segments[0] : null;
	      applyLessonSceneForSegment(seg0);
	    }

	    function maybeStartLessonElevatorTransitionForCurrentPage() {
	      if (state.currentScreen !== 'restaurantScreen') return false;
	      if (!state.currentStation) return false;
	      const plan = state.lessonElevatorPlan;
	      const segmentByPage = state.lessonElevatorSegmentByPage;
	      if (!plan || !Array.isArray(plan.segments) || !Array.isArray(segmentByPage)) return false;

	      const segmentIndex = Number(segmentByPage[state.currentPage] || 0);
	      if (segmentIndex <= 0) return false;

	      const visited = state.lessonElevatorVisitedSegments;
	      if (visited && visited.has(segmentIndex)) {
	        state.lessonElevatorActiveSegment = segmentIndex;
	        return false;
	      }

	      const segment = plan.segments[segmentIndex];
	      if (!segment) return false;

	      if (visited) visited.add(segmentIndex);
	      else state.lessonElevatorVisitedSegments = new Set([0, segmentIndex]);

	      state.lessonElevatorActiveSegment = segmentIndex;

	      startElevatorAutoTrip({
	        targetFloor: segment.floor,
	        title: `Floor ${toVisualFloor(segment.floor)}`,
	        mode: 'quick',
	        styleIndex: segment.styleIndex,
	        doorSceneUrl: segment.sceneUrl,
	        afterDoorMs: 3200,
	        onArrive: () => {
	          applyLessonSceneForSegment(segment);
	          goToScreen('restaurantScreen');
	          showPage();
	        },
	      });
	      return true;
	    }

	
	    // ===== WORD WARM-UP =====
	    let warmupWordsHeard = new Set();

    function showWarmup() {
      const station = stationContent[state.currentStation];
      if (!station || !station.previewWords) {
        // No preview words, skip to destination
        goToScreen('elevatorScreen');
        showElevatorAtFloor(2, { openDoors: true });
        setTimeout(() => {
          if (state.currentScreen === 'elevatorScreen') selectFloor(3);
        }, 650);
        return;
      }

      // Reset warmup state
      warmupWordsHeard = new Set();

      // Update UI
      const warmupIconEl = document.getElementById('warmupIcon');
      if (warmupIconEl) warmupIconEl.textContent = '';

      // Show phonics focus if this station has a digraph focus
      const phonicsFocusBox = document.getElementById('phonicsFocusBox');
      if (station.digraphFocus) {
        phonicsFocusBox.style.display = 'flex';
        document.getElementById('phonicsPattern').textContent = station.digraphFocus.toUpperCase();

        // Set appropriate example based on digraph
        const digraphExamples = {
          'sh': 'Makes the sh sound. Like ship.',
          'ch': 'Makes the ch sound. Like chip.',
          'th': 'Makes the th sound. Like this.'
        };
        document.getElementById('phonicsExample').textContent =
          digraphExamples[station.digraphFocus] || 'is a special sound!';
      } else {
        phonicsFocusBox.style.display = 'none';
      }

      // Show sight word reminder if there are sight words in preview
      const sightWordReminder = document.getElementById('sightWordReminder');
      const hasSightWords = station.previewWords.some(w => w.isSightWord);
      sightWordReminder.style.display = hasSightWords ? 'flex' : 'none';

      // Build word cards
      const wordsContainer = document.getElementById('warmupWords');
      wordsContainer.innerHTML = '';

      station.previewWords.forEach((wordData, index) => {
        const card = document.createElement('div');
        card.className = 'warmup-word-card';

        // Add sight word indicator
        if (wordData.isSightWord) {
          card.classList.add('sight-word');
        }

        // Add digraph indicator
        if (wordData.hasDigraph) {
          card.classList.add('has-digraph');
        }

        card.dataset.word = wordData.word;
        card.dataset.index = index;

        // Highlight digraph in word if applicable
        let displayWord = wordData.word;
        if (wordData.hasDigraph && station.digraphFocus) {
          const digraph = station.digraphFocus;
          displayWord = wordData.word.replace(
            new RegExp(digraph, 'gi'),
            `<span class="digraph-highlight">${digraph.toUpperCase()}</span>`
          );
        }

        card.innerHTML = `
	          <div class="warmup-word-text">${displayWord}</div>
	        `;
        card.onclick = () => tapWarmupWord(wordData.word, index);
        wordsContainer.appendChild(card);
      });

      // Reset progress
      document.getElementById('warmupProgressBar').style.width = '0%';
      // Warm-up is optional; keep the CTA visible immediately to avoid layout jumps.
      document.getElementById('warmupContinueBtn').style.display = 'flex';

      goToScreen('warmupScreen');
      // Educational note: We don't auto-play audio - let child initiate interaction

      // No delayed reveal (prevents sudden UI reflow).
    }

    function tapWarmupWord(word, index) {
      // Initialize audio context on user interaction (required for iOS)
      unlockAudioContext();

      const station = stationContent[state.currentStation];
      const totalWords = station.previewWords.length;
      const wordData = station.previewWords[index];

      // For CVC words with phonicsNote, do sound blending (educational feature)
      // This teaches phonemic awareness - crucial for early reading
      if (wordData.phonicsNote && wordData.phonicsNote.includes('CVC')) {
        // Sound out the word slowly first, then blend
        speakWithBlending(word);
      } else {
        // Regular word - just speak it
        speak(word, 0.9); // Slightly slower for clarity
      }

      // Mark as heard
      warmupWordsHeard.add(index);

      // Update card style
      const cards = document.querySelectorAll('.warmup-word-card');
      cards[index].classList.add('heard');

      // Update progress bar
      const progress = (warmupWordsHeard.size / totalWords) * 100;
      document.getElementById('warmupProgressBar').style.width = `${progress}%`;

      // Continue button is already shown on a timer - no need to wait for all words
      // Users can practice as much or as little as they want!
    }

    // Sound blending for CVC words - speaks each sound then blends
    // This is a core Orton-Gillingham/Science of Reading technique
    async function speakWithBlending(word) {
      // For short CVC words, we speak the whole word clearly
      // The phonics note in the data provides the breakdown
      await speak(word, 0.85); // Speak slowly and clearly
    }

    function finishWarmup() {
      // Go back to elevator and automatically go to floor 3
      goToScreen('elevatorScreen');
      setTimeout(() => {
        showElevatorAtFloor(2, { openDoors: true });
        setTimeout(() => {
          if (state.currentScreen === 'elevatorScreen') selectFloor(3);
        }, 650);
      }, 250);
    }

    // ===== STATION ASSETS (Ghibli-style) =====
    // Large hero images for restaurant screens
    const stationImages = {
      // Red Line (Level 1)
      fruit: 'assets/food_fruit.jpeg',
      drink: 'assets/food_drink.jpeg',
      bakery: 'assets/food_bakery.png',
      redbean: 'assets/food_bakery.png', // Reuse bakery for now
      // Blue Line (Level 2)
      pizza: 'assets/food_pizza.jpeg',
      bubbletea: 'assets/food_drink.jpeg', // Reuse drink for now
      burger: 'assets/food_pizza.jpeg', // Reuse pizza for now
      icecream: 'assets/food_icecream.png',
      // Green Line (Level 3)
      fishshop: 'assets/food_fishshop.png',
      sushi: 'assets/food_fishshop.png', // Reuse fish for now
      cheese: 'assets/food_cheese.png',
      chicken: 'assets/food_cheese.png', // Reuse cheese for now
      // Orange Line (Level 4)
      noodle: 'assets/food_noodle.png',
      smoothie: 'assets/food_drink.jpeg', // Reuse drink for now
      teahouse: 'assets/food_noodle.png', // Reuse noodle for now
      practice: 'assets/mascot.png'
    };

    // Small SVG icons for buttons
    const stationIcons = {
      fruit: 'assets/icon_fruit.svg',
      drink: 'assets/icon_drink.svg',
      bakery: 'assets/icon_bakery.svg',
      redbean: 'assets/icon_bakery.svg',
      pizza: 'assets/icon_pizza.svg',
      bubbletea: 'assets/icon_drink.svg',
      burger: 'assets/icon_pizza.svg',
      icecream: 'assets/icon_icecream.svg',
      fishshop: 'assets/icon_fish.svg',
      sushi: 'assets/icon_fish.svg',
      cheese: 'assets/icon_cheese.svg',
      chicken: 'assets/icon_cheese.svg',
      noodle: 'assets/icon_noodle.svg',
      smoothie: 'assets/icon_drink.svg',
      teahouse: 'assets/icon_noodle.svg'
    };

    // ===== IMAGE PRELOADING =====
    // Preload state management
    const imagePreloadState = {
      loaded: new Set(),
      loading: new Set(),
      failed: new Set(),
      allReady: false
    };

    // Preload a single image and track its state
    function preloadImage(src) {
      // Skip if already loaded or loading
      if (imagePreloadState.loaded.has(src) || imagePreloadState.loading.has(src)) {
        return Promise.resolve(src);
      }

      imagePreloadState.loading.add(src);

      return new Promise((resolve, reject) => {
        const img = new Image();

        img.onload = () => {
          imagePreloadState.loading.delete(src);
          imagePreloadState.loaded.add(src);
          console.log(`Preloaded image: ${src}`);
          resolve(src);
        };

        img.onerror = () => {
          imagePreloadState.loading.delete(src);
          imagePreloadState.failed.add(src);
          console.warn(`Failed to preload image: ${src}`);
          reject(new Error(`Failed to load ${src}`));
        };

        img.src = src;
      });
    }

    // Preload all station assets
    async function preloadAllStationAssets() {
      console.log('Starting image preload...');

      const allImages = [
        'assets/mascot.png',
        'assets/train.png',
        'assets/elevator_scenes/lobby.jpg',
        ...Object.values(stationImages),
        ...Object.values(stationIcons)
      ];

      // Preload all images in parallel
      const preloadPromises = allImages.map(src =>
        preloadImage(src).catch(err => {
          // Log error but don't stop other images from loading
          console.warn(`Image preload error for ${src}:`, err);
        })
      );

      try {
        await Promise.all(preloadPromises);
        imagePreloadState.allReady = true;
        console.log(`Image preload complete: ${imagePreloadState.loaded.size} loaded, ${imagePreloadState.failed.size} failed`);
      } catch (err) {
        console.warn('Some images failed to preload, but continuing:', err);
        imagePreloadState.allReady = true;
      }
    }

    // ===== RESTAURANT =====
	    function showRestaurant() {
	      const station = stationContent[state.currentStation];

	      document.getElementById('restaurantName').textContent = station.name;
	      resetLessonElevatorFlowForStation(state.currentStation);

	      goToScreen('restaurantScreen');
	      showPage();
	    }

    // Cute MRT train SVG icon for progress bar
    function getTrainSVG(lineColor) {
      return `<svg viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">
        <rect x="4" y="6" width="24" height="18" rx="4" fill="${lineColor}"/>
        <rect x="6" y="8" width="8" height="6" rx="1" fill="#E3F2FD"/>
        <rect x="18" y="8" width="8" height="6" rx="1" fill="#E3F2FD"/>
        <rect x="8" y="16" width="16" height="3" rx="1" fill="white" opacity="0.3"/>
        <circle cx="10" cy="26" r="2.5" fill="#455A64"/>
        <circle cx="22" cy="26" r="2.5" fill="#455A64"/>
        <rect x="7" y="23" width="18" height="2" fill="#78909C"/>
        <circle cx="16" cy="4" r="2" fill="#FFC107"/>
        <circle cx="9" cy="10" r="1" fill="#263238"/>
        <circle cx="14" cy="10" r="1" fill="#263238"/>
        <path d="M8 12 Q11.5 14 15 12" stroke="#263238" stroke-width="0.8" fill="none"/>
      </svg>`;
    }

    function updateMRTProgressBar() {
      const progressBar = document.getElementById('mrtLessonProgress');
      const progressTrack = document.getElementById('mrtProgressTrack');
      const progressStationName = document.getElementById('progressStationName');
      const progressLineBadge = document.getElementById('progressLineBadge');
      const mobileMiniLine = document.getElementById('mobileMiniLine');
      const mobileBadge = document.getElementById('mobileBadge');
      const mobileStationName = document.getElementById('mobileStationName');
      const mobileCount = document.getElementById('mobileCount');

      if (!progressBar || !progressTrack) return;

      const pages = getCurrentStationPages();
      if (!pages || pages.length === 0) {
        progressBar.style.display = 'none';
        return;
      }

      const station = stationContent[state.currentStation];
      if (!station) return;

      // Line info mapping with colors for train SVG
      const lineInfo = {
        1: { class: 'line-red', name: 'Red', fullName: 'Red Line', color: '#E3002C' },
        2: { class: 'line-blue', name: 'Blue', fullName: 'Blue Line', color: '#0070BD' },
        3: { class: 'line-green', name: 'Green', fullName: 'Green Line', color: '#008659' },
        4: { class: 'line-orange', name: 'Orange', fullName: 'Orange Line', color: '#F8B61C' }
      };
      const info = lineInfo[station.level] || lineInfo[1];

      // Update progress bar color class
      progressBar.className = 'mrt-progress-bar ' + info.class;

      // Update labels
      if (progressLineBadge) progressLineBadge.textContent = info.fullName;
      if (progressStationName) progressStationName.textContent = station.name;

      const currentPage = state.currentPage;
      const totalPages = pages.length;
      const labels = { 'read': 'Read', 'question': 'Q', 'menu': 'Pick' };

      // === UPDATE MOBILE VIEW ===
      if (mobileMiniLine) {
        mobileMiniLine.innerHTML = '';

        pages.forEach((page, index) => {
          // Add stop
          const stop = document.createElement('div');
          stop.className = 'mrt-progress-mini-stop';

          if (index < currentPage) {
            stop.classList.add('completed');
          } else if (index === currentPage) {
            stop.classList.add('current');
            // Add train to current stop
            const train = document.createElement('div');
            train.className = 'mrt-progress-mini-train';
            train.innerHTML = getTrainSVG(info.color);
            stop.appendChild(train);
          }
          mobileMiniLine.appendChild(stop);

          // Add segment between stops (not after last)
          if (index < pages.length - 1) {
            const segment = document.createElement('div');
            segment.className = 'mrt-progress-mini-segment';
            if (index < currentPage) {
              segment.classList.add('filled');
            }
            mobileMiniLine.appendChild(segment);
          }
        });
      }

      // Update mobile info
      if (mobileBadge) mobileBadge.textContent = info.name;
      if (mobileStationName) mobileStationName.textContent = station.name;
      if (mobileCount) mobileCount.textContent = 'â€¢ ' + (currentPage + 1) + '/' + totalPages;

      // === UPDATE DESKTOP VIEW ===
      progressTrack.innerHTML = '';

      // Add progress fill element
      const progressFill = document.createElement('div');
      progressFill.className = 'mrt-progress-fill';
      progressTrack.appendChild(progressFill);

      // Create stops for each page
      pages.forEach((page, index) => {
        const stop = document.createElement('div');
        stop.className = 'mrt-progress-stop';

        const label = labels[page.type] || (index + 1);
        stop.setAttribute('data-label', label);

        // Mark completed/current
        if (index < currentPage) {
          stop.classList.add('completed');
        } else if (index === currentPage) {
          stop.classList.add('current');
          // Add animated train above current stop
          const train = document.createElement('div');
          train.className = 'mrt-progress-train arriving';
          train.innerHTML = getTrainSVG(info.color);
          stop.appendChild(train);
          // Reset animation after it plays
          setTimeout(() => {
            train.classList.remove('arriving');
          }, 600);
        }

        progressTrack.appendChild(stop);
      });

      // Calculate and set progress fill width
      const progress = currentPage / Math.max(1, pages.length - 1);
      progressFill.style.width = (progress * 100) + '%';

      // Show the progress bar
      progressBar.style.display = 'block';
    }

    // Update the MRT line indicator on lesson cards
    function updateMRTLineIndicator() {
      const indicator = document.getElementById('mrtLineIndicator');
      const lineName = document.getElementById('lineIndicatorName');
      const stopInfo = document.getElementById('lineIndicatorStop');

      if (!indicator) return;

      const station = stationContent[state.currentStation];
      if (!station || station.isPractice) {
        indicator.style.display = 'none';
        return;
      }

      // Line info mapping
      const lineInfo = {
        1: { class: 'line-red', name: 'Red Line', fullName: 'Tamsui-Xinyi' },
        2: { class: 'line-blue', name: 'Blue Line', fullName: 'Bannan' },
        3: { class: 'line-green', name: 'Green Line', fullName: 'Songshan' },
        4: { class: 'line-orange', name: 'Orange Line', fullName: 'Zhonghe' }
      };

      const info = lineInfo[station.level] || lineInfo[1];

      // Update indicator class for correct color
      indicator.className = 'mrt-line-indicator ' + info.class;

      // Update text content
      lineName.textContent = info.name;

      // Get current stop number on this line
      const pages = getCurrentStationPages();
      const currentStop = state.currentPage + 1;
      const totalStops = pages.length;
      stopInfo.textContent = `â€¢ Stop ${currentStop}/${totalStops}`;

      // Show the indicator
      indicator.style.display = 'flex';
    }

    function updateStoryScenePanelForPage(page) {
      const panel = document.getElementById('storyScenePanel');
      const img = document.getElementById('storySceneImage');
      const caption = document.getElementById('storySceneCaption');
      const stationId = String(state.currentStation || '');
      const station = stationId && stationContent ? stationContent[stationId] : null;

      if (!panel || !img) return;

      const isStory = !!(station && station.isStory);
      if (!isStory) {
        panel.style.display = 'none';
        if (caption) caption.style.display = 'none';
        return;
      }

      const src =
        (page && typeof page.sceneImage === 'string' && page.sceneImage.trim())
          ? page.sceneImage.trim()
          : ((stationImages && stationImages[stationId]) || (stationThemes && stationThemes[stationId] && stationThemes[stationId].sceneImage) || '');

      if (!src) {
        panel.style.display = 'none';
        if (caption) caption.style.display = 'none';
        return;
      }

      panel.style.display = 'flex';
      if (img.getAttribute('src') !== src) img.src = src;
      img.alt = (page && typeof page.sceneAlt === 'string' && page.sceneAlt.trim())
        ? page.sceneAlt.trim()
        : `${station.name || 'Story'} scene`;

      const captionText = (page && typeof page.sceneCaption === 'string') ? page.sceneCaption.trim() : '';
      if (caption) {
        caption.textContent = captionText;
        caption.style.display = captionText ? 'block' : 'none';
      }

      // If this page is an ending page, remember it for the reward recap.
      if (state.storySession && state.storySession.stationId === stationId && page && page.endingId) {
        state.storySession.endingId = String(page.endingId);
        state.storySession.endingTitle = page.endingTitle ? String(page.endingTitle) : null;
        state.storySession.endingSummary = page.endingSummary ? String(page.endingSummary) : null;
      }
    }

	    function showPage() {
	      stopGuidanceAudioOnNavigation({ fadeMs: 120 });
	      const pages = getCurrentStationPages();
	      const page = pages[state.currentPage];
	      if (!page) return;

	      // Between passages, ride the elevator to a new floor + new scene.
	      if (maybeStartLessonElevatorTransitionForCurrentPage()) return;

	      // Mobile UX: always start each page at the top (avoids leftover scroll leaving big blank areas).
	      const restaurantScreen = document.getElementById('restaurantScreen');
	      if (restaurantScreen) restaurantScreen.scrollTop = 0;

      // Update MRT lesson progress bar
      updateMRTProgressBar();

      // Update MRT line indicator
      updateMRTLineIndicator();

      // Story scene art (only for pilot story stations)
      updateStoryScenePanelForPage(page);

      // Hide all sections first
      document.getElementById('menuSection').style.display = 'none';
      document.getElementById('questionSection').style.display = 'none';
      document.getElementById('continueBtn').style.display = 'none';

      const readingSection = document.querySelector('.reading-section');

      if (page.type === 'read') {
        readingSection.style.display = 'flex';
        showReadingPage(page);
      } else if (page.type === 'menu') {
        readingSection.style.display = 'none';
        showMenuPage(page);
      } else if (page.type === 'question') {
        readingSection.style.display = 'none';
        showQuestionPage(page);
      }

      if (state.currentScreen === 'restaurantScreen') {
        playLessonGuidanceForPage(page);
      }

      // Keep the next step snappy: warm audio for the current page + the next page.
      preloadUpcomingLessonAudio({ pages, currentIndex: state.currentPage });
    }

	    function showReadingPage(page) {
      const sentenceImageEl = document.getElementById('sentenceImage');
      if (sentenceImageEl) {
        sentenceImageEl.textContent = '';
        sentenceImageEl.style.display = 'none';
      }

      // Get station's sight words for highlighting
      const station = stationContent[state.currentStation];
      const stationSightWords = station.sightWords || [];
      const focusSightWord = page.sightWordFocus || null;

      // Create clickable words
      const display = document.getElementById('sentenceDisplay');
      display.innerHTML = '';

      let foundFocusInSentence = false;
      const wordList = Array.isArray(page.words) ? page.words : splitSentenceIntoWords(page.sentence || '');
      wordList.forEach((word, index) => {
        const wordSpan = document.createElement('span');
        wordSpan.className = 'word';

        // Clean word for comparison (remove punctuation)
        const cleanWord = word.replace(/[.,!?"]/g, '');

        // Check if this is a sight word
        const isSightWord = stationSightWords.includes(cleanWord) ||
          stationSightWords.includes(cleanWord.toLowerCase());

        // Check if this is the focus sight word for this page
        const isFocusWord = focusSightWord &&
          (cleanWord.toLowerCase() === focusSightWord.toLowerCase());

        // Add sight word styling
        if (isFocusWord) {
          wordSpan.classList.add('sight-word', 'focus-word');
          foundFocusInSentence = true;
        } else if (isSightWord) {
          if (state.sightWordMarksEnabled) wordSpan.classList.add('sight-word');
        }

        // Check if this is a digraph teaching word
        if (page.teachWord && cleanWord.toLowerCase() === page.teachWord.word.toLowerCase()) {
          wordSpan.classList.add('digraph-word');
          wordSpan.setAttribute('data-digraph', page.teachWord.sound.toUpperCase());
        }

        wordSpan.textContent = word;
        wordSpan.onclick = () => tapWord(word, wordSpan);
        display.appendChild(wordSpan);
      });

      // Show/hide reading tip based on page content
      const readingTipBox = document.getElementById('readingTipBox');
      const tipBtn = document.getElementById('tipBtn');
      const readingTipTextEl = document.getElementById('readingTipText');

      const helpParts = [];
      if (page.readingTip) helpParts.push(page.readingTip);

      if (focusSightWord) {
        const cleaned = String(focusSightWord || '').replace(/[^A-Za-z']/g, '');
        const chars = cleaned.split('').filter(Boolean);
        const spellLine = chars.length ? `Spell it. ${chars.map(c => c.toUpperCase()).join(' ')}` : '';
	        const gateLine = (page.requireSightWordTap && state.sightWordGateEnabled && !state.calmMode)
	          ? 'To keep going, tap the sight word one time. You can tap it in the sentence or on the card.'
	          : '';
        helpParts.push(
          [
            `Sight word is ${focusSightWord}.`,
            'Tap it to hear it. Then find it in the sentence.',
            spellLine,
            gateLine
          ].filter(Boolean).join('\n')
        );
      }

      // Only add generic UI help when there's no specific instruction for this page.
      if (helpParts.length === 0) {
        helpParts.push('Tap words to hear them. Use Read to Me for the whole sentence.');
      }
      const helpText = helpParts.filter(Boolean).join('\n\n');

      // Always provide a small, actionable help path for struggling readers.
      tipBtn.style.display = 'flex';
      readingTipBox.style.display = 'none'; // Hide until user clicks Help
      if (readingTipTextEl) readingTipTextEl.textContent = helpText;

      // Show sight word focus box - compact design
      const sightWordFocus = document.getElementById('sightWordFocus');
      const focusChip = document.getElementById('focusSightWord');
      const focusLabel = document.getElementById('sightWordLabel');
      const focusAction = document.getElementById('sightWordAction');

	      // Determine if this is a gated (must tap) situation
	      const shouldGate = !!(focusSightWord && page.requireSightWordTap && state.sightWordGateEnabled && !state.calmMode && foundFocusInSentence);

	      if (focusSightWord) {
	        sightWordFocus.style.display = 'inline-flex';
	        sightWordFocus.classList.toggle('gated', shouldGate);
	        display.querySelectorAll('.word.focus-word').forEach(el => el.classList.toggle('gate-required', shouldGate));

	        if (focusChip) {
	          focusChip.textContent = focusSightWord;
          focusChip.setAttribute('role', 'button');
          focusChip.setAttribute('tabindex', '0');
          focusChip.setAttribute('aria-label', `Tap to hear ${focusSightWord}`);
          focusChip.onclick = () => {
            unlockAudioContext();
            const wordSpeakPromise = speak(focusSightWord, 1.0);
            const wordSpeakToken = ttsRequestToken;
            if (state.requiredSightWord && !state.sightWordGateSatisfied && focusSightWord.toLowerCase() === state.requiredSightWord) {
              const satisfied = satisfySightWordGate();
              if (satisfied) maybeAnnounceSightWordGateSatisfied({ afterSpeakPromise: wordSpeakPromise, afterSpeakToken: wordSpeakToken });
            }
          };
          focusChip.onkeydown = e => {
            if (e.key === 'Enter' || e.key === ' ') {
              e.preventDefault();
              focusChip.click();
            }
          };
	        }

	        // Clear, explicit label/action (avoid â€œTap Tap to continueâ€ ambiguity).
	        if (focusLabel) focusLabel.textContent = 'Sight word';
	        if (focusAction) {
	          focusAction.textContent = shouldGate ? 'Tap one to continue' : 'Tap to hear';
	        }
	      } else {
	        sightWordFocus.style.display = 'none';
	        sightWordFocus.classList.remove('gated');
	        display.querySelectorAll('.word.focus-word').forEach(el => el.classList.remove('gate-required'));
	        if (focusChip) {
	          focusChip.onclick = null;
	          focusChip.onkeydown = null;
	        }
	      }

      // Show continue button
      document.getElementById('continueBtn').style.display = 'flex';
      if (shouldGate) {
        armSightWordGate(focusSightWord);
      } else {
        clearSightWordGate();
      }

      // Educational note: We don't auto-read - let the user tap "Read to Me" when ready
      // This promotes active engagement and prevents audio overwhelm (important for autism)
    }

    // Show reading tip when Help button is clicked
    function showReadingTip() {
      const readingTipBox = document.getElementById('readingTipBox');
      const isVisible = readingTipBox.style.display === 'flex';
      readingTipBox.style.display = isVisible ? 'none' : 'flex';
    }

	    function tapWord(word, element) {
      // Initialize audio context on user interaction (required for iOS)
      unlockAudioContext();

	      // Clean word for speech (remove punctuation)
	      const cleanWord = word.replace(/[.,!?]/g, '');
	      const wordSpeakPromise = speak(cleanWord, 1.0);
	      const wordSpeakToken = ttsRequestToken;

      // Visual feedback
      element.classList.add('tap-heard');
      setTimeout(() => element.classList.remove('tap-heard'), 500);

      // Track word exposure
      state.masteredWords.add(cleanWord.toLowerCase());
      updateProgress();

	      // Soft gate: require tapping the focus sight word (when present) to unlock Next
	      if (state.requiredSightWord && !state.sightWordGateSatisfied) {
	        const normalized = cleanWord.replace(/["]/g, '').toLowerCase();
	        if (normalized === state.requiredSightWord) {
	          const satisfied = satisfySightWordGate();
	          if (satisfied) maybeAnnounceSightWordGateSatisfied({ afterSpeakPromise: wordSpeakPromise, afterSpeakToken: wordSpeakToken });
	        }
	      }
	    }

    let sentenceHighlightRafId = null;
    let sentenceHighlightToken = 0;

    // Passage highlight tracking (for reading comprehension passages)
    let passageHighlightRafId = null;
    let passageHighlightToken = 0;

    function cancelPassageHighlight(wordElements) {
      passageHighlightToken++;
      if (passageHighlightRafId !== null) {
        cancelAnimationFrame(passageHighlightRafId);
        passageHighlightRafId = null;
      }
      if (wordElements && wordElements.length) {
        wordElements.forEach(el => el.classList.remove('highlighted'));
      }
      return passageHighlightToken;
    }

    async function playFullPassage(passageText) {
      unlockAudioContext();

      const passageBody = document.getElementById('passageText');
      if (!passageBody) return;

      const allWordElements = Array.from(passageBody.querySelectorAll('.passage-word'));
      if (allWordElements.length === 0) return;

      logCloudEvent('read_passage', {
        wordCount: allWordElements.length,
      });

      const playbackToken = cancelPassageHighlight(allWordElements);
      const segments = String(passageText || '')
        .split('\n')
        .map(s => s.trim())
        .filter(Boolean);

      const playSegment = async (segmentText, wordElements) => {
        if (playbackToken !== passageHighlightToken) return false;
        if (!segmentText || wordElements.length === 0) return true;

        const result = await speak(segmentText, 1.0, { analyze: true });
        if (playbackToken !== passageHighlightToken) return false;
        if (!result || !result.duration) return true;

        const wordTexts = wordElements.map(el => (el.textContent || '').trim());

        const normalizeTokenForCompare = tokenText =>
          String(tokenText || '')
            .toLowerCase()
            .replace(/^[""']+|[""']+$/g, '')
            .replace(/[^a-z0-9']/g, '');

        const ttsWordTimings = result.wordTimings;
        let useTtsTimings =
          ttsWordTimings &&
          Array.isArray(ttsWordTimings.startMs) &&
          ttsWordTimings.startMs.length === wordTexts.length;

        if (useTtsTimings && Array.isArray(ttsWordTimings.words) && ttsWordTimings.words.length === wordTexts.length) {
          let mismatches = 0;
          for (let i = 0; i < wordTexts.length; i++) {
            if (normalizeTokenForCompare(ttsWordTimings.words[i]) !== normalizeTokenForCompare(wordTexts[i])) {
              mismatches++;
            }
          }
          const mismatchLimit = Math.max(2, Math.floor(wordTexts.length * 0.25));
          if (mismatches > mismatchLimit) useTtsTimings = false;
        }

        const durationMs = result.duration;
        let boundariesMs;

        if (useTtsTimings) {
          const offsetMs = Number.isFinite(result.timingOffsetMs) ? result.timingOffsetMs : 0;
          boundariesMs = new Array(wordTexts.length + 1);
          let last = 0;
          for (let i = 0; i < wordTexts.length; i++) {
            const raw = ttsWordTimings.startMs[i];
            let ms = (Number.isFinite(raw) ? raw : last) + offsetMs;
            ms = Math.max(0, Math.min(ms, durationMs));
            if (ms < last) ms = last;
            boundariesMs[i] = ms;
            last = ms;
          }
          boundariesMs[wordTexts.length] = durationMs;
        } else {
          // Fallback: estimate word boundaries based on word lengths
          boundariesMs = computeWordBoundariesMs(wordTexts, durationMs, {
            includePunctuationWeight: true,
            silenceMidpointsMs: result.silenceMidpointsMs || []
          });
        }

        let currentWordIndex = -1;
        let lastHighlightedIndex = -1;

        const setHighlightedIndex = index => {
          if (index === lastHighlightedIndex) return;
          if (lastHighlightedIndex >= 0 && wordElements[lastHighlightedIndex]) {
            wordElements[lastHighlightedIndex].classList.remove('highlighted');
          }
          if (index >= 0 && wordElements[index]) {
            wordElements[index].classList.add('highlighted');
          }
          lastHighlightedIndex = index;
        };

        let resolved = false;
        let resolveEnd = null;
        let tokenWatchId = null;
        const endPromise = new Promise(resolve => { resolveEnd = resolve; });

        const stop = () => {
          if (resolved) return;
          resolved = true;
          if (tokenWatchId !== null) {
            clearInterval(tokenWatchId);
            tokenWatchId = null;
          }
          if (passageHighlightRafId !== null) {
            cancelAnimationFrame(passageHighlightRafId);
            passageHighlightRafId = null;
          }
          setHighlightedIndex(-1);
          if (typeof resolveEnd === 'function') resolveEnd();
        };

        if (result.source) {
          result.source.onended = stop;
        }
        if (result.audioEl) {
          result.audioEl.onended = stop;
        }

        const updateHighlightForAudioElapsedMs = audioElapsedMs => {
          if (playbackToken !== passageHighlightToken) {
            stop();
            return false;
          }
          if (audioElapsedMs < 0) {
            setHighlightedIndex(-1);
            return true;
          }
          if (audioElapsedMs >= durationMs) {
            stop();
            return false;
          }
          while (currentWordIndex + 1 < wordElements.length && boundariesMs[currentWordIndex + 1] < audioElapsedMs) {
            currentWordIndex++;
          }
          setHighlightedIndex(currentWordIndex);
          return true;
        };

        tokenWatchId = setInterval(() => {
          if (playbackToken !== passageHighlightToken) stop();
        }, 120);

        if (Number.isFinite(result.outputStartPerfMs)) {
          const tickPerf = () => {
            if (!updateHighlightForAudioElapsedMs(performance.now() - result.outputStartPerfMs)) return;
            passageHighlightRafId = requestAnimationFrame(tickPerf);
          };
          passageHighlightRafId = requestAnimationFrame(tickPerf);
        } else if (result.ctx && typeof result.startTime === 'number') {
          const latencySec = typeof result.outputLatencySec === 'number' ? result.outputLatencySec : 0;
          const tick = () => {
            if (!updateHighlightForAudioElapsedMs((result.ctx.currentTime - result.startTime - latencySec) * 1000)) return;
            passageHighlightRafId = requestAnimationFrame(tick);
          };
          passageHighlightRafId = requestAnimationFrame(tick);
        } else if (result.audioEl) {
          const tickAudioEl = () => {
            if (!updateHighlightForAudioElapsedMs((result.audioEl.currentTime || 0) * 1000)) return;
            passageHighlightRafId = requestAnimationFrame(tickAudioEl);
          };
          passageHighlightRafId = requestAnimationFrame(tickAudioEl);
        } else {
          // Fallback wall-clock timing
          const startedAtMs = performance.now();
          const tickFallback = () => {
            if (!updateHighlightForAudioElapsedMs(performance.now() - startedAtMs)) return;
            passageHighlightRafId = requestAnimationFrame(tickFallback);
          };
          passageHighlightRafId = requestAnimationFrame(tickFallback);
        }

        // If we can't attach an end event, resolve after the estimated duration.
        setTimeout(() => {
          if (playbackToken !== passageHighlightToken) stop();
          else if (!resolved) stop();
        }, Math.max(300, durationMs + 220));

        await endPromise;
        return playbackToken === passageHighlightToken;
      };

      if (segments.length <= 1) {
        await playSegment(String(passageText || ''), allWordElements);
        return;
      }

      let cursor = 0;
      for (const segmentText of segments) {
        if (playbackToken !== passageHighlightToken) return;
        const expectedCount = splitSentenceIntoWords(segmentText).length;
        const remaining = allWordElements.length - cursor;
        const take = Math.max(0, Math.min(expectedCount, remaining));
        if (take <= 0) continue;
        const segmentWordElements = allWordElements.slice(cursor, cursor + take);
        cursor += take;
        const ok = await playSegment(segmentText, segmentWordElements);
        if (!ok) return;
        if (cursor >= allWordElements.length) break;
      }
    }

    function computeWordBoundariesMs(wordTexts, durationMs, options = {}) {
      const silenceMidpointsMs = Array.isArray(options.silenceMidpointsMs) ? options.silenceMidpointsMs : [];
      const includePunctuationWeight = options.includePunctuationWeight !== false;
      const wordCount = wordTexts.length;
      const boundaries = new Array(wordCount + 1);
      boundaries[0] = 0;
      boundaries[wordCount] = Math.max(0, durationMs);

      if (wordCount <= 1 || durationMs <= 0) {
        return boundaries;
      }

      const weights = wordTexts.map(text => {
        const raw = (text || '').trim();
        const core = raw.replace(/^[â€œ"']+|[â€"']+$/g, '');
        const letters = core.replace(/[^A-Za-z']/g, '');
        const baseLen = Math.max(1, letters.length || core.replace(/[^A-Za-z0-9']/g, '').length || 1);
        const vowelGroups = (letters.toLowerCase().match(/[aeiouy]+/g) || []).length || 1;

        let weight = 2 + baseLen + vowelGroups;

        if (includePunctuationWeight) {
          if (/\.\.\.$/.test(core) || /â€¦$/.test(core)) {
            weight += 10;
          } else if (/[.?!]$/.test(core)) {
            weight += 8;
          } else if (/[,;:]$/.test(core)) {
            weight += 4;
          }
        }

        return weight;
      });

      const totalWeight = weights.reduce((sum, w) => sum + w, 0) || wordCount;
      let acc = 0;
      for (let i = 0; i < wordCount; i++) {
        boundaries[i] = (acc / totalWeight) * durationMs;
        acc += weights[i];
      }
      boundaries[wordCount] = durationMs;

      if (!Array.isArray(silenceMidpointsMs) || silenceMidpointsMs.length === 0) {
        return boundaries;
      }

      const adjusted = boundaries.slice();
      const candidates = silenceMidpointsMs.filter(t => Number.isFinite(t)).sort((a, b) => a - b);
      const minGapMs = Math.max(60, Math.min(140, durationMs / (wordCount * 2)));
      const searchWindowMs = Math.min(260, Math.max(140, durationMs * 0.12));

      for (let i = 1; i < wordCount; i++) {
        const expected = boundaries[i];
        const earliest = adjusted[i - 1] + minGapMs;
        const latest = durationMs - (wordCount - i) * minGapMs;

        if (earliest >= latest) {
          adjusted[i] = Math.min(Math.max(expected, earliest), latest);
          continue;
        }

        let best = null;
        let bestDist = Infinity;
        for (const t of candidates) {
          if (t < earliest) continue;
          if (t > latest) break;

          const dist = Math.abs(t - expected);
          if (dist <= searchWindowMs && dist < bestDist) {
            best = t;
            bestDist = dist;
          }
        }

        adjusted[i] = best !== null ? best : Math.min(Math.max(expected, earliest), latest);
      }

      adjusted[wordCount] = durationMs;
      return adjusted;
    }

    function cancelSentenceHighlight(wordElements) {
      sentenceHighlightToken++;
      if (sentenceHighlightRafId !== null) {
        cancelAnimationFrame(sentenceHighlightRafId);
        sentenceHighlightRafId = null;
      }
      if (wordElements && wordElements.length) {
        wordElements.forEach(el => el.classList.remove('highlighted'));
      }
      return sentenceHighlightToken;
    }

    async function playFullSentence() {
      // Initialize audio context on user interaction (required for iOS)
      unlockAudioContext();

      const page = getCurrentPage();
      if (!page) return;

      const wordElements = Array.from(document.querySelectorAll('.sentence-display .word'));
      if (wordElements.length === 0) return;

      const buildSentenceFromWordElements = elements => {
        const tokens = elements.map(el => (el.textContent || '').trim()).filter(Boolean);
        if (tokens.length === 0) return '';
        let text = tokens.join(' ');
        text = text.replace(/\s+([.,!?;:])/g, '$1');
        text = text.replace(/([â€œ"'])\s+/g, '$1');
        return text.trim();
      };

      const sentenceText =
        (typeof page.sentence === 'string' && page.sentence.trim())
          ? page.sentence.trim()
          : buildSentenceFromWordElements(wordElements);

      if (!sentenceText) return;

      logCloudEvent('read_sentence', {
        wordCount: wordElements.length,
      });

      const token = cancelSentenceHighlight(wordElements);

      const result = await speak(sentenceText, 1.0, { analyze: true });
      if (token !== sentenceHighlightToken) return;
      if (!result || !result.duration) return;

      const wordTexts = wordElements.map(el => (el.textContent || '').trim());

      // If the TTS backend provides word-level timestamps, use them for near-perfect sync.
      // (Fallback below remains for cases where timestamps are missing/mismatched.)
      const normalizeTokenForCompare = tokenText =>
        String(tokenText || '')
          .toLowerCase()
          .replace(/^[â€œ"']+|[â€"']+$/g, '')
          .replace(/[^a-z0-9']/g, '');

      const ttsWordTimings = result.wordTimings;
      let useTtsTimings =
        ttsWordTimings &&
        Array.isArray(ttsWordTimings.startMs) &&
        ttsWordTimings.startMs.length === wordTexts.length;

      if (useTtsTimings && Array.isArray(ttsWordTimings.words) && ttsWordTimings.words.length === wordTexts.length) {
        let mismatches = 0;
        for (let i = 0; i < wordTexts.length; i++) {
          if (normalizeTokenForCompare(ttsWordTimings.words[i]) !== normalizeTokenForCompare(wordTexts[i])) {
            mismatches++;
          }
        }
        const mismatchLimit = Math.max(2, Math.floor(wordTexts.length * 0.25));
        if (mismatches > mismatchLimit) useTtsTimings = false;
      }

      if (useTtsTimings) {
        const durationMs = result.duration;
        const offsetMs = Number.isFinite(result.timingOffsetMs) ? result.timingOffsetMs : 0;
        const boundariesMs = new Array(wordTexts.length + 1);

        let last = 0;
        for (let i = 0; i < wordTexts.length; i++) {
          const raw = ttsWordTimings.startMs[i];
          let ms = (Number.isFinite(raw) ? raw : last) + offsetMs;
          ms = Math.max(0, Math.min(ms, durationMs));
          if (ms < last) ms = last;
          boundariesMs[i] = ms;
          last = ms;
        }
        boundariesMs[wordTexts.length] = durationMs;

        let currentWordIndex = -1;
        let lastHighlightedIndex = -1;

        const setHighlightedIndex = index => {
          if (index === lastHighlightedIndex) return;

          if (lastHighlightedIndex >= 0 && wordElements[lastHighlightedIndex]) {
            wordElements[lastHighlightedIndex].classList.remove('highlighted');
          }

          if (index >= 0 && wordElements[index]) {
            wordElements[index].classList.add('highlighted');
          }

          lastHighlightedIndex = index;
        };

        const stop = () => {
          if (token !== sentenceHighlightToken) return;
          sentenceHighlightToken++;

          if (sentenceHighlightRafId !== null) {
            cancelAnimationFrame(sentenceHighlightRafId);
            sentenceHighlightRafId = null;
          }

          setHighlightedIndex(-1);
        };

        if (result.source) {
          result.source.onended = stop;
        }
        if (result.audioEl) {
          result.audioEl.onended = stop;
        }

        const updateHighlightForAudioElapsedMs = audioElapsedMs => {
          if (token !== sentenceHighlightToken) return false;

          if (audioElapsedMs < 0) {
            setHighlightedIndex(-1);
            return true;
          }

          if (audioElapsedMs >= durationMs) {
            stop();
            return false;
          }

          while (currentWordIndex + 1 < wordElements.length && boundariesMs[currentWordIndex + 1] < audioElapsedMs) {
            currentWordIndex++;
          }
          setHighlightedIndex(currentWordIndex);
          return true;
        };

        if (Number.isFinite(result.outputStartPerfMs)) {
          const tickPerf = () => {
            if (!updateHighlightForAudioElapsedMs(performance.now() - result.outputStartPerfMs)) return;
            sentenceHighlightRafId = requestAnimationFrame(tickPerf);
          };
          sentenceHighlightRafId = requestAnimationFrame(tickPerf);
          return;
        }

        if (result.ctx && typeof result.startTime === 'number') {
          const latencySec = typeof result.outputLatencySec === 'number' ? result.outputLatencySec : 0;
          const tick = () => {
            if (!updateHighlightForAudioElapsedMs((result.ctx.currentTime - result.startTime - latencySec) * 1000)) return;
            sentenceHighlightRafId = requestAnimationFrame(tick);
          };
          sentenceHighlightRafId = requestAnimationFrame(tick);
          return;
        }

        if (result.audioEl) {
          const tickAudioEl = () => {
            if (!updateHighlightForAudioElapsedMs((result.audioEl.currentTime || 0) * 1000)) return;
            sentenceHighlightRafId = requestAnimationFrame(tickAudioEl);
          };
          sentenceHighlightRafId = requestAnimationFrame(tickAudioEl);
          return;
        }

        const startedAtMs = performance.now();
        const tickFallback = () => {
          if (!updateHighlightForAudioElapsedMs(performance.now() - startedAtMs)) return;
          sentenceHighlightRafId = requestAnimationFrame(tickFallback);
        };
        sentenceHighlightRafId = requestAnimationFrame(tickFallback);
        return;
      }

      const punctuationBreakWordIndices = [];
      for (let i = 0; i < wordTexts.length - 1; i++) {
        const tokenText = wordTexts[i] || '';
        if (/[.?!][â€"']?$/.test(tokenText)) {
          punctuationBreakWordIndices.push(i);
        }
      }
      const leadingSilenceMs = result.leadingSilenceMs || 0;
      const trailingSilenceMs = result.trailingSilenceMs || 0;
      const audioHighlightDurationMs = Math.max(0, result.duration - leadingSilenceMs - trailingSilenceMs);

      const rawSilenceSegments = Array.isArray(result.silenceSegmentsMs) ? result.silenceSegmentsMs : [];
      const minPauseMs = 40;
      const pauseSegments = rawSilenceSegments
        .map(segment => ({
          startMs: (segment.startMs || 0) - leadingSilenceMs,
          endMs: (segment.endMs || 0) - leadingSilenceMs
        }))
        .filter(segment => Number.isFinite(segment.startMs) && Number.isFinite(segment.endMs))
        .map(segment => ({
          startMs: Math.max(0, segment.startMs),
          endMs: Math.min(audioHighlightDurationMs, segment.endMs)
        }))
        .filter(segment => segment.endMs > segment.startMs)
        .filter(segment => (segment.endMs - segment.startMs) >= minPauseMs)
        .sort((a, b) => a.startMs - b.startMs)
        .reduce((merged, segment) => {
          const last = merged[merged.length - 1];
          if (!last || segment.startMs > last.endMs) {
            merged.push(segment);
            return merged;
          }
          last.endMs = Math.max(last.endMs, segment.endMs);
          return merged;
        }, []);

      const silenceMsBefore = t => {
        if (pauseSegments.length === 0 || t <= 0) return 0;
        let silence = 0;
        for (const segment of pauseSegments) {
          if (t <= segment.startMs) break;
          silence += Math.min(t, segment.endMs) - segment.startMs;
        }
        return silence;
      };

      const pauseSpeechTimes = pauseSegments
        .map(segment => segment.startMs - silenceMsBefore(segment.startMs))
        .filter(t => Number.isFinite(t))
        .sort((a, b) => a - b);

      const pauseTotalMs = pauseSegments.reduce((sum, segment) => sum + (segment.endMs - segment.startMs), 0);
      const speechDurationMs = Math.max(0, audioHighlightDurationMs - pauseTotalMs);

      const includePunctuationWeight = pauseSpeechTimes.length < punctuationBreakWordIndices.length;

      let boundariesMs = computeWordBoundariesMs(wordTexts, speechDurationMs, {
        includePunctuationWeight,
        silenceMidpointsMs: pauseSpeechTimes
      });

      // Snap sentence-break boundaries (., !, ?) to the strongest detected pauses.
      if (punctuationBreakWordIndices.length > 0 && pauseSegments.length > 0 && boundariesMs.length === wordTexts.length + 1) {
        const minGapMs = Math.max(60, Math.min(140, speechDurationMs / (wordTexts.length * 2)));
        const maxSnapDistanceMs = Math.min(700, Math.max(320, speechDurationMs * 0.22));

        const strongPauseTimes = pauseSegments
          .filter(segment => (segment.endMs - segment.startMs) >= 60)
          .map(segment => segment.startMs - silenceMsBefore(segment.startMs))
          .filter(t => Number.isFinite(t))
          .sort((a, b) => a - b);

        if (strongPauseTimes.length > 0) {
          let cursor = 0;
          for (const breakWordIndex of punctuationBreakWordIndices) {
            const boundaryIndex = breakWordIndex + 1;
            if (boundaryIndex <= 0 || boundaryIndex >= boundariesMs.length) continue;

            const expected = boundariesMs[boundaryIndex];
            let bestIdx = -1;
            let bestDist = Infinity;

            for (let i = cursor; i < strongPauseTimes.length; i++) {
              const t = strongPauseTimes[i];
              if (t < expected - maxSnapDistanceMs) continue;
              if (t > expected + maxSnapDistanceMs) break;

              const dist = Math.abs(t - expected);
              if (dist < bestDist) {
                bestDist = dist;
                bestIdx = i;
              }
            }

            if (bestIdx === -1) continue;

            const target = strongPauseTimes[bestIdx];
            const earliest = boundariesMs[boundaryIndex - 1] + minGapMs;
            const latest = boundaryIndex + 1 < boundariesMs.length ? boundariesMs[boundaryIndex + 1] - minGapMs : speechDurationMs;

            if (earliest < latest) {
              boundariesMs[boundaryIndex] = Math.min(Math.max(target, earliest), latest);
              cursor = bestIdx + 1;
            }
          }

          boundariesMs[boundariesMs.length - 1] = speechDurationMs;
        }
      }

      let currentWordIndex = -1;
      let lastHighlightedIndex = -1;

      const setHighlightedIndex = index => {
        if (index === lastHighlightedIndex) return;

        if (lastHighlightedIndex >= 0 && wordElements[lastHighlightedIndex]) {
          wordElements[lastHighlightedIndex].classList.remove('highlighted');
        }

        if (index >= 0 && wordElements[index]) {
          wordElements[index].classList.add('highlighted');
        }

        lastHighlightedIndex = index;
      };

      const stop = () => {
        if (token !== sentenceHighlightToken) return;
        sentenceHighlightToken++;

        if (sentenceHighlightRafId !== null) {
          cancelAnimationFrame(sentenceHighlightRafId);
          sentenceHighlightRafId = null;
        }

        setHighlightedIndex(-1);
      };

      if (result.source) {
        result.source.onended = stop;
      }

      const updateHighlightForAudioElapsedMs = audioElapsedMs => {
        if (token !== sentenceHighlightToken) return false;

        const elapsedMs = audioElapsedMs - leadingSilenceMs;

        if (elapsedMs < 0) {
          setHighlightedIndex(-1);
          return true;
        }

        if (elapsedMs >= audioHighlightDurationMs) {
          stop();
          return false;
        }

        const speechElapsedMs = Math.max(0, elapsedMs - silenceMsBefore(elapsedMs));

        while (currentWordIndex + 1 < wordElements.length && boundariesMs[currentWordIndex + 1] < speechElapsedMs) {
          currentWordIndex++;
        }
        setHighlightedIndex(currentWordIndex);
        return true;
      };

      if (Number.isFinite(result.outputStartPerfMs)) {
        const tickPerf = () => {
          if (!updateHighlightForAudioElapsedMs(performance.now() - result.outputStartPerfMs)) return;
          sentenceHighlightRafId = requestAnimationFrame(tickPerf);
        };
        sentenceHighlightRafId = requestAnimationFrame(tickPerf);
        return;
      }

      if (result.ctx && typeof result.startTime === 'number') {
        const latencySec = typeof result.outputLatencySec === 'number' ? result.outputLatencySec : 0;
        const tick = () => {
          if (!updateHighlightForAudioElapsedMs((result.ctx.currentTime - result.startTime - latencySec) * 1000)) return;
          sentenceHighlightRafId = requestAnimationFrame(tick);
        };
        sentenceHighlightRafId = requestAnimationFrame(tick);
        return;
      }

      if (result.audioEl) {
        const tickAudioEl = () => {
          if (!updateHighlightForAudioElapsedMs((result.audioEl.currentTime || 0) * 1000)) return;
          sentenceHighlightRafId = requestAnimationFrame(tickAudioEl);
        };
        sentenceHighlightRafId = requestAnimationFrame(tickAudioEl);
        return;
      }

      // Last-resort wall-clock timing (e.g., if we fall back to SpeechSynthesis).
      const startedAtMs = performance.now();
      const tickFallback = () => {
        if (!updateHighlightForAudioElapsedMs(performance.now() - startedAtMs)) return;
        sentenceHighlightRafId = requestAnimationFrame(tickFallback);
      };
      sentenceHighlightRafId = requestAnimationFrame(tickFallback);
    }

	    function showMenuPage(page) {
	      document.getElementById('menuSection').style.display = 'block';
	      document.querySelector('.menu-prompt').textContent = page.prompt;
	      clearSightWordGate();

	      // Show menu story if available (adds learning context)
	      const menuStoryEl = document.getElementById('menuStory');
	      if (page.menuStory) {
	        const storyText = String(page.menuStory || '').trim();
	        menuStoryEl.innerHTML = '';

	        const kicker = document.createElement('div');
	        kicker.className = 'menu-story-kicker';
	        kicker.textContent = 'Story Check';
	        menuStoryEl.appendChild(kicker);

	        const subtitle = document.createElement('div');
	        subtitle.className = 'menu-story-subtitle';
	        subtitle.textContent = 'Use details from the story you just read.';
	        menuStoryEl.appendChild(subtitle);

	        const body = document.createElement('div');
	        body.className = 'menu-story-body';

	        // Special-case: "Think about the story: x, y, z." â†’ show as a clear clue list.
	        const thinkMatch = storyText.match(/^Think about the story\s*:\s*(.+)$/i);
	        if (thinkMatch && thinkMatch[1]) {
	          body.textContent = 'Clues from the story:';
	          menuStoryEl.appendChild(body);

	          const raw = String(thinkMatch[1] || '').trim();
	          const parts = raw.split(',').map(s => s.trim()).filter(Boolean);
	          const list = document.createElement('ul');
	          list.className = 'menu-story-list';
	          (parts.length ? parts : [raw]).forEach(part => {
	            const li = document.createElement('li');
	            li.textContent = part;
	            list.appendChild(li);
	          });
	          menuStoryEl.appendChild(list);
	        } else {
	          body.textContent = storyText;
	          menuStoryEl.appendChild(body);
	        }

	        // Add a short quote from the most recent read page (makes the link obvious).
	        try {
	          const pages = getCurrentStationPages();
	          const startIndex = Math.max(0, Number(state.currentPage || 0) - 1);
	          let prevRead = '';
	          for (let i = startIndex; i >= 0; i--) {
	            const p = pages && pages[i];
	            if (p && p.type === 'read') {
	              prevRead = String(p.sentence || '').replace(/\s+/g, ' ').trim();
	              break;
	            }
	          }
	          if (prevRead) {
	            const quote = document.createElement('div');
	            quote.className = 'menu-story-quote';
	            const maxLen = 160;
	            const clipped = prevRead.length > maxLen ? (prevRead.slice(0, maxLen - 1).trimEnd() + 'â€¦') : prevRead;
	            quote.textContent = `You just read: â€œ${clipped}â€`;
	            menuStoryEl.appendChild(quote);
	          }
	        } catch {
	          // Non-fatal: menu still renders without the quote.
	        }

	        menuStoryEl.style.display = 'block';
	      } else {
	        menuStoryEl.style.display = 'none';
	      }

      const grid = document.getElementById('menuGrid');
      grid.innerHTML = '';

	      page.items.forEach(item => {
	        const btn = document.createElement('button');
	        btn.className = 'menu-item';

	        // Add description for extra learning context if available
	        const iconText = item.icon ? `<span class="item-icon">${item.icon}</span>` : '';
	        const descText = item.description ? `<span class="item-desc">${item.description}</span>` : '';

	        btn.innerHTML = `
		          ${iconText}
		          <span class="item-name">${item.name}</span>
		          ${descText}
		        `;
	        btn.onclick = () => selectMenuItem(item, btn);
	        grid.appendChild(btn);
	      });

      // Removed auto-play: speak(page.prompt);
    }

    function selectMenuItem(item, button) {
      const currentPage = getCurrentPage();
      const isStoryChoice = !!(currentPage && currentPage.type === 'menu' && currentPage.storyChoice && item && item._storyNextNodeId);

      // Store the order
      state.currentOrder = isStoryChoice ? null : item;
      recordMenuChoiceAnalytics(state.currentStation, item && item.name ? item.name : null);

      // Visual feedback
      document.querySelectorAll('.menu-item').forEach(btn => {
        btn.classList.remove('selected');
      });
      button.classList.add('selected');

      speak(`You picked ${item.name}!`);

      // Branching story choice: inject the selected branch into session pages.
      if (isStoryChoice) {
        applyStoryChoiceSelection({ page: currentPage, item });
        updateMRTProgressBar();
      }

      // Show continue button
      document.getElementById('continueBtn').style.display = 'flex';
      setContinueEnabled(true);
    }

    // ===== EVIDENCE-BASED ANSWERING & HINT LADDER =====
    // State for current question's learning scaffolds
    let currentQuestionState = {
      evidenceRequired: false,
      evidenceSatisfied: false,
      selectedEvidence: [],
      hintLevel: 0,
      maxHints: 3,
      hintTexts: [],
      keySentenceHighlightVisible: false,
      wrongAttempts: 0,
      page: null
    };

    function resetQuestionState() {
      currentQuestionState = {
        evidenceRequired: false,
        evidenceSatisfied: false,
        selectedEvidence: [],
        hintLevel: 0,
        maxHints: 3,
        hintTexts: [],
        keySentenceHighlightVisible: false,
        wrongAttempts: 0,
        page: null
      };
    }

    function setKeySentenceHighlightVisible(visible) {
      const passageText = document.getElementById('passageText');
      if (!passageText) return;
      const shouldShow = !!visible;
      passageText.querySelectorAll('.passage-sentence[data-key-sentence="1"]').forEach(span => {
        span.classList.toggle('key-sentence', shouldShow);
      });
      currentQuestionState.keySentenceHighlightVisible = shouldShow;
    }

    function revealKeySentenceHighlight() {
      if (currentQuestionState.keySentenceHighlightVisible) return;
      setKeySentenceHighlightVisible(true);
    }

    // Setup evidence-based answering for comprehension questions
    function setupEvidenceBasedAnswering(page, isComprehensionQuestion, displayPassage) {
      const evidencePrompt = document.getElementById('evidencePrompt');
      const hintLadder = document.getElementById('hintLadder');
      const errorExplanation = document.getElementById('errorExplanation');

      // Reset UI elements
      if (evidencePrompt) {
        evidencePrompt.classList.remove('active', 'satisfied');
        const evidenceText = evidencePrompt.querySelector('.evidence-text');
        if (evidenceText) {
          evidenceText.textContent = 'Tip: Tap the words in the story that help answer this question.';
        }
      }
      if (hintLadder) {
        hintLadder.classList.remove('active');
        document.getElementById('hintLevel1').classList.remove('active');
        document.getElementById('hintLevel2').classList.remove('active');
        document.getElementById('hintLevel3').classList.remove('active');
      }
      if (errorExplanation) {
        errorExplanation.classList.remove('active');
      }

      resetQuestionState();
      currentQuestionState.page = page;

      // Only require evidence for comprehension questions with passages
      // Skip for menu recall and fill-in-blank questions
      const isPractice = !!stationContent[state.currentStation]?.isPractice;
      const requireEvidence = !isPractice && isComprehensionQuestion && displayPassage && page.questionType === 'comprehension';

      if (requireEvidence) {
        currentQuestionState.evidenceRequired = true;

        // Show evidence prompt
        if (evidencePrompt) {
          evidencePrompt.classList.add('active');
        }

        // Setup hint texts based on question type
        setupHintLadder(page);
      }
    }

    // Setup 3-level hint ladder
    function setupHintLadder(page) {
      const hintLadder = document.getElementById('hintLadder');
      const hintCounter = document.getElementById('hintCounter');
      const getHintBtn = document.getElementById('getHintBtn');

      // Generate hint texts based on question content
      const hints = [];

      // Level 1: Strategy reminder
      const questionLower = (page.question || '').toLowerCase();
      if (questionLower.includes('where') || questionLower.includes('setting')) {
        hints.push('Strategy. Look for place words like at and in. Look for a place name.');
      } else if (questionLower.includes('who') || questionLower.includes('character')) {
        hints.push('Strategy. Look for names or pronouns like he, she, and they.');
      } else if (questionLower.includes('what happen') || questionLower.includes('sequence')) {
        hints.push('Strategy. Look for time words like first, then, and next.');
      } else if (questionLower.includes('why') || questionLower.includes('because')) {
        hints.push('Strategy. Look for why words like because, so, and since.');
      } else if (questionLower.includes('main idea') || questionLower.includes('mostly about')) {
        hints.push('Strategy. Think about what the whole story is mostly about.');
      } else {
        hints.push('Strategy. Read the story again. The answer is in the words.');
      }

      // Level 2: Point to key sentence
      if (page.comprehensionHint) {
        hints.push('Look here. ' + page.comprehensionHint);
      } else if (page.passage) {
        hints.push('Read the highlighted sentence again. The answer is in that sentence.');
      } else {
        hints.push('The highlighted sentence has your answer. Tap the words you need.');
      }

      // Level 3: Eliminate wrong choice (we'll fill this dynamically on wrong answers)
      hints.push('Try this. One remaining answer is correct. Choose the one that matches the story.');

      currentQuestionState.hintTexts = hints;
      currentQuestionState.maxHints = hints.length;

      // Reset hint UI
      if (hintCounter) {
        hintCounter.textContent = hints.length;
      }
      if (getHintBtn) {
        getHintBtn.disabled = false;
      }

      // Hide all hint levels
      document.getElementById('hintLevel1').classList.remove('active');
      document.getElementById('hintLevel2').classList.remove('active');
      document.getElementById('hintLevel3').classList.remove('active');
      document.getElementById('hintLevel1').textContent = '';
      document.getElementById('hintLevel2').textContent = '';
      document.getElementById('hintLevel3').textContent = '';
    }

    // Show next hint level
    function showNextHint() {
      const hintLadder = document.getElementById('hintLadder');
      const hintCounter = document.getElementById('hintCounter');
      const getHintBtn = document.getElementById('getHintBtn');

      if (currentQuestionState.hintLevel >= currentQuestionState.maxHints) {
        return; // No more hints
      }

      // If the learner asks for help, reveal the key sentence highlight as an additional scaffold.
      if (currentQuestionState.evidenceRequired) {
        revealKeySentenceHighlight();
      }

      currentQuestionState.hintLevel++;
      const level = currentQuestionState.hintLevel;
      const hintText = currentQuestionState.hintTexts[level - 1] || '';

      // Show the hint ladder if not visible
      if (hintLadder && !hintLadder.classList.contains('active')) {
        hintLadder.classList.add('active');
      }

      // Show this hint level
      const hintElement = document.getElementById('hintLevel' + level);
      if (hintElement) {
        hintElement.textContent = hintText;
        hintElement.classList.add('active');
      }

      // Update counter
      const remaining = currentQuestionState.maxHints - level;
      if (hintCounter) {
        hintCounter.textContent = remaining;
      }

      // Disable button if no more hints
      if (remaining <= 0 && getHintBtn) {
        getHintBtn.disabled = true;
      }

      // Speak the hint
      speak(hintText.replace(/[ðŸ’šðŸŸ ðŸ”´]/g, '').trim());

      // Log hint usage
      logCloudEvent('hint_used', {
        hintLevel: level,
        stationId: state.currentStation,
        question: currentQuestionState.page?.question || null
      });
    }

    // Handle evidence word selection
    function handleEvidenceWordClick(wordSpan, word) {
      unlockAudioContext();
      const cleanWord = word.replace(/[.,!?"]/g, '');
      speak(cleanWord, 1.0);

      // Toggle evidence selection
      if (wordSpan.classList.contains('evidence-selected')) {
        wordSpan.classList.remove('evidence-selected');
        currentQuestionState.selectedEvidence = currentQuestionState.selectedEvidence.filter(w => w !== cleanWord.toLowerCase());
      } else {
        wordSpan.classList.add('evidence-selected');
        currentQuestionState.selectedEvidence.push(cleanWord.toLowerCase());
      }

      // Check if enough evidence is selected (at least 2 words)
      if (currentQuestionState.selectedEvidence.length >= 2 && !currentQuestionState.evidenceSatisfied) {
        currentQuestionState.evidenceSatisfied = true;
        // Update evidence prompt
        const evidencePrompt = document.getElementById('evidencePrompt');
        if (evidencePrompt) {
          evidencePrompt.classList.add('satisfied');
          evidencePrompt.querySelector('.evidence-text').textContent = 'Good job finding evidence. Now pick your answer.';
        }

        speak('Good. Now you can answer.');

        // Show hint ladder for support
        const hintLadder = document.getElementById('hintLadder');
        if (hintLadder) {
          hintLadder.classList.add('active');
        }
      }
    }

    // Show instructional error explanation
    function showErrorExplanation(wrongAnswer, correctAnswer, page) {
      const errorExplanation = document.getElementById('errorExplanation');
      const errorText = document.getElementById('errorExplanationText');

      if (!errorExplanation || !errorText) return;

      currentQuestionState.wrongAttempts++;

      // After a wrong attempt, reveal the key sentence highlight for comprehension questions.
      if (currentQuestionState.evidenceRequired) {
        revealKeySentenceHighlight();
      }

      // Generate misconception-specific feedback
      let explanation = '';
      const questionLower = (page.question || '').toLowerCase();

      if (questionLower.includes('where') || questionLower.includes('setting')) {
        explanation = `${wrongAnswer} is not where the story happens. Look for place words in the story.`;
      } else if (questionLower.includes('who') || questionLower.includes('character')) {
        explanation = `${wrongAnswer} is not who the question is asking about. Check the names in the story.`;
      } else if (questionLower.includes('what') && questionLower.includes('pick')) {
        explanation = `Think about what you chose earlier in the story. It was not ${wrongAnswer}.`;
      } else {
        explanation = `${wrongAnswer} is not quite right. Read the highlighted sentence again.`;
      }

      errorText.textContent = explanation;
      errorExplanation.classList.add('active');

      // Auto-hide after 4 seconds
      setTimeout(() => {
        errorExplanation.classList.remove('active');
      }, 4000);

      // After 2 wrong attempts, auto-show a hint
      if (currentQuestionState.wrongAttempts >= 2 && currentQuestionState.hintLevel === 0) {
        showNextHint();
      }
    }

    function showQuestionPage(page) {
      document.getElementById('questionSection').style.display = 'block';
      clearSightWordGate();

      // Show optional passage/story text (used by comprehension + fill-in-the-blank).
      // For sight-word blank questions, show the blanked sentence (not the full story).
      const passageBox = document.getElementById('passageBox');
      const passageText = document.getElementById('passageText');
      const passageReadBtn = document.getElementById('passageReadBtn');

      // Get the KEY sentence (contains the answer) and the FULL passage
      const keySentence = normalizePassageText(page.passage || '');
      const fullPassage = getFullPassageForQuestion();
	      const questionLower = (page.question || '').toLowerCase();
	      const passageLower = (page.passage || '').toLowerCase();
	      const isSightWordQuestion = questionLower.includes('sight word') || passageLower.includes('sight word');
	      const isComprehensionQuestion = page.questionType === 'comprehension' && !isSightWordQuestion;

      const keySentenceHasBlank = /_{2,}/.test(keySentence);
      const questionLooksLikeBlank =
        questionLower.includes('fill in') ||
        questionLower.includes('blank') ||
        questionLower.includes('completes the sentence') ||
        questionLower.includes('completes this sentence');

	      // Also show passage for fill-in-the-blank questions (they have ____ in the key sentence).
	      const isFillInBlank = keySentenceHasBlank || questionLooksLikeBlank;

	      // Some comprehension questions are direct â€œquote recallâ€ (e.g., â€œWhat did I say?â€).
	      // Showing the entire story can hide the key sentence and confuse learners, so for these
	      // questions we prefer the key sentence only.
	      const looksLikeQuoteRecall =
	        (questionLower.includes('what did i say') ||
	          questionLower.includes('what words did i say') ||
	          questionLower.includes('which words did i use') ||
	          questionLower.includes('what words did i use') ||
	          (questionLower.includes('what') && questionLower.includes('words') && questionLower.includes('say')) ||
	          questionLower.includes('good manners'));
	      const shouldPreferKeySentenceOnly =
	        isComprehensionQuestion &&
	        !isFillInBlank &&
	        !!keySentence &&
	        keySentence.length <= 90 &&
	        looksLikeQuoteRecall;

	      // Use the blanked key sentence for fill-in questions; otherwise use the full passage when available.
	      const displayPassage = isFillInBlank
	        ? (keySentence || fullPassage || getMostRecentPassageTextForQuestion())
	        : (shouldPreferKeySentenceOnly
	            ? (keySentence || getMostRecentPassageTextForQuestion())
	            : (fullPassage || keySentence || getMostRecentPassageTextForQuestion()));

      const shouldShowPassage = isComprehensionQuestion || isFillInBlank;

      if (passageBox && passageText && displayPassage && shouldShowPassage) {
        // Render full passage with key sentence highlighted
        passageText.innerHTML = '';

        // Split passage into sentences for highlighting
        const sentences = displayPassage.split(/(?<=[.!?])\s+/);
        const keySentenceNormalized = keySentence.toLowerCase().replace(/[^a-z0-9\s]/g, '').trim();

        sentences.forEach((sentence, sentenceIdx) => {
          // Create a container for each sentence
          const sentenceSpan = document.createElement('span');
          sentenceSpan.className = 'passage-sentence';

          // Check if this sentence matches or contains the key sentence
          const sentenceNormalized = sentence.toLowerCase().replace(/[^a-z0-9\s]/g, '').trim();
          const isKeySentence = keySentenceNormalized && (
            sentenceNormalized.includes(keySentenceNormalized) ||
            keySentenceNormalized.includes(sentenceNormalized)
          );
          if (isKeySentence) {
            sentenceSpan.dataset.keySentence = '1';
            // For comprehension questions, hide the key sentence highlight until the learner needs support.
            if (!isComprehensionQuestion) {
              sentenceSpan.classList.add('key-sentence');
            }
          }

	          // Render each word as clickable
	          const words = splitSentenceIntoWords(sentence);
	          words.forEach((word, wordIdx) => {
	            const wordSpan = document.createElement('span');
	            wordSpan.className = 'passage-word';
            // Add evidence-selectable class for comprehension questions
            if (isComprehensionQuestion) {
              wordSpan.classList.add('evidence-selectable');
            }
            wordSpan.textContent = word;
            wordSpan.onclick = () => {
              if (currentQuestionState.evidenceRequired) {
                handleEvidenceWordClick(wordSpan, word);
              } else {
                unlockAudioContext();
                const cleanWord = word.replace(/[.,!?"]/g, '');
                speak(cleanWord, 1.0);
              }
	            };
	            sentenceSpan.appendChild(wordSpan);
	            // Preserve spaces between words so the passage is readable and searchable.
	            if (wordIdx < words.length - 1) {
	              sentenceSpan.appendChild(document.createTextNode(' '));
	            }
	          });

          passageText.appendChild(sentenceSpan);

          // Add space between sentences
          if (sentenceIdx < sentences.length - 1) {
            passageText.appendChild(document.createTextNode(' '));
          }
        });

        passageBox.style.display = 'block';
        if (passageReadBtn) {
          passageReadBtn.style.display = state.soundEnabled ? 'inline-flex' : 'none';
          passageReadBtn.textContent = !!stationContent[state.currentStation]?.isPractice ? 'Read' : 'Read All';
          passageReadBtn.onclick = () => {
            playFullPassage(displayPassage);
          };
        }

        const passageTitleEl = passageBox.querySelector('.passage-title');
        if (passageTitleEl) {
          const isPractice = !!stationContent[state.currentStation]?.isPractice;
          if (isPractice) {
            const normalized = String(displayPassage || '').trim().toLowerCase();
            if (normalized.startsWith('word')) passageTitleEl.textContent = 'Word';
            else if (normalized.startsWith('letter')) passageTitleEl.textContent = 'Letter';
            else passageTitleEl.textContent = 'Clue';
          } else {
            passageTitleEl.textContent = 'The Story So Far';
          }
        }
      } else if (passageBox) {
        passageBox.style.display = 'none';
        if (passageReadBtn) passageReadBtn.onclick = null;
      }

      // Setup evidence-based answering and hint ladder
      setupEvidenceBasedAnswering(page, isComprehensionQuestion, displayPassage);
      if (currentQuestionState.evidenceRequired) {
        // Attempt 1: do not highlight the key sentence (keeps the question from being â€œtoo easyâ€).
        setKeySentenceHighlightVisible(false);
      }

      // Set question text - use the page's question
      document.getElementById('questionText').textContent = page.question;

      // Show comprehension hint if available
      const hintElement = document.getElementById('questionHint');
      if (hintElement && page.comprehensionHint) {
        hintElement.textContent = page.comprehensionHint;
        // Hide by default; reveal after a wrong attempt so the learner tries first.
        hintElement.style.display = 'none';
      } else if (hintElement) {
        hintElement.style.display = 'none';
      }

      // Show bonus phonics question for digraph stations
      const bonusQuestion = document.getElementById('bonusQuestion');
      if (page.bonusQuestion) {
        bonusQuestion.style.display = 'flex';
        document.getElementById('bonusQuestionText').textContent = page.bonusQuestion;
      } else {
        bonusQuestion.style.display = 'none';
      }

      // Hide success feedback initially
      document.getElementById('successFeedback').style.display = 'none';

      const grid = document.getElementById('answerGrid');
      grid.innerHTML = '';

      const station = stationContent[state.currentStation];

      // Question sources:
      // - menu recall (default): answers come from the station menu items
      // - multiple choice: answers come from page.answers (story-detail questions)
      const isMultipleChoice = page.questionMode === 'multipleChoice' || Array.isArray(page.answers);

      let answerItems = [];
      let correctAnswerName = '';
      let feedbackContext = 'choice';

      if (isMultipleChoice) {
        answerItems = [...(page.answers || [])];
        correctAnswerName = page.correctAnswerName || '';
        feedbackContext = 'story';
      } else {
        const menuPage = getCurrentStationPages().find(p => p && p.type === 'menu');
        answerItems = menuPage && Array.isArray(menuPage.items) ? [...menuPage.items] : [];
        correctAnswerName = (state.currentOrder && state.currentOrder.name) ? state.currentOrder.name : '';
      }

      // Shuffle all items for random order
      const allItems = [...answerItems];
      for (let i = allItems.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [allItems[i], allItems[j]] = [allItems[j], allItems[i]];
      }

      allItems.forEach(answer => {
        const btn = document.createElement('button');
        btn.className = 'answer-btn';

        // Add description for extra learning context if available
        const descText = answer.description ? `<span class="answer-desc">${answer.description}</span>` : '';

        btn.innerHTML = `
          <span class="answer-text">${answer.name}</span>
          ${descText}
        `;
        btn.onclick = () => selectAnswer(answer, btn, answer.name === correctAnswerName, page, correctAnswerName, feedbackContext);
        grid.appendChild(btn);
      });

      // Educational note: We don't auto-play the question - let user read it
    }

    function selectAnswer(answer, button, isCorrect, page, correctAnswerName, feedbackContext) {
      // Disable all buttons temporarily to prevent rapid clicking
      const allButtons = document.querySelectorAll('.answer-btn');
      const isPractice = !!stationContent[state.currentStation]?.isPractice;
      page._answerAttempts = (page._answerAttempts || 0) + 1;
      recordQuestionAnalytics({
        isPractice,
        correct: !!isCorrect,
        attempt: page._answerAttempts,
        page,
        stationId: state.currentStation,
        skillId: isPractice ? state.practiceSkillId : null,
      });
      if (page._answerAttempts === 1) {
        const skillId = resolveSkillIdForAttempt({ isPractice, page, practiceSkillId: state.practiceSkillId });
        const itemId = deriveItemIdForAttempt({ stationId: state.currentStation, pageIndex: state.currentPage, page, skillId });
        const difficulty = Number.isFinite(page.difficulty) ? page.difficulty : (stationContent[state.currentStation]?.level || 1);
        recordMasteryAttempt({
          skillId,
          itemId,
          stationId: state.currentStation,
          correct: !!isCorrect,
          supportUsed: (currentQuestionState && Number.isFinite(currentQuestionState.hintLevel) ? currentQuestionState.hintLevel : 0) > 0,
          difficulty,
        });

        // Story pilot: track 5W comprehension accuracy (first try).
        const station = stationContent[state.currentStation];
        const isStory = !!(station && station.isStory);
        const isComprehension = !!(page && page.questionType === 'comprehension');
        if (!isPractice && isStory && isComprehension) {
          const entry = ensureStoryProgressEntry(state.currentStation);
          entry.compTotal += 1;
          if (isCorrect) entry.compCorrect += 1;
          state.storyProgress = normalizeStoryProgress(state.storyProgress);
        }
      }

      logCloudEvent('question_answered', {
        correct: !!isCorrect,
        attempt: page._answerAttempts,
        answer: (answer && answer.name) ? answer.name : null,
        correctAnswer: correctAnswerName || null,
        question: (page && page.question) ? page.question : null,
        questionType: page && page.questionType ? page.questionType : null,
        questionMode: page && page.questionMode ? page.questionMode : null,
        feedbackContext: feedbackContext || null,
        isPractice: !!isPractice,
        // Learning scaffolds tracking
        hintLevelUsed: currentQuestionState.hintLevel || 0,
        evidenceRequired: currentQuestionState.evidenceRequired || false,
        evidenceSelected: currentQuestionState.selectedEvidence?.length || 0,
      });

      if (isPractice && !page._practiceAttempted) {
        page._practiceAttempted = true;
        if (isCorrect) {
          state.practiceFirstTryCorrect++;
        }
      }

      if (isCorrect) {
        button.classList.add('correct');

        if (isPractice && !page._practiceScored) {
          page._practiceScored = true;
          state.practiceCorrect++;
        }

        // Audio feedback: make sight-word/cloze confirmations fast + specific.
        const isSightWordQuestion = page && page.questionType === 'sightWord';
        const successAudio =
          isSightWordQuestion && typeof page.successMessage === 'string' && page.successMessage.trim()
            ? page.successMessage.trim()
            : null;
        const feedbackMessage = successAudio || getRandomFeedback(true);
        const feedbackRate = isSightWordQuestion ? 1.12 : 1.0;
        speak(feedbackMessage, feedbackRate, { kind: 'feedback' });

        // Disable wrong answers
        allButtons.forEach(btn => {
          if (!btn.classList.contains('correct')) {
            btn.disabled = true;
            btn.style.opacity = '0.5';
          }
        });

        // Show success feedback with educational reinforcement
        const successFeedback = document.getElementById('successFeedback');
        const successText = document.getElementById('successFeedbackText');
        if (page.successMessage) {
          successText.textContent = page.successMessage;
        } else {
          successText.textContent = 'Great job! You remembered what you read!';
        }
        successFeedback.style.display = 'flex';

        // Hide the hint once they get it right (prevents mixed messaging).
        const hintElement = document.getElementById('questionHint');
        if (hintElement) hintElement.style.display = 'none';

        // Show continue after celebration
        setTimeout(() => {
          document.getElementById('continueBtn').style.display = 'flex';
        }, 1000);
      } else {
        // Gentle try-again: keep going without revealing the answer.
        button.classList.add('wrong');
        button.disabled = true;

        // Show instructional error explanation
        showErrorExplanation(answer.name, correctAnswerName, page);

        const hintElement = document.getElementById('questionHint');
        const hasHint = !!(hintElement && hintElement.textContent);
        speak(hasHint ? 'Try again. Use the hint.' : 'Try again. Look back at the passage.');
        nudgeForQuestionSupport();
      }
    }

    function continueStory() {
      if (state.requiredSightWord && !state.sightWordGateSatisfied) {
        nudgeSightWordGate();
        const text =
          guidancePrompts &&
          guidancePrompts.lessons &&
          guidancePrompts.lessons.read &&
          guidancePrompts.lessons.read.sightGateBlocked
            ? guidancePrompts.lessons.read.sightGateBlocked
            : 'Tap the highlighted sight word one time. Then press Next.';
        scheduleGuidancePlayback({
          key: `gate:${state.currentStation || 'station'}:${state.currentPage}:sightWord`,
          text,
          guardScreenId: state.currentScreen,
          delayMs: 0
        });
        return;
      }
      const pages = getCurrentStationPages();
      state.currentPage++;

      if (state.currentPage >= pages.length) {
        // Station complete! Show reward
        showReward();
      } else {
        showPage();
      }
    }

    // ===== REWARDS =====
    function showReward() {
      const station = stationContent[state.currentStation];
      const rewardMessageEl = document.getElementById('rewardMessage');
      const rewardContinueText = document.getElementById('rewardContinueText');
      const storyMetaEl = document.getElementById('rewardStoryMeta');
      const playAgainBtn = document.getElementById('rewardPlayAgainBtn');

      if (storyMetaEl) storyMetaEl.style.display = 'none';
      if (playAgainBtn) playAgainBtn.style.display = 'none';

      // Award sticker
      awardStickerAndPage();

      // Mark station as completed (skip for skill practice)
      if (!station.isPractice) {
        if (!state.completedStations.includes(state.currentStation)) {
          state.completedStations.push(state.currentStation);
          unlockNextStation();
        }
      }

      logCloudEvent('station_completed', {
        stationId: state.currentStation || null,
        stationName: station && station.name ? station.name : null,
        isPractice: !!station.isPractice,
        score: (station.isPractice && state.practiceTotal > 0)
          ? { correct: state.practiceCorrect, total: state.practiceTotal, firstTryCorrect: state.practiceFirstTryCorrect }
          : null,
      });

      const stickerEarnedEl = document.getElementById('stickerEarned');
      if (stickerEarnedEl) {
        if (station.isPractice && state.practiceTotal > 0) {
          stickerEarnedEl.textContent = `Score ${state.practiceCorrect}/${state.practiceTotal}`;
        } else {
          stickerEarnedEl.textContent = 'Sticker +1';
        }
      }

      if (station.isPractice && state.practiceTotal > 0) {
        if (rewardMessageEl) {
          rewardMessageEl.textContent = `${station.name} complete! Score: ${state.practiceCorrect}/${state.practiceTotal} (first try: ${state.practiceFirstTryCorrect}/${state.practiceTotal})`;
        }
        if (rewardContinueText) rewardContinueText.textContent = 'More Skills';
      } else {
        if (rewardMessageEl) rewardMessageEl.textContent = `You finished ${station.name}!`;

        const isStory = !!station.isStory;
        if (isStory && state.storySession && state.storySession.stationId === state.currentStation) {
          const session = state.storySession;
          const entry = ensureStoryProgressEntry(state.currentStation);

          if (session.endingId) {
            const endingId = String(session.endingId);
            if (!entry.endingsUnlocked.includes(endingId)) entry.endingsUnlocked.push(endingId);
            entry.endingsUnlocked = Array.from(new Set(entry.endingsUnlocked));
          }
          state.storyProgress = normalizeStoryProgress(state.storyProgress);

          const endingTitle = session.endingTitle ? String(session.endingTitle) : 'Adventure Complete';
          const endingSummary = session.endingSummary ? String(session.endingSummary) : '';

          let endingsTotal = 0;
          try {
            const graph = getFoodStoryGraph(state.currentStation);
            if (graph && graph.nodes) {
              const ids = new Set();
              Object.values(graph.nodes).forEach(n => {
                if (n && n.endingId) ids.add(String(n.endingId));
              });
              endingsTotal = ids.size;
            }
          } catch (e) { endingsTotal = 0; }

          const endingsFound = (entry.endingsUnlocked || []).length;
          const compPct = entry.compTotal > 0 ? Math.round((entry.compCorrect / Math.max(1, entry.compTotal)) * 100) : null;

          if (storyMetaEl) {
            const parts = [];
            parts.push(`Ending unlocked: ${endingTitle}`);
            if (endingSummary) parts.push(endingSummary);
            if (endingsTotal > 0) parts.push(`Endings found: ${endingsFound}/${endingsTotal}`);
            if (compPct !== null) parts.push(`Story Check accuracy: ${compPct}%`);
            storyMetaEl.textContent = parts.join('\n');
            storyMetaEl.style.display = 'block';
          }

          if (rewardContinueText) rewardContinueText.textContent = 'Back to Map';
          if (playAgainBtn) playAgainBtn.style.display = 'block';
        } else {
          if (rewardContinueText) rewardContinueText.textContent = 'Keep Going!';
        }
      }

      updateProgress();
      goToScreen('rewardScreen');

      if (!state.calmMode) {
        // Removed auto-play: speak('Great job! You got a sticker!');
      }
    }

	    function playReturnRideToHub(options = {}) {
	      const durationMs = Number.isFinite(options.durationMs) ? options.durationMs : 5200;
	      const destinationLabel = typeof options.destinationLabel === 'string' ? options.destinationLabel : 'Central Hub';

	      const rideScreen = document.getElementById('mrtRideScreen');
	      const destinationNameEl = document.getElementById('destinationName');
	      const rideIconEl = document.getElementById('rideIcon');

	      if (destinationNameEl) destinationNameEl.textContent = destinationLabel;
	      if (rideIconEl) rideIconEl.textContent = '';

	      if (rideScreen) rideScreen.classList.add('returning');
	      goToScreen('mrtRideScreen');
	      restartRideSceneAnimations({ direction: 'return' });

	      return new Promise(resolve => {
	        setTimeout(resolve, Math.max(800, durationMs));
	      });
	    }

	    async function returnToMapAfterStationCompletion() {
	      cancelElevatorAutoFlow();

	      if (state.stationTransitionTimeoutId) {
	        clearTimeout(state.stationTransitionTimeoutId);
	        state.stationTransitionTimeoutId = null;
	      }

	      // 1) Elevator back down to the lobby (Floor 1).
	      if (state.currentFloor !== 1) {
	        await new Promise(resolve => {
	          startElevatorAutoTrip({
	            targetFloor: 1,
	            title: 'Back to Lobby',
	            mode: 'quick',
	            doorSceneUrl: elevatorDoorScenes.lobby || null,
	            afterDoorMs: 1100,
	            onArrive: resolve,
	          });
	        });
	      } else {
	        goToScreen('elevatorScreen');
	        showElevatorAtFloor(1, { openDoors: true });
	        await new Promise(resolve => setTimeout(resolve, 700));
	      }

	      // 2) Train ride back (right â†’ left), returning to the hub.
	      await playReturnRideToHub();

	      // 3) Reset the session state and show the map, with the train parked at the hub.
	      state.currentStation = null;
	      state.currentOrder = null;
	      state.currentPage = 0;
	      state.currentFloor = 1;
	      state.sessionPages = null;
	      state.lessonElevatorPlan = null;
	      state.lessonElevatorSegmentByPage = null;
	      state.lessonElevatorVisitedSegments = null;
	      state.lessonElevatorActiveSegment = 0;

	      state.mapTrainStation = 'hub';
	      state.mapTrainAtHub = true;

	      // Ensure map interactions are unlocked and visuals are clean.
	      clearStationTransitionState();
	      generateMRTMap();
	      saveProgress();
	      goToScreen('mrtScreen');
	    }

	    async function finishReward() {
	      const btn = document.getElementById('rewardContinueBtn');
	      if (btn) btn.disabled = true;

	      try {
	        // Reset floor
	        if (state.currentStation === 'practice') {
	          state.currentFloor = 1;
	          state.currentStation = null;
	          state.sessionPages = null;
	          state.practiceSkillId = null;
	          state.practiceCorrect = 0;
	          state.practiceFirstTryCorrect = 0;
	          state.practiceTotal = 0;
	          renderSkillsScreen();
	          goToScreen('skillsScreen');
	          return;
	        }

	        await returnToMapAfterStationCompletion();
	      } finally {
	        if (btn) btn.disabled = false;
	      }
	    }

	    function replayStoryFromReward() {
	      const stationId = String(state.currentStation || '');
	      const station = stationId && stationContent ? stationContent[stationId] : null;
	      if (!station || !station.isStory) return;

	      // Restart the story immediately (skip the return trip to the hub).
	      beginStorySessionIfNeeded(stationId);
	      state.currentPage = 0;
	      state.currentOrder = null;
	      state.sessionPages = buildSessionPagesForStation(stationId);
	      saveProgress();
	      goToScreen('restaurantScreen');
	      showPage();
	    }

    // ===== PROGRESS =====
    function ensureProgressCountersState() {
      const existing = state.progressCounters && typeof state.progressCounters === 'object' ? state.progressCounters : null;
      const stickersByDevice = normalizeDeviceCounterBucket(existing && existing.stickersByDevice);
      const pagesByDevice = normalizeDeviceCounterBucket(existing && existing.pagesCompletedByDevice);

      if (!Number.isFinite(stickersByDevice.legacy)) stickersByDevice.legacy = 0;
      if (!Number.isFinite(pagesByDevice.legacy)) pagesByDevice.legacy = 0;

      state.progressCounters = { stickersByDevice, pagesCompletedByDevice: pagesByDevice };
      return state.progressCounters;
    }

    function recalcProgressCountersTotals() {
      const counters = ensureProgressCountersState();
      state.stickers = sumDeviceCounterBucket(counters.stickersByDevice);
      state.pagesCompleted = sumDeviceCounterBucket(counters.pagesCompletedByDevice);
    }

    function awardStickerAndPage() {
      const counters = ensureProgressCountersState();
      const deviceId = (state.deviceId && typeof state.deviceId === 'string') ? state.deviceId : 'device';
      counters.stickersByDevice[deviceId] = (counters.stickersByDevice[deviceId] || 0) + 1;
      counters.pagesCompletedByDevice[deviceId] = (counters.pagesCompletedByDevice[deviceId] || 0) + 1;
      recalcProgressCountersTotals();
    }

    function resetProgressCounters() {
      state.progressCounters = { stickersByDevice: { legacy: 0 }, pagesCompletedByDevice: { legacy: 0 } };
      recalcProgressCountersTotals();
    }

    function updateProgress(options = {}) {
      // Update sticker count
      document.getElementById('stickerCount').textContent = state.stickers;

      // Update progress bar (based on stations completed)
      const totalStations = Object.keys(stationContent).filter(id => !stationContent[id].isPractice && !stationContent[id].comingSoon).length;
      const progress = (state.completedStations.length / totalStations) * 100;
      document.getElementById('progressFill').style.width = `${progress}%`;

      // Update settings modal
      document.getElementById('pagesCompleted').textContent = state.pagesCompleted;
      document.getElementById('wordsMastered').textContent = state.masteredWords.size;
      document.getElementById('stationsCompleted').textContent = state.completedStations.length;

      if (options && options.save === false) return;

      // Save to localStorage
      saveProgress(options && options.saveOptions ? options.saveOptions : {});
    }

    async function resetProgress() {
      const ok = await showConfirmModal({
        title: 'Reset all progress?',
        message: 'This cannot be undone.',
        confirmText: 'Reset',
        cancelText: 'Cancel',
        danger: true,
      });
      if (ok) {
        const key = getProgressStorageKey();
        try { localStorage.removeItem(key); } catch (e) { }
        resetProgressCounters();
        state.completedStations = [];
        state.masteredWords = new Set();
        state.analytics = normalizeAnalyticsData(null);
        state.progressResetAt = getSyncNowMs();
        logCloudEvent('progress_reset', { storageKey: key });
        updateProgress({ save: true });
        generateMRTMap();
        closeSettings();
        goToScreen('welcomeScreen');
      }
    }

    function saveProgress(options = {}) {
      const storageKey = options.storageKey || getProgressStorageKey();
      const now = getSyncNowMs();
      const updatedAt = Number.isFinite(options.forceUpdatedAt) ? options.forceUpdatedAt : now;
      const resetAt = Number.isFinite(options.forceResetAt) ? options.forceResetAt : (state.progressResetAt || 0);
      recalcProgressCountersTotals();
      const counters = ensureProgressCountersState();

      const saveData = {
        counters,
        stickers: state.stickers,
        pagesCompleted: state.pagesCompleted,
        completedStations: state.completedStations,
        masteredWords: Array.from(state.masteredWords),
        storyProgress: normalizeStoryProgress(state.storyProgress),
        soundEnabled: state.soundEnabled,
        guidanceEnabled: state.guidanceEnabled,
        calmMode: state.calmMode,
        sightWordMarksEnabled: state.sightWordMarksEnabled,
        sightWordGateEnabled: state.sightWordGateEnabled,
        updatedAt,
        resetAt,
        lastPosition: {
          stationId: state.currentStation || null,
          pageIndex: Number.isFinite(state.currentPage) ? state.currentPage : 0,
        },
        analytics: normalizeAnalyticsData(state.analytics),
      };
      try {
        localStorage.setItem(storageKey, JSON.stringify(saveData));
      } catch (e) {
        // Some mobile browsers (e.g., iOS private mode) can throw on localStorage writes.
        console.warn('Failed to save local progress', e);
      }

      state.progressUpdatedAt = updatedAt;
      state.progressResetAt = resetAt;

      if (state.cloud && state.cloud.activeChildId) {
        const childIndex = state.cloud.children.findIndex(c => c.id === state.cloud.activeChildId);
        if (childIndex >= 0) {
          state.cloud.children[childIndex].progress = saveData;
        }
        if (state.cloud.activeChild) {
          state.cloud.activeChild.progress = saveData;
        }
      }

      if (!options.skipCloud) scheduleCloudSave('progress');
    }

    function loadProgress(options = {}) {
      const storageKey = options.storageKey || getProgressStorageKey();

      // Child profiles: if the child key is missing but the legacy key exists, copy it once.
      if (storageKey.startsWith(CLOUD_PROGRESS_CHILD_PREFIX)) {
        try {
          const alreadyMigrated = localStorage.getItem(CLOUD_LEGACY_PROGRESS_MIGRATED_KEY) === '1';
          const existing = localStorage.getItem(storageKey);
          const legacy = localStorage.getItem(LEGACY_PROGRESS_KEY);
          if (!alreadyMigrated && !existing && legacy) {
            localStorage.setItem(storageKey, legacy);
            localStorage.setItem(CLOUD_LEGACY_PROGRESS_MIGRATED_KEY, '1');
          }
        } catch (e) {
          // ignore
        }
      }

      let saved = null;
      try { saved = localStorage.getItem(storageKey); } catch (e) { saved = null; }
      if (saved) {
        const data = safeJsonParse(saved, null);
        if (!data) {
          try { localStorage.removeItem(storageKey); } catch (e) { }
          saved = null;
        }
      }

      if (saved) {
        const data = safeJsonParse(saved, {});
        const p = normalizeProgressData(data);
        state.progressCounters = p.counters || { stickersByDevice: { legacy: 0 }, pagesCompletedByDevice: { legacy: 0 } };
        state.stickers = p.stickers;
        state.pagesCompleted = p.pagesCompleted;
        state.completedStations = p.completedStations;
        state.masteredWords = new Set(p.masteredWords);
        state.soundEnabled = p.soundEnabled;
        state.guidanceEnabled = p.guidanceEnabled;
        state.calmMode = p.calmMode;
        state.sightWordMarksEnabled = p.sightWordMarksEnabled;
        state.sightWordGateEnabled = p.sightWordGateEnabled;
        state.progressUpdatedAt = p.updatedAt;
        state.progressResetAt = p.resetAt;
        state.analytics = normalizeAnalyticsData(p.analytics);
        state.storyProgress = normalizeStoryProgress(p.storyProgress);

        // Restore UI state
        updateProgress({ save: false });
        syncSettingsButtonsToState();
      } else {
        const p = normalizeProgressData(null);
        state.progressCounters = p.counters || { stickersByDevice: { legacy: 0 }, pagesCompletedByDevice: { legacy: 0 } };
        state.stickers = p.stickers;
        state.pagesCompleted = p.pagesCompleted;
        state.completedStations = p.completedStations;
        state.masteredWords = new Set(p.masteredWords);
        state.soundEnabled = p.soundEnabled;
        state.guidanceEnabled = p.guidanceEnabled;
        state.calmMode = p.calmMode;
        state.sightWordMarksEnabled = p.sightWordMarksEnabled;
        state.sightWordGateEnabled = p.sightWordGateEnabled;
        state.progressUpdatedAt = p.updatedAt;
        state.progressResetAt = p.resetAt;
        state.analytics = normalizeAnalyticsData(p.analytics);
        state.storyProgress = normalizeStoryProgress(p.storyProgress);
        updateProgress({ save: false });
        syncSettingsButtonsToState();
      }
    }

    function syncSettingsButtonsToState() {
      document.body.classList.toggle('calm-mode', state.calmMode);

      const soundToggle = document.getElementById('soundToggle');
      if (soundToggle) {
        soundToggle.textContent = 'Audio';
        soundToggle.classList.toggle('active', state.soundEnabled);
      }

      const soundSettingToggle = document.getElementById('soundSettingToggle');
      if (soundSettingToggle) soundSettingToggle.classList.toggle('active', state.soundEnabled);

      const guidanceSettingToggle = document.getElementById('guidanceSettingToggle');
      if (guidanceSettingToggle) guidanceSettingToggle.classList.toggle('active', state.guidanceEnabled);

      const calmToggle = document.getElementById('calmModeToggle');
      if (calmToggle) {
        calmToggle.textContent = 'Calm';
        calmToggle.classList.toggle('active', state.calmMode);
      }

      const calmSettingToggle = document.getElementById('calmSettingToggle');
      if (calmSettingToggle) calmSettingToggle.classList.toggle('active', state.calmMode);

      const marksToggle = document.getElementById('sightWordMarksSettingToggle');
      if (marksToggle) marksToggle.classList.toggle('active', state.sightWordMarksEnabled);

      const gateToggle = document.getElementById('sightWordGateSettingToggle');
      if (gateToggle) gateToggle.classList.toggle('active', state.sightWordGateEnabled);
    }

    // ===== SETTINGS =====
    let confirmModalResolver = null;
    let confirmModalOpen = false;
    let confirmModalLastFocus = null;
    let confirmModalKeyHandlerAttached = false;

    function closeConfirmModal(result) {
      const overlay = document.getElementById('confirmModal');
      if (overlay) overlay.classList.remove('active');
      confirmModalOpen = false;
      const resolver = confirmModalResolver;
      confirmModalResolver = null;

      if (confirmModalLastFocus && typeof confirmModalLastFocus.focus === 'function') {
        try { confirmModalLastFocus.focus(); } catch (e) { }
      }
      confirmModalLastFocus = null;

      if (resolver) resolver(!!result);
    }

    function showConfirmModal({ title, message, confirmText, cancelText, danger = false } = {}) {
      const overlay = document.getElementById('confirmModal');
      const titleEl = document.getElementById('confirmTitle');
      const messageEl = document.getElementById('confirmMessage');
      const okBtn = document.getElementById('confirmOkBtn');
      const cancelBtn = document.getElementById('confirmCancelBtn');
      if (!overlay || !titleEl || !messageEl || !okBtn || !cancelBtn) {
        return Promise.resolve(window.confirm(String(message || title || 'Are you sure?')));
      }

      if (confirmModalOpen) {
        closeConfirmModal(false);
      }

      confirmModalLastFocus = document.activeElement;
      confirmModalOpen = true;

      titleEl.textContent = title || 'Are you sure?';
      messageEl.textContent = message || '';
      okBtn.textContent = confirmText || 'OK';
      cancelBtn.textContent = cancelText || 'Cancel';

      okBtn.classList.toggle('danger', !!danger);
      okBtn.classList.remove('secondary');

      overlay.classList.add('active');

      return new Promise(resolve => {
        confirmModalResolver = resolve;

        setTimeout(() => {
          try { (cancelBtn || okBtn).focus(); } catch (e) { }
        }, 0);

        if (!confirmModalKeyHandlerAttached) {
          confirmModalKeyHandlerAttached = true;
          document.addEventListener('keydown', e => {
            if (!confirmModalOpen) return;
            if (e.key === 'Escape') {
              e.preventDefault();
              closeConfirmModal(false);
            }
          });
        }
      });
    }

    function toggleSetting(setting) {
      if (setting === 'sound') {
        state.soundEnabled = !state.soundEnabled;
        document.getElementById('soundToggle').textContent = 'Audio';
        document.getElementById('soundToggle').classList.toggle('active', state.soundEnabled);
        document.getElementById('soundSettingToggle').classList.toggle('active', state.soundEnabled);
      } else if (setting === 'guidance') {
        state.guidanceEnabled = !state.guidanceEnabled;
        const toggle = document.getElementById('guidanceSettingToggle');
        if (toggle) toggle.classList.toggle('active', state.guidanceEnabled);
      } else if (setting === 'calm') {
        state.calmMode = !state.calmMode;
        document.body.classList.toggle('calm-mode', state.calmMode);
        const calmBtn = document.getElementById('calmModeToggle');
        if (calmBtn) calmBtn.classList.toggle('active', state.calmMode);
        document.getElementById('calmSettingToggle').classList.toggle('active', state.calmMode);
        if (calmBtn) calmBtn.textContent = 'Calm';
      } else if (setting === 'sightWordMarks') {
        state.sightWordMarksEnabled = !state.sightWordMarksEnabled;
        const toggle = document.getElementById('sightWordMarksSettingToggle');
        if (toggle) toggle.classList.toggle('active', state.sightWordMarksEnabled);
        if (state.currentStation) showPage();
      } else if (setting === 'sightWordGate') {
        state.sightWordGateEnabled = !state.sightWordGateEnabled;
        const toggle = document.getElementById('sightWordGateSettingToggle');
        if (toggle) toggle.classList.toggle('active', state.sightWordGateEnabled);
        if (!state.sightWordGateEnabled) clearSightWordGate();
        if (state.currentStation) showPage();
      } else if (setting.startsWith('font-')) {
        const size = setting.replace('font-', '');
        state.fontSize = size;

        // Update body classes
        document.body.classList.remove('text-lg', 'text-xl');
        document.querySelectorAll('.segment-btn').forEach(btn => btn.classList.remove('active'));

        if (size === 'large') {
          document.body.classList.add('text-lg');
          document.getElementById('fontLargeBtn').classList.add('active');
        } else if (size === 'xlarge') {
          document.body.classList.add('text-xl');
          document.getElementById('fontXLargeBtn').classList.add('active');
        } else {
          document.getElementById('fontNormalBtn').classList.add('active');
        }
      } else if (setting === 'contrast') {
        state.highContrast = !state.highContrast;
        document.body.classList.toggle('high-contrast', state.highContrast);
        document.getElementById('contrastSettingToggle').classList.toggle('active', state.highContrast);
      }
      saveProgress();
    }

    const homeTitleBtn = document.getElementById('homeTitleBtn');
    if (homeTitleBtn) homeTitleBtn.onclick = () => goHome();

    const homeBtn = document.getElementById('homeBtn');
    if (homeBtn) homeBtn.onclick = () => goHome();

	    const skillsBtn = document.getElementById('skillsBtn');
	    if (skillsBtn) skillsBtn.onclick = () => {
	      updateSkillsFilterButtons();
	      renderSkillsScreen();
	      goToScreen('skillsScreen');
	    };
	    const skillsFilterAllBtn = document.getElementById('skillsFilterAll');
	    if (skillsFilterAllBtn) skillsFilterAllBtn.onclick = () => setSkillsLevelFilter('all');
	    const skillsFilter1Btn = document.getElementById('skillsFilter1');
	    if (skillsFilter1Btn) skillsFilter1Btn.onclick = () => setSkillsLevelFilter(1);
	    const skillsFilter2Btn = document.getElementById('skillsFilter2');
	    if (skillsFilter2Btn) skillsFilter2Btn.onclick = () => setSkillsLevelFilter(2);
	    const skillsFilter3Btn = document.getElementById('skillsFilter3');
	    if (skillsFilter3Btn) skillsFilter3Btn.onclick = () => setSkillsLevelFilter(3);
	    const skillsFilter4Btn = document.getElementById('skillsFilter4');
	    if (skillsFilter4Btn) skillsFilter4Btn.onclick = () => setSkillsLevelFilter(4);

	    const sightWordSkipBtn = document.getElementById('sightWordSkipBtn');
	    if (sightWordSkipBtn) sightWordSkipBtn.onclick = () => skipSightWordGate();
    const soundToggle = document.getElementById('soundToggle');
    if (soundToggle) soundToggle.onclick = () => toggleSetting('sound');

    const calmModeToggle = document.getElementById('calmModeToggle');
    if (calmModeToggle) calmModeToggle.onclick = () => toggleSetting('calm');

    const settingsBtn = document.getElementById('settingsBtn');
    if (settingsBtn) settingsBtn.onclick = (e) => {
      if (e && typeof e.stopPropagation === 'function') e.stopPropagation();
      if (e && typeof e.preventDefault === 'function') e.preventDefault();
      document.getElementById('settingsModal').classList.add('active');
    };

    const settingsMapBtn = document.getElementById('settingsMapBtn');
    if (settingsMapBtn) settingsMapBtn.onclick = () => goHome();

	    function closeSettings() {
	      document.getElementById('settingsModal').classList.remove('active');
	    }

	    // Close modal on overlay click
	    const settingsModal = document.getElementById('settingsModal');
	    if (settingsModal) {
	      settingsModal.onclick = (e) => {
	        if (e && e.target && e.target.id === 'settingsModal') {
	          closeSettings();
	        }
	      };
	    }

    // Confirm modal wiring
    const confirmModal = document.getElementById('confirmModal');
    const confirmCancelBtn = document.getElementById('confirmCancelBtn');
    const confirmOkBtn = document.getElementById('confirmOkBtn');
    if (confirmCancelBtn) confirmCancelBtn.onclick = () => closeConfirmModal(false);
    if (confirmOkBtn) confirmOkBtn.onclick = () => closeConfirmModal(true);
    if (confirmModal) {
      confirmModal.onclick = e => {
        if (e.target && e.target.id === 'confirmModal') closeConfirmModal(false);
      };
    }

    // ===== SKILL PRACTICE =====
    function shuffleInPlace(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
      return array;
    }

    function pickOne(array) {
      return array[Math.floor(Math.random() * array.length)];
    }

    function normalizePassageText(text) {
      return (text || '').toString().replace(/\s+/g, ' ').trim();
    }

    function getMostRecentPassageTextForQuestion() {
      const pages = getCurrentStationPages();
      if (!Array.isArray(pages) || pages.length === 0) return '';
      const idx = Number.isFinite(state.currentPage) ? state.currentPage : 0;
      const start = Math.min(idx - 1, pages.length - 1);

      const passages = [];
      const seen = new Set();
      const add = text => {
        const normalized = normalizePassageText(text);
        const key = normalized.toLowerCase();
        if (!normalized || seen.has(key)) return;
        seen.add(key);
        passages.push(normalized);
      };

      for (let i = start; i >= 0; i--) {
        const p = pages[i];
        if (!p || p.type !== 'read') continue;
        if (typeof p.sentence === 'string' && p.sentence.trim()) add(p.sentence);
        else if (Array.isArray(p.words) && p.words.length) add(p.words.join(' '));
        if (passages.length >= 2) break;
      }

      if (passages.length) return passages.reverse().join('\n');

      for (let i = start; i >= 0; i--) {
        const p = pages[i];
        if (!p) continue;
        if (p.type === 'menu' && typeof p.menuStory === 'string' && p.menuStory.trim()) {
          return normalizePassageText(p.menuStory);
        }
      }

      return '';
    }

    // Get the FULL accumulated reading passage for comprehension questions
    // This makes questions more challenging - child must find answer in full context
    function getFullPassageForQuestion() {
      const pages = getCurrentStationPages();
      if (!Array.isArray(pages) || pages.length === 0) return '';
      const idx = Number.isFinite(state.currentPage) ? state.currentPage : 0;

      const passages = [];
      const seen = new Set();
      const add = text => {
        const normalized = normalizePassageText(text);
        const key = normalized.toLowerCase();
        if (!normalized || seen.has(key)) return;
        seen.add(key);
        passages.push(normalized);
      };

      // Collect ALL read pages up to current page (not just 2)
      for (let i = 0; i <= idx; i++) {
        const p = pages[i];
        if (!p || p.type !== 'read') continue;
        if (typeof p.sentence === 'string' && p.sentence.trim()) add(p.sentence);
        else if (Array.isArray(p.words) && p.words.length) add(p.words.join(' '));
      }

      return passages.join('\n');
    }

    function pickDistinct(array, count, exclude = new Set()) {
      const pool = array.filter(x => !exclude.has(x));
      shuffleInPlace(pool);
      return pool.slice(0, count);
    }

    function makeMCQ({ question, passage = null, hint = null, answers, correctAnswerName, successMessage, questionType = 'comprehension' }) {
      return {
        type: 'question',
        questionType,
        questionMode: 'multipleChoice',
        question,
        passage,
        comprehensionHint: hint || '',
        answers: answers.map(name => ({ name, icon: '' })),
        correctAnswerName,
        successMessage: successMessage || 'Great job!'
      };
    }

    const skillWordBanks = {
      vowels: ['a', 'e', 'i', 'o', 'u'],
      consonants: ['b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'x', 'y', 'z'],

      cvc: [
        'cat', 'dog', 'pig', 'hen', 'bug', 'map', 'sun', 'hop', 'fin', 'cap', 'bed', 'kid', 'log', 'cup', 'bat', 'hat', 'rat',
        'jam', 'pen', 'sit', 'lip', 'rug', 'fox', 'win', 'mud', 'tap', 'mop', 'net', 'hut', 'rib', 'gum', 'jet', 'nut', 'mix',
        'zip', 'fan', 'web', 'red', 'tan', 'vet', 'top', 'pot', 'sip', 'rag', 'pin', 'pan', 'got', 'get', 'fun'
      ],
      cvcc: ['milk', 'hand', 'wind', 'camp', 'best', 'nest', 'lamp', 'desk', 'sock', 'belt'],
      ccvc: ['flag', 'frog', 'step', 'stop', 'plan', 'clip', 'drip', 'crab', 'slam', 'brag', 'skip', 'spot', 'clap', 'grin'],

      twoSyllables: [
        { word: 'pizza', syllables: 2 },
        { word: 'paper', syllables: 2 },
        { word: 'tiger', syllables: 2 },
        { word: 'table', syllables: 2 },
        { word: 'open', syllables: 2 },
        { word: 'robot', syllables: 2 },
        { word: 'music', syllables: 2 },
        { word: 'seven', syllables: 2 },
        { word: 'sunset', syllables: 2 },
        { word: 'lunchbox', syllables: 2 },
        { word: 'pencil', syllables: 2 },
        { word: 'rabbit', syllables: 2 },
        { word: 'apple', syllables: 2 },
        { word: 'monkey', syllables: 2 },
        { word: 'window', syllables: 2 },
        { word: 'pocket', syllables: 2 },
        { word: 'kitten', syllables: 2 },
        { word: 'market', syllables: 2 },
        { word: 'basket', syllables: 2 },
        { word: 'rocket', syllables: 2 },
        { word: 'napkin', syllables: 2 }
      ],
      threeSyllables: [
        { word: 'banana', syllables: 3 },
        { word: 'animal', syllables: 3 },
        { word: 'tomato', syllables: 3 },
        { word: 'elephant', syllables: 3 },
        { word: 'family', syllables: 3 },
        { word: 'octopus', syllables: 3 },
        { word: 'butterfly', syllables: 3 },
        { word: 'computer', syllables: 3 },
        { word: 'tomorrow', syllables: 3 },
        { word: 'remember', syllables: 3 },
        { word: 'strawberry', syllables: 3 }
      ],
      twoSyllableBuild: [
        { a: 'ba', b: 'by', word: 'baby' },
        { a: 'pi', b: 'zza', word: 'pizza' },
        { a: 'pa', b: 'per', word: 'paper' },
        { a: 'ta', b: 'ble', word: 'table' },
        { a: 'ro', b: 'bot', word: 'robot' },
        { a: 'mu', b: 'sic', word: 'music' },
        { a: 'pen', b: 'cil', word: 'pencil' },
        { a: 'rab', b: 'bit', word: 'rabbit' },
        { a: 'ap', b: 'ple', word: 'apple' },
        { a: 'mon', b: 'key', word: 'monkey' },
        { a: 'win', b: 'dow', word: 'window' },
        { a: 'kit', b: 'ten', word: 'kitten' },
        { a: 'mar', b: 'ket', word: 'market' },
        { a: 'bas', b: 'ket', word: 'basket' },
        { a: 'roc', b: 'ket', word: 'rocket' },
        { a: 'nap', b: 'kin', word: 'napkin' }
      ],
      compoundWords: [
        { a: 'sun', b: 'set', word: 'sunset' },
        { a: 'cup', b: 'cake', word: 'cupcake' },
        { a: 'lunch', b: 'box', word: 'lunchbox' },
        { a: 'rain', b: 'bow', word: 'rainbow' },
        { a: 'bed', b: 'room', word: 'bedroom' },
        { a: 'rain', b: 'coat', word: 'raincoat' },
        { a: 'play', b: 'ground', word: 'playground' },
        { a: 'sun', b: 'flower', word: 'sunflower' },
        { a: 'foot', b: 'ball', word: 'football' },
        { a: 'back', b: 'pack', word: 'backpack' },
        { a: 'tooth', b: 'brush', word: 'toothbrush' }
      ],

      rhymes: [
        ['cat', 'hat', 'bat', 'rat'],
        ['pig', 'wig', 'dig'],
        ['sun', 'fun', 'run'],
        ['cap', 'map', 'tap'],
        ['bed', 'red'],
        ['pen', 'hen', 'ten'],
        ['hop', 'mop', 'top'],
        ['rug', 'bug', 'hug'],
        ['fin', 'win', 'pin'],
        ['cup', 'pup'],
        ['cake', 'bake', 'lake'],
        ['shop', 'top', 'mop'],
        ['fish', 'dish', 'wish']
      ],

      digraphs: {
        sh: ['ship', 'shop', 'fish', 'dish', 'shell', 'wish', 'shut', 'shed', 'shop', 'shack', 'rush', 'cash'],
        ch: ['chip', 'chop', 'chin', 'cheese', 'chair', 'chill', 'chat', 'chess', 'much', 'lunch'],
        th: ['this', 'that', 'them', 'thin', 'bath', 'with', 'then', 'than', 'math', 'thick']
      },
      blends: ['st', 'sp', 'sl', 'pl', 'cl', 'fl', 'br', 'cr', 'tr', 'gr'],
      blendWords: {
        st: ['stop', 'step', 'star'],
        sp: ['spin', 'spot', 'spoon'],
        sl: ['slip', 'slam', 'sled'],
        pl: ['plan', 'plug', 'plant'],
        cl: ['clap', 'clip', 'clock'],
        fl: ['flag', 'flip', 'flat'],
        br: ['brag', 'brick', 'brown'],
        cr: ['crab', 'crack', 'crisp'],
        tr: ['trip', 'truck', 'train'],
        gr: ['grin', 'grab', 'green']
      },

      silentE: [
        { short: 'cap', long: 'cape' },
        { short: 'kit', long: 'kite' },
        { short: 'hop', long: 'hope' },
        { short: 'cub', long: 'cube' },
        { short: 'mad', long: 'made' },
        { short: 'hid', long: 'hide' },
        { short: 'tap', long: 'tape' }
      ],
      vowelTeams: {
        ee: ['see', 'tree', 'feet', 'seed', 'green', 'sleep', 'sweet', 'jeep', 'week', 'need', 'keep'],
        ea: ['eat', 'leaf', 'sea', 'meat', 'peach', 'beach', 'seal', 'team', 'seat', 'read', 'clean'],
        ai: ['rain', 'tail', 'mail', 'sail', 'train', 'paint', 'chain', 'wait', 'snail', 'brain'],
        ay: ['day', 'play', 'say', 'stay', 'tray', 'gray', 'clay', 'spray', 'may', 'way'],
        oa: ['boat', 'goat', 'road', 'soap', 'coat', 'toad', 'float', 'loaf', 'oat', 'goal'],
        ow: ['snow', 'grow', 'blow', 'slow', 'flow', 'glow', 'show', 'crow', 'low', 'row']
      },
      rControlled: {
        ar: ['car', 'star', 'park', 'farm', 'yard', 'barn', 'march', 'hard', 'cart', 'part'],
        er: ['her', 'fern', 'term', 'paper', 'germ', 'corner', 'river', 'teacher', 'baker', 'letter'],
        ir: ['bird', 'girl', 'shirt', 'first', 'third', 'stir', 'whirl', 'skirt', 'dirt'],
        or: ['fork', 'corn', 'storm', 'short', 'born', 'horse', 'shore', 'more', 'sort'],
        ur: ['turn', 'fur', 'hurt', 'nurse', 'burn', 'curl', 'surf', 'purse', 'burst']
      },
      diphthongs: {
        oi: ['coin', 'oil', 'boil', 'soil', 'foil', 'join', 'point'],
        oy: ['boy', 'toy', 'joy', 'soy', 'enjoy', 'ploy'],
        ou: ['out', 'loud', 'cloud', 'house', 'mouse', 'shout', 'found'],
        ow: ['cow', 'now', 'brown', 'town', 'down', 'how', 'clown']
      },

      sightWords: ['the', 'and', 'to', 'a', 'I', 'see', 'want', 'can', 'my', 'is', 'you', 'we', 'like', 'have', 'this', 'there', 'they', 'with', 'said', 'come', 'here', 'it'],
      sightWordSentences: [
        { sentence: 'I ____ a dog.', correct: 'see', choices: ['see', 'want', 'have'] },
        { sentence: '____ is my book.', correct: 'This', choices: ['This', 'There', 'You'] },
        { sentence: 'I ____ to eat.', correct: 'want', choices: ['want', 'like', 'have'] },
        { sentence: '____ is a cat.', correct: 'It', choices: ['It', 'My', 'We'] },
        { sentence: 'We ____ here.', correct: 'come', choices: ['come', 'can', 'see'] },
        { sentence: '____ is the door.', correct: 'There', choices: ['There', 'They', 'We'] },
        { sentence: 'I ____ my hat.', correct: 'have', choices: ['have', 'with', 'come'] },
        { sentence: '____ like pizza.', correct: 'I', choices: ['I', 'My', 'There'] },
        { sentence: '____ are my friends.', correct: 'They', choices: ['They', 'The', 'To'] },
        { sentence: 'Come ____.', correct: 'here', choices: ['here', 'there', 'to'] },
        { sentence: 'I can ____.', correct: 'see', choices: ['see', 'my', 'is'] },
        { sentence: '____ is my cup.', correct: 'This', choices: ['This', 'They', 'You'] },
        { sentence: 'I ____ the dog.', correct: 'see', choices: ['see', 'say', 'sip'] },
        { sentence: 'I ____ you.', correct: 'like', choices: ['like', 'lake', 'lick'] },
        { sentence: 'We ____ to play.', correct: 'want', choices: ['want', 'went', 'win'] },
        { sentence: '____ is my mom.', correct: 'This', choices: ['This', 'They', 'We'] },
        { sentence: '____ can help.', correct: 'You', choices: ['You', 'The', 'To'] },
        { sentence: '____ is hot.', correct: 'It', choices: ['It', 'In', 'If'] },
        { sentence: 'I go ____ the park.', correct: 'to', choices: ['to', 'two', 'too'] },
        { sentence: 'The cat is ____.', correct: 'here', choices: ['here', 'have', 'this'] },
        { sentence: 'I like ___ big dog.', correct: 'the', choices: ['the', 'to', 'and'] },
        { sentence: 'We sit ___ read.', correct: 'and', choices: ['and', 'a', 'to'] },
        { sentence: 'I go ___ school.', correct: 'to', choices: ['to', 'two', 'too'] },
        { sentence: 'I see ___ cat.', correct: 'a', choices: ['a', 'an', 'and'] },
        { sentence: 'This is ___ book.', correct: 'my', choices: ['my', 'me', 'mice'] },
        { sentence: 'I ___ read.', correct: 'can', choices: ['can', 'ran', 'car'] },
        { sentence: 'We play ___ Mom.', correct: 'with', choices: ['with', 'wish', 'wet'] },
        { sentence: 'Mom ___ hi.', correct: 'said', choices: ['said', 'sail', 'sad'] }
      ],

      nouns: ['dog', 'cat', 'fish', 'bird', 'pizza', 'shop', 'table', 'teacher', 'park', 'bus', 'box', 'dish', 'book', 'desk', 'pencil', 'hat', 'sock', 'shirt', 'home', 'store', 'train', 'cake', 'kite', 'cup', 'bed'],
      nounTypes: {
        person: ['mom', 'dad', 'teacher', 'doctor', 'friend', 'girl', 'boy'],
        place: ['park', 'school', 'home', 'store', 'beach', 'zoo'],
        animal: ['dog', 'cat', 'fish', 'bird', 'frog', 'duck'],
        thing: ['book', 'desk', 'pencil', 'hat', 'sock', 'cup', 'box', 'kite']
      },
      verbs: ['run', 'jump', 'eat', 'see', 'want', 'help', 'play', 'walk', 'look', 'read', 'write', 'cook', 'draw', 'sing', 'sit', 'stand'],
      adjectives: ['big', 'small', 'hot', 'cold', 'yummy', 'fresh', 'happy', 'sad', 'tiny', 'brave', 'loud', 'quiet', 'fast', 'slow', 'wet', 'dry'],
      adjectiveDegrees: [
        { base: 'fast', comparative: 'faster', superlative: 'fastest' },
        { base: 'small', comparative: 'smaller', superlative: 'smallest' },
        { base: 'tall', comparative: 'taller', superlative: 'tallest' },
        { base: 'long', comparative: 'longer', superlative: 'longest' },
        { base: 'loud', comparative: 'louder', superlative: 'loudest' },
        { base: 'big', comparative: 'bigger', superlative: 'biggest' },
        { base: 'cold', comparative: 'colder', superlative: 'coldest' },
        { base: 'hot', comparative: 'hotter', superlative: 'hottest' },
        { base: 'slow', comparative: 'slower', superlative: 'slowest' },
        { base: 'short', comparative: 'shorter', superlative: 'shortest' }
      ],
      unscrambleSentences: [
        { words: ['I', 'see', 'a', 'cat'], correct: 'I see a cat.', wrong: ['See I a cat.', 'I a see cat.'] },
        { words: ['We', 'ride', 'the', 'train'], correct: 'We ride the train.', wrong: ['Ride we the train.', 'We the ride train.'] },
        { words: ['The', 'dog', 'can', 'run'], correct: 'The dog can run.', wrong: ['Dog the can run.', 'The can dog run.'] },
        { words: ['She', 'has', 'a', 'hat'], correct: 'She has a hat.', wrong: ['Has she a hat.', 'She a has hat.'] },
        { words: ['I', 'like', 'cold', 'milk'], correct: 'I like cold milk.', wrong: ['I cold like milk.', 'Like I cold milk.'] },
        { words: ['They', 'play', 'a', 'game'], correct: 'They play a game.', wrong: ['Play they a game.', 'They a play game.'] },
        { words: ['The', 'fish', 'is', 'wet'], correct: 'The fish is wet.', wrong: ['Fish the is wet.', 'The is fish wet.'] },
        { words: ['I', 'want', 'a', 'cookie'], correct: 'I want a cookie.', wrong: ['Want I a cookie.', 'I a want cookie.'] }
      ],
      prepositions: ['in', 'on', 'under', 'by', 'behind', 'between', 'next to'],

      numberWords: [
        { digit: '1', word: 'one', wrong: ['won', 'on'] },
        { digit: '2', word: 'two', wrong: ['to', 'too'] },
        { digit: '3', word: 'three', wrong: ['tree', 'free'] },
        { digit: '4', word: 'four', wrong: ['for', 'fore'] },
        { digit: '5', word: 'five', wrong: ['fiv', 'fine'] },
        { digit: '6', word: 'six', wrong: ['sicks', 'sip'] },
        { digit: '7', word: 'seven', wrong: ['sevin', 'siren'] },
        { digit: '8', word: 'eight', wrong: ['ate', 'eigt'] },
        { digit: '9', word: 'nine', wrong: ['neen', 'nice'] },
        { digit: '10', word: 'ten', wrong: ['tin', 'teen'] }
      ],

      prefixesUn: [
        { base: 'happy', derived: 'unhappy', meaning: 'not happy', wrong: ['happy', 'happier'] },
        { base: 'kind', derived: 'unkind', meaning: 'not kind', wrong: ['kind', 'kinds'] },
        { base: 'safe', derived: 'unsafe', meaning: 'not safe', wrong: ['safe', 'safest'] },
        { base: 'fair', derived: 'unfair', meaning: 'not fair', wrong: ['fair', 'fairs'] },
        { base: 'lock', derived: 'unlock', meaning: 'open the lock', wrong: ['lock', 'locked'] },
        { base: 'wrap', derived: 'unwrap', meaning: 'take off the wrap', wrong: ['wrap', 'wrapped'] },
        { base: 'tie', derived: 'untie', meaning: 'undo the tie', wrong: ['tie', 'tied'] },
        { base: 'clean', derived: 'unclean', meaning: 'not clean', wrong: ['clean', 'cleaner'] },
        { base: 'even', derived: 'uneven', meaning: 'not even', wrong: ['even', 'evenly'] },
        { base: 'able', derived: 'unable', meaning: 'not able', wrong: ['able', 'ables'] }
      ],

      suffixesFul: [
        { base: 'help', derived: 'helpful', meaning: 'full of help', wrong: ['help', 'helpless'] },
        { base: 'care', derived: 'careful', meaning: 'full of care', wrong: ['care', 'careless'] },
        { base: 'hope', derived: 'hopeful', meaning: 'full of hope', wrong: ['hope', 'hopeless'] },
        { base: 'use', derived: 'useful', meaning: 'full of use', wrong: ['use', 'useless'] },
        { base: 'play', derived: 'playful', meaning: 'full of play', wrong: ['play', 'played'] },
        { base: 'thank', derived: 'thankful', meaning: 'full of thanks', wrong: ['thank', 'thanks'] },
        { base: 'joy', derived: 'joyful', meaning: 'full of joy', wrong: ['joy', 'joyless'] },
        { base: 'wonder', derived: 'wonderful', meaning: 'full of wonder', wrong: ['wonder', 'wonderless'] },
        { base: 'beauty', derived: 'beautiful', meaning: 'full of beauty', wrong: ['beauty', 'beautyless'] },
        { base: 'color', derived: 'colorful', meaning: 'full of color', wrong: ['color', 'colorless'] }
      ],

      properNouns: [
        { question: 'Which word is a name?', correct: 'Sam', wrong: ['boy', 'dog'] },
        { question: 'Which word is a name?', correct: 'Mia', wrong: ['girl', 'cat'] },
        { question: 'Which word is a name?', correct: 'Ben', wrong: ['friend', 'park'] },
        { question: 'Which word should start with a capital letter?', correct: 'Monday', wrong: ['school', 'home'] },
        { question: 'Which word should start with a capital letter?', correct: 'January', wrong: ['winter', 'month'] },
        { question: 'Which word is a name?', correct: 'Ana', wrong: ['teacher', 'school'] },
        { question: 'Which word is a name?', correct: 'Tom', wrong: ['kid', 'chair'] },
        { question: 'Which word should start with a capital letter?', correct: 'Friday', wrong: ['lunch', 'night'] },
        { question: 'Which word should start with a capital letter?', correct: 'March', wrong: ['spring', 'weather'] },
        { question: 'Which word is a name?', correct: 'Max', wrong: ['puppy', 'bone'] }
      ],

      possessiveNouns: [
        { owner: 'girl', thing: 'hat', correct: "girl's", wrong: ['girls', 'girl'] },
        { owner: 'boy', thing: 'bike', correct: "boy's", wrong: ['boys', 'boy'] },
        { owner: 'Mom', thing: 'bag', correct: "Mom's", wrong: ['Moms', 'Mom'] },
        { owner: 'Dad', thing: 'car', correct: "Dad's", wrong: ['Dads', 'Dad'] },
        { owner: 'teacher', thing: 'book', correct: "teacher's", wrong: ['teachers', 'teacher'] },
        { owner: 'dog', thing: 'bone', correct: "dog's", wrong: ['dogs', 'dog'] },
        { owner: 'bird', thing: 'nest', correct: "bird's", wrong: ['birds', 'bird'] },
        { owner: 'friend', thing: 'toy', correct: "friend's", wrong: ['friends', 'friend'] },
        { owner: 'baby', thing: 'bottle', correct: "baby's", wrong: ['babies', 'baby'] },
        { owner: 'cat', thing: 'food', correct: "cat's", wrong: ['cats', 'cat'] }
      ],

      irregularPlurals: [
        { singular: 'child', plural: 'children', wrong: ['childs', 'childes'] },
        { singular: 'man', plural: 'men', wrong: ['mans', 'mens'] },
        { singular: 'woman', plural: 'women', wrong: ['womans', 'womens'] },
        { singular: 'mouse', plural: 'mice', wrong: ['mouses', 'mices'] },
        { singular: 'foot', plural: 'feet', wrong: ['foots', 'feets'] },
        { singular: 'tooth', plural: 'teeth', wrong: ['tooths', 'teeths'] }
      ],

      possessivePronouns: [
        { sentence: 'This is ____ book.', correct: 'my', wrong: ['me', 'I'] },
        { sentence: 'That is ____ hat.', correct: 'his', wrong: ['him', 'he'] },
        { sentence: 'This is ____ doll.', correct: 'her', wrong: ['she', 'hers'] },
        { sentence: 'Look at ____ bike.', correct: 'my', wrong: ['me', 'I'] },
        { sentence: 'We like ____ school.', correct: 'our', wrong: ['us', 'we'] },
        { sentence: 'That is ____ dog.', correct: 'their', wrong: ['they', 'them'] },
        { sentence: 'I see ____ bag.', correct: 'your', wrong: ['you', 'yours'] },
        { sentence: 'Where is ____ pencil?', correct: 'my', wrong: ['me', 'I'] },
        { sentence: 'She lost ____ coat.', correct: 'her', wrong: ['she', 'hers'] },
        { sentence: 'He rides ____ bike.', correct: 'his', wrong: ['him', 'he'] },
        { sentence: 'These are ____ shoes.', correct: 'our', wrong: ['us', 'we'] },
        { sentence: 'Those are ____ toys.', correct: 'their', wrong: ['they', 'them'] }
      ],

      synonyms: [
        { word: 'big', synonym: 'large', wrong: ['hot', 'sad'] },
        { word: 'small', synonym: 'little', wrong: ['cold', 'run'] },
        { word: 'happy', synonym: 'glad', wrong: ['mad', 'wet'] },
        { word: 'tiny', synonym: 'small', wrong: ['loud', 'slow'] },
        { word: 'fast', synonym: 'quick', wrong: ['cold', 'sad'] },
        { word: 'loud', synonym: 'noisy', wrong: ['tiny', 'quiet'] },
        { word: 'sad', synonym: 'unhappy', wrong: ['glad', 'fast'] },
        { word: 'begin', synonym: 'start', wrong: ['stop', 'sleep'] },
        { word: 'smart', synonym: 'clever', wrong: ['tired', 'wet'] },
        { word: 'angry', synonym: 'mad', wrong: ['glad', 'sleepy'] },
        { word: 'funny', synonym: 'silly', wrong: ['quiet', 'cold'] },
        { word: 'wet', synonym: 'damp', wrong: ['dry', 'hot'] },
        { word: 'cold', synonym: 'chilly', wrong: ['sunny', 'loud'] },
        { word: 'help', synonym: 'assist', wrong: ['hide', 'hurt'] }
      ],
      antonyms: [
        { word: 'hot', antonym: 'cold', wrong: ['big', 'fast'] },
        { word: 'up', antonym: 'down', wrong: ['in', 'on'] },
        { word: 'happy', antonym: 'sad', wrong: ['glad', 'smile'] },
        { word: 'quiet', antonym: 'loud', wrong: ['fast', 'tiny'] },
        { word: 'big', antonym: 'small', wrong: ['tall', 'wide'] },
        { word: 'in', antonym: 'out', wrong: ['up', 'over'] },
        { word: 'open', antonym: 'shut', wrong: ['shine', 'splash'] },
        { word: 'first', antonym: 'last', wrong: ['next', 'fast'] },
        { word: 'fast', antonym: 'slow', wrong: ['quick', 'loud'] },
        { word: 'wet', antonym: 'dry', wrong: ['damp', 'cold'] },
        { word: 'day', antonym: 'night', wrong: ['sun', 'light'] },
        { word: 'clean', antonym: 'dirty', wrong: ['tidy', 'shiny'] },
        { word: 'full', antonym: 'empty', wrong: ['big', 'heavy'] },
        { word: 'on', antonym: 'off', wrong: ['up', 'over'] }
      ],
      categories: [
        { category: 'Animals', words: ['dog', 'cat', 'fish'], odd: 'cake' },
        { category: 'Food', words: ['pizza', 'cake', 'rice'], odd: 'shoe' },
        { category: 'Colors', words: ['red', 'blue', 'green'], odd: 'jump' },
        { category: 'School', words: ['book', 'desk', 'pencil'], odd: 'soup' },
        { category: 'Clothes', words: ['hat', 'sock', 'shirt'], odd: 'fish' },
        { category: 'Places', words: ['park', 'home', 'store'], odd: 'jump' },
        { category: 'Weather', words: ['rain', 'snow', 'wind'], odd: 'pizza' },
        { category: 'Actions', words: ['run', 'jump', 'read'], odd: 'blue' },
        { category: 'Kitchen', words: ['cup', 'plate', 'spoon'], odd: 'kite' },
        { category: 'Body Parts', words: ['hand', 'foot', 'nose'], odd: 'rain' },
        { category: 'Toys', words: ['ball', 'kite', 'doll'], odd: 'bread' },
        { category: 'Pets', words: ['dog', 'cat', 'fish'], odd: 'desk' },
        { category: 'Vehicles', words: ['car', 'bus', 'train'], odd: 'leaf' }
      ],

      multipleMeaning: [
        { context: 'I hit the ball with a bat.', correct: 'A sports stick', wrong: ['A flying animal', 'A kind of food'] },
        { context: 'We put jam on toast.', correct: 'Sweet fruit spread', wrong: ['A traffic problem', 'A kind of shoe'] },
        { context: 'The cars are in a jam.', correct: 'A traffic problem', wrong: ['Sweet fruit spread', 'A flying animal'] },
        { context: 'I can put soup in a can.', correct: 'A metal container', wrong: ['To be able to', 'A kind of animal'] },
        { context: 'I can read this word.', correct: 'To be able to', wrong: ['A metal container', 'A kind of food'] },
        { context: 'The duck has a bill.', correct: 'The duck\'s mouth', wrong: ['Money to pay', 'A kind of bed'] },
        { context: 'Mom pays the bill.', correct: 'Money to pay', wrong: ['The duck\'s mouth', 'A kind of fish'] },
        { context: 'The dog can bark.', correct: 'A dog sound', wrong: ['Tree skin', 'A kind of shoe'] },
        { context: 'The bark is rough.', correct: 'Tree skin', wrong: ['A dog sound', 'A kind of soup'] },
        { context: 'The light is bright.', correct: 'Not dark', wrong: ['Not heavy', 'A kind of food'] },
        { context: 'The bag is light.', correct: 'Not heavy', wrong: ['Not dark', 'A kind of bird'] },
        { context: 'I wear a ring.', correct: 'A piece of jewelry', wrong: ['A loud sound', 'A kind of fish'] },
        { context: 'The bell will ring.', correct: 'Make a sound', wrong: ['A piece of jewelry', 'A kind of cookie'] }
      ],
      contextClues: [
        { passage: 'The puppy is tiny. It is very small.', correct: 'very small', wrong: ['very loud', 'very tall'] },
        { passage: 'The soup is steaming. It is very hot.', correct: 'very hot', wrong: ['very cold', 'very quiet'] },
        { passage: 'The room is quiet. No one is talking.', correct: 'not loud', wrong: ['very loud', 'very fast'] },
        { passage: 'The ice is slippery. It is hard to stand.', correct: 'hard to stand on', wrong: ['easy to read', 'very loud'] },
        { passage: 'The cake is sweet. It tastes like sugar.', correct: 'tastes like sugar', wrong: ['tastes like dirt', 'tastes like soap'] },
        { passage: 'The puppy is playful. It runs and jumps.', correct: 'likes to play', wrong: ['likes to sleep', 'likes to hide'] },
        { passage: 'The box is heavy. I need help to lift it.', correct: 'hard to lift', wrong: ['easy to carry', 'very tiny'] },
        { passage: 'The path is narrow. Only one person can walk.', correct: 'not wide', wrong: ['very wide', 'very loud'] },
        { passage: 'The puppy is calm. It sits still.', correct: 'not wild', wrong: ['very loud', 'very fast'] },
        { passage: 'The water is freezing. My hands feel cold.', correct: 'very, very cold', wrong: ['very hot', 'very loud'] },
        { passage: 'The snack is crunchy. It makes a loud sound when I bite.', correct: 'hard and crackly', wrong: ['soft and quiet', 'wet and slippery'] },
        { passage: 'The glass is fragile. It can break easily.', correct: 'can break easily', wrong: ['very strong', 'very loud'] },
        { passage: 'The baby is fussy. The baby cries and cries.', correct: 'hard to please', wrong: ['very sleepy', 'very brave'] }
      ],
      shadesOfMeaning: [
        { question: 'Which word means the MOST happy?', answers: ['glad', 'happy', 'thrilled'], correct: 'thrilled' },
        { question: 'Which word means the MOST cold?', answers: ['cool', 'cold', 'freezing'], correct: 'freezing' },
        { question: 'Which word means the MOST loud?', answers: ['loud', 'noisy', 'deafening'], correct: 'deafening' },
        { question: 'Which word means the MOST hot?', answers: ['warm', 'hot', 'burning'], correct: 'burning' },
        { question: 'Which word means the MOST big?', answers: ['big', 'large', 'huge'], correct: 'huge' }
      ],
      shadesOrder: [
        { prompt: 'Order from least to most happy.', words: ['glad', 'happy', 'thrilled'], correct: ['glad', 'happy', 'thrilled'] },
        { prompt: 'Order from least to most cold.', words: ['cool', 'cold', 'freezing'], correct: ['cool', 'cold', 'freezing'] },
        { prompt: 'Order from least to most loud.', words: ['loud', 'noisy', 'deafening'], correct: ['loud', 'noisy', 'deafening'] },
        { prompt: 'Order from least to most big.', words: ['big', 'large', 'huge'], correct: ['big', 'large', 'huge'] },
        { prompt: 'Order from least to most fast.', words: ['fast', 'faster', 'fastest'], correct: ['fast', 'faster', 'fastest'] },
        { prompt: 'Order from least to most small.', words: ['small', 'smaller', 'smallest'], correct: ['small', 'smaller', 'smallest'] },
        { prompt: 'Order from least to most wet.', words: ['damp', 'wet', 'soaked'], correct: ['damp', 'wet', 'soaked'] },
        { prompt: 'Order from least to most tired.', words: ['tired', 'sleepy', 'exhausted'], correct: ['tired', 'sleepy', 'exhausted'] },
        { prompt: 'Order from least to most good.', words: ['good', 'great', 'excellent'], correct: ['good', 'great', 'excellent'] }
      ],

      phonemeChange: [
        { base: 'cat', firstTo: 'b', result: 'bat', lastTo: 'p', lastResult: 'cap', vowelTo: 'o', vowelResult: 'cot' },
        { base: 'dog', firstTo: 'l', result: 'log', lastTo: 't', lastResult: 'dot', vowelTo: 'i', vowelResult: 'dig' },
        { base: 'sun', firstTo: 'f', result: 'fun', lastTo: 'm', lastResult: 'sum', vowelTo: 'o', vowelResult: 'son' },
        { base: 'bed', firstTo: 'r', result: 'red', lastTo: 'g', lastResult: 'beg', vowelTo: 'a', vowelResult: 'bad' },
        { base: 'pin', firstTo: 't', result: 'tin', lastTo: 'g', lastResult: 'pig', vowelTo: 'a', vowelResult: 'pan' },
        { base: 'tap', firstTo: 'm', result: 'map', lastTo: 'n', lastResult: 'tan', vowelTo: 'o', vowelResult: 'top' },
        { base: 'bug', firstTo: 'h', result: 'hug', lastTo: 'n', lastResult: 'bun', vowelTo: 'a', vowelResult: 'bag' },
        { base: 'hat', firstTo: 'b', result: 'bat', lastTo: 'm', lastResult: 'ham', vowelTo: 'u', vowelResult: 'hut' },
        { base: 'cap', firstTo: 't', result: 'tap', lastTo: 't', lastResult: 'cat', vowelTo: 'o', vowelResult: 'cop' },
        { base: 'fin', firstTo: 'p', result: 'pin', lastTo: 't', lastResult: 'fit', vowelTo: 'a', vowelResult: 'fan' }
      ],

      contractions: [
        { phrase: 'do not', contraction: "don't", wrong: ["do'nt", 'dont'] },
        { phrase: 'cannot', contraction: "can't", wrong: ['cant', "ca'nt"] },
        { phrase: 'I am', contraction: "I'm", wrong: ['Im', "I m".replace(' ', '')] },
        { phrase: 'we are', contraction: "we're", wrong: ['were', "we re".replace(' ', '')] },
        { phrase: 'it is', contraction: "it's", wrong: ['its', "it s".replace(' ', '')] },
        { phrase: 'you are', contraction: "you're", wrong: ['your', "you re".replace(' ', '')] },
        { phrase: 'they are', contraction: "they're", wrong: ['there', "they re".replace(' ', '')] },
        { phrase: 'she is', contraction: "she's", wrong: ['shes', "she s".replace(' ', '')] },
        { phrase: 'is not', contraction: "isn't", wrong: ['isnt', "is'nt"] },
        { phrase: 'are not', contraction: "aren't", wrong: ['arent', "are'nt"] },
        { phrase: 'will not', contraction: "won't", wrong: ['wont', "wo'nt"] },
        { phrase: 'has not', contraction: "hasn't", wrong: ['hasnt', "has'nt"] },
        { phrase: 'did not', contraction: "didn't", wrong: ['didnt', "did'nt"] }
      ],
      plurals: [
        { singular: 'cat', plural: 'cats', wrong: ['cat', 'cates'] },
        { singular: 'dog', plural: 'dogs', wrong: ['dog', 'doges'] },
        { singular: 'box', plural: 'boxes', wrong: ['boxs', 'box'] },
        { singular: 'dish', plural: 'dishes', wrong: ['dishs', 'dish'] },
        { singular: 'bus', plural: 'buses', wrong: ['buss', 'bus'] },
        { singular: 'fox', plural: 'foxes', wrong: ['foxs', 'fox'] },
        { singular: 'bench', plural: 'benches', wrong: ['benchs', 'bench'] },
        { singular: 'class', plural: 'classes', wrong: ['classs', 'class'] },
        { singular: 'baby', plural: 'babies', wrong: ['babys', 'baby'] },
        { singular: 'city', plural: 'cities', wrong: ['citys', 'city'] },
        { singular: 'leaf', plural: 'leaves', wrong: ['leafs', 'leaf'] }
      ],
      sentenceTypes: [
        { sentence: 'I like pizza.', type: 'Statement' },
        { sentence: 'Do you like pizza?', type: 'Question' },
        { sentence: 'Please sit down.', type: 'Command' },
        { sentence: 'That is amazing!', type: 'Exclamation' },
        { sentence: 'The dog can run.', type: 'Statement' },
        { sentence: 'Where is the book?', type: 'Question' },
        { sentence: 'Close the door.', type: 'Command' },
        { sentence: 'I did it!', type: 'Exclamation' },
        { sentence: 'We ride the train.', type: 'Statement' },
        { sentence: 'Can you help me?', type: 'Question' },
        { sentence: 'Stop and look.', type: 'Command' },
        { sentence: 'What a big fish!', type: 'Exclamation' }
      ],
      whSentences: [
        { sentence: '____ is at the door?', correct: 'Who', wrong: ['Where', 'When'] },
        { sentence: '____ do you live?', correct: 'Where', wrong: ['Who', 'Why'] },
        { sentence: '____ did you eat?', correct: 'What', wrong: ['When', 'Who'] },
        { sentence: '____ is it raining?', correct: 'Why', wrong: ['What', 'Where'] },
        { sentence: '____ do we go?', correct: 'When', wrong: ['Who', 'What'] },
        { sentence: '____ is your name?', correct: 'What', wrong: ['Where', 'When'] },
        { sentence: '____ is the party?', correct: 'When', wrong: ['Who', 'Why'] },
        { sentence: '____ is the ball?', correct: 'Where', wrong: ['What', 'When'] },
        { sentence: '____ is calling me?', correct: 'Who', wrong: ['Where', 'Why'] },
        { sentence: '____ are you sad?', correct: 'Why', wrong: ['Who', 'When'] },
        { sentence: '____ is in the box?', correct: 'What', wrong: ['When', 'Why'] },
        { sentence: '____ is the teacher?', correct: 'Who', wrong: ['What', 'When'] },
        { sentence: '____ do we eat lunch?', correct: 'When', wrong: ['Where', 'Why'] },
        { sentence: '____ do we put the shoes?', correct: 'Where', wrong: ['Who', 'When'] }
      ],
      conjunctions: [
        { sentence: 'I like soup ____ I like pizza.', correct: 'and', wrong: ['but', 'because'] },
        { sentence: 'I want to play, ____ it is raining.', correct: 'but', wrong: ['and', 'so'] },
        { sentence: 'I was hungry, ____ I ate.', correct: 'so', wrong: ['but', 'because'] },
        { sentence: 'I wear a coat ____ it is cold.', correct: 'because', wrong: ['and', 'so'] },
        { sentence: 'I can read ____ I can write.', correct: 'and', wrong: ['but', 'because'] },
        { sentence: 'I was tired, ____ I went to bed.', correct: 'so', wrong: ['and', 'but'] },
        { sentence: 'I want to go, ____ I must wait.', correct: 'but', wrong: ['and', 'because'] },
        { sentence: 'I ate, ____ I was still hungry.', correct: 'but', wrong: ['and', 'because'] },
        { sentence: 'I wore boots ____ it was raining.', correct: 'because', wrong: ['and', 'but'] },
        { sentence: 'I finished my work, ____ I played.', correct: 'so', wrong: ['but', 'because'] }
      ],
      timeOrder: [
        { sentence: '____, I wash my hands. Next, I eat.', correct: 'First', wrong: ['Next', 'Last'] },
        { sentence: 'First, I mix. ____, I bake. Last, I eat.', correct: 'Next', wrong: ['First', 'Last'] },
        { sentence: 'First, I read. Next, I write. ____, I clean up.', correct: 'Last', wrong: ['First', 'Next'] },
        { sentence: '____, I put on socks. Next, I put on shoes.', correct: 'First', wrong: ['Next', 'Last'] },
        { sentence: 'First, we line up. ____, we walk to class. Last, we sit.', correct: 'Next', wrong: ['First', 'Last'] },
        { sentence: 'First, I brush my teeth. Next, I wash my face. ____, I go to bed.', correct: 'Last', wrong: ['First', 'Next'] },
        { sentence: '____, I get a bowl. Next, I pour cereal. Last, I eat.', correct: 'First', wrong: ['Next', 'Last'] },
        { sentence: 'First, I open the door. ____, I step in. Last, I shut it.', correct: 'Next', wrong: ['First', 'Last'] },
        { sentence: 'First, we pack. Next, we ride. ____, we arrive.', correct: 'Last', wrong: ['First', 'Next'] }
      ],
      textFeatures: [
        { question: 'What helps you find page numbers fast?', correct: 'Table of contents', wrong: ['Title', 'Picture'] },
        { question: 'What tells what a picture shows?', correct: 'Caption', wrong: ['Question mark', 'Rhyme'] },
        { question: 'What word is at the top of a page to tell the topic?', correct: 'Heading', wrong: ['Sticker', 'Song'] },
        { question: 'What list tells what a word means?', correct: 'Glossary', wrong: ['Calendar', 'Recipe'] },
        { question: 'What list helps you find topics at the back of a book?', correct: 'Index', wrong: ['Poem', 'Riddle'] },
        { question: 'What shows the parts of something with words and lines?', correct: 'Label', wrong: ['Rhyme', 'End mark'] },
        { question: 'What helps you see where places are?', correct: 'Map', wrong: ['Joke', 'Song'] },
        { question: 'What special word shows important words in dark print?', correct: 'Bold print', wrong: ['Whisper', 'Shadow'] }
      ],
      bestTitle: [
        { passage: 'Sam plants a seed. Sam waters it. A plant grows.', correct: 'A New Plant', wrong: ['A Rainy Day', 'A Fast Train'] },
        { passage: 'Mia makes a sandwich. Mia eats lunch. Mia feels full.', correct: 'Lunch Time', wrong: ['At the Zoo', 'A Snow Day'] },
        { passage: 'Ben finds a lost hat. Ben gives it back. The girl smiles.', correct: 'A Kind Choice', wrong: ['A Big Race', 'A Fish Shop'] },
        { passage: 'A dog is wet. The dog shakes. Water splashes.', correct: 'A Wet Dog', wrong: ['A Dry Desert', 'A Quiet Room'] },
        { passage: 'We line up. We get on the bus. We go to school.', correct: 'Going to School', wrong: ['Baking a Cake', 'Flying a Kite'] },
        { passage: 'Ana reads a book. Ana learns facts. Ana tells a friend.', correct: 'Reading to Learn', wrong: ['Fixing a Bike', 'Eating Pizza'] },
        { passage: 'The wind blows. Leaves fall. It is autumn.', correct: 'A Windy Fall Day', wrong: ['Summer at the Beach', 'A New Puppy'] },
        { passage: 'A boy drops his ice cream. He feels sad. Mom helps him.', correct: 'Ice Cream Trouble', wrong: ['A Lost Hat', 'A New Toy'] },
        { passage: 'The class is loud. The teacher says please be quiet.', correct: 'Quiet in Class', wrong: ['A Loud Class', 'Reading Time'] },
        { passage: 'Dad cooks rice. The rice gets soft. We eat dinner.', correct: 'Dinner Is Ready', wrong: ['Lunch Time', 'A Quiet Room'] },
        { passage: 'Kim puts on boots. Kim walks in the rain. Kim stays dry.', correct: 'Walking in the Rain', wrong: ['A Hot Desert', 'A Sleeping Cat'] },
        { passage: 'The bird finds sticks. The bird builds a nest.', correct: 'Building a Nest', wrong: ['A New Toy', 'A Cold Drink'] },
        { passage: 'Sara loses a pencil. Sara looks under the desk. Sara finds it.', correct: 'Finding a Pencil', wrong: ['A Snowy Day', 'A Pizza Party'] },
        { passage: 'A boy is thirsty. He drinks water. He feels better.', correct: 'A Thirsty Boy', wrong: ['A Cold Drink', 'Feeling Better'] },
        { passage: 'We wash our hands. We eat. We clean up.', correct: 'After We Eat', wrong: ['A Rainy Day', 'A New Train'] },
        { passage: 'The puppy runs. The puppy jumps. The puppy plays.', correct: 'Puppy Play', wrong: ['A Sad Song', 'A Quiet Cave'] },
        { passage: 'Mom bakes a cake. The cake smells sweet. We taste it.', correct: 'Baking a Cake', wrong: ['Riding a Bike', 'A Lost Hat'] },
        { passage: 'A frog sits on a log. A frog jumps in the pond.', correct: 'A Frog Jumps', wrong: ['A Long Train', 'A Cold Pizza'] },
        { passage: 'Ben reads the sign. Ben walks to the store.', correct: 'Reading a Sign', wrong: ['Going to School', 'A New Plant'] }
      ],
      supportingDetail: [
        { passage: 'The cat sits on the bed. The cat is sleepy.', question: 'Which detail is in the passage?', correct: 'The cat is sleepy.', wrong: ['The cat is hungry.', 'The cat is happy.'] },
        { passage: 'Ben has a kite. Ben runs fast. The kite goes up.', question: 'Which detail is in the passage?', correct: 'The kite goes up.', wrong: ['The kite goes down.', 'Ben sits down.'] },
        { passage: 'Mia goes to the bakery. It smells sweet. Mia buys a bun.', question: 'Which detail is in the passage?', correct: 'It smells sweet.', wrong: ['It smells like bread.', 'Mia buys a cake.'] },
        { passage: 'Dark clouds come. Rain starts. We go inside.', question: 'What happens in the passage?', correct: 'We go inside.', wrong: ['We stay outside.', 'We close the door.'] },
        { passage: 'The soup is hot. Steam goes up. I wait to eat.', question: 'Which detail is true?', correct: 'Steam goes up.', wrong: ['Steam goes down.', 'The soup is cold.'] },
        { passage: 'The dog is thirsty. The dog drinks water.', question: 'Which detail is in the passage?', correct: 'The dog drinks water.', wrong: ['The dog eats food.', 'The dog takes a nap.'] },
        { passage: 'We clean up toys. We put them in a box.', question: 'Which detail is in the passage?', correct: 'We put toys in a box.', wrong: ['We leave toys on the floor.', 'We put toys on a shelf.'] },
        { passage: 'I wear a coat because it is cold.', question: 'Which detail is in the passage?', correct: 'It is cold.', wrong: ['It is hot.', 'It is bedtime.'] },
        { passage: 'A fish swims in water. A bird flies in the sky.', question: 'Which detail is in the passage?', correct: 'A bird flies in the sky.', wrong: ['A bird sings in a tree.', 'A fish hides by rocks.'] },
        { passage: 'Tom reads each page. Tom learns new words.', question: 'Which detail is in the passage?', correct: 'Tom learns new words.', wrong: ['Tom draws a picture.', 'Tom plays a game.'] },
        { passage: 'We go to the park. We swing. We slide.', question: 'Which detail is in the passage?', correct: 'We swing.', wrong: ['We run.', 'We climb.'] },
        { passage: 'A baby drinks milk. The baby smiles.', question: 'Which detail is in the passage?', correct: 'The baby smiles.', wrong: ['The baby cries.', 'The baby falls asleep.'] },
        { passage: 'Dad fixes the bike. The bike can roll again.', question: 'Which detail is in the passage?', correct: 'Dad fixes the bike.', wrong: ['Dad cleans the bike.', 'Dad rides the bike.'] },
        { passage: 'Ana paints with red and blue. Ana makes a picture.', question: 'Which detail is in the passage?', correct: 'Ana paints with red and blue.', wrong: ['Ana paints with green and yellow.', 'Ana draws with a pencil.'] },
        { passage: 'The rain stops. The sun comes out.', question: 'Which detail is in the passage?', correct: 'The sun comes out.', wrong: ['The rain starts.', 'The clouds cover the sun.'] },
        { passage: 'Ben is hungry. Ben eats an apple.', question: 'Which detail is in the passage?', correct: 'Ben eats an apple.', wrong: ['Ben eats a banana.', 'Ben drinks water.'] },
        { passage: 'Mia has a new puppy. The puppy runs to her.', question: 'Which detail is in the passage?', correct: 'The puppy runs to her.', wrong: ['The puppy runs away.', 'The puppy sits down.'] },
        { passage: 'We make pancakes. We mix and stir. We cook them.', question: 'Which detail is in the passage?', correct: 'We mix and stir.', wrong: ['We plant a tree.', 'We fly a kite.'] },
        { passage: 'The class is quiet. The teacher reads a story.', question: 'Which detail is in the passage?', correct: 'The teacher reads a story.', wrong: ['The teacher writes on a board.', 'The class talks loudly.'] },
        { passage: 'A boy drops his cup. The water spills on the floor.', question: 'Which detail is in the passage?', correct: 'The water spills on the floor.', wrong: ['The cup stays dry.', 'The boy wipes it up.'] },
        { passage: 'Kim ties her shoes. Kim runs outside.', question: 'Which detail is in the passage?', correct: 'Kim ties her shoes.', wrong: ['Kim paints her shoes.', 'Kim sleeps on the shoes.'] },
        { passage: 'The bird builds a nest with sticks.', question: 'Which detail is in the passage?', correct: 'The bird uses sticks.', wrong: ['The bird uses leaves.', 'The bird uses grass.'] },
        { passage: 'We wash our hands before we eat.', question: 'Which detail is in the passage?', correct: 'We wash our hands.', wrong: ['We wash our face.', 'We wash our plate.'] },
        { passage: 'Dad packs a lunch. Dad puts an apple in the bag.', question: 'Which detail is in the passage?', correct: 'Dad puts an apple in the bag.', wrong: ['Dad puts a sandwich in the bag.', 'Dad puts a banana in the bag.'] },
        { passage: 'The dog digs in the yard. The dog finds a bone.', question: 'Which detail is in the passage?', correct: 'The dog finds a bone.', wrong: ['The dog finds a stick.', 'The dog finds a toy.'] },
        { passage: 'Lia reads a sign. The sign says STOP.', question: 'Which detail is in the passage?', correct: 'The sign says STOP.', wrong: ['The sign says GO.', 'The sign says SLOW.'] },
        { passage: 'I put on boots. I walk in the rain. I stay dry.', question: 'Which detail is in the passage?', correct: 'I stay dry.', wrong: ['I get wet.', 'I use an umbrella.'] }
      ],
      characterActions: [
        { passage: 'Ben sees a friend fall. Ben helps her up.', question: 'What is Ben like?', correct: 'Helpful', wrong: ['Mean', 'Lazy'] },
        { passage: 'Mia shares her crayons. Mia says you can use mine.', question: 'What is Mia like?', correct: 'Kind', wrong: ['Rude', 'Scared'] },
        { passage: 'Tom hears a loud sound. Tom hides behind a chair.', question: 'How does Tom feel?', correct: 'Scared', wrong: ['Proud', 'Sleepy'] },
        { passage: 'Ana tries a hard puzzle. Ana keeps trying.', question: 'What is Ana like?', correct: 'Keeps trying', wrong: ['Gives up', 'Does not care'] },
        { passage: 'Kai says I can do it. Kai smiles and tries again.', question: 'How does Kai feel?', correct: 'Confident', wrong: ['Sad', 'Angry'] },
        { passage: 'A girl says sorry. She fixes the mistake.', question: 'What is the girl like?', correct: 'Fixes mistakes', wrong: ['Blames others', 'Runs away'] },
        { passage: 'A boy takes a toy without asking.', question: 'What is the boy like?', correct: 'Rude', wrong: ['Kind', 'Helpful'] },
        { passage: 'Lia waits her turn. Lia stands in line.', question: 'What is Lia like?', correct: 'Patient', wrong: ['Wild', 'Mean'] },
        { passage: 'Dad cooks dinner. Dad says we can work together.', question: 'What is Dad like?', correct: 'Helpful', wrong: ['Rude', 'Sleepy'] },
        { passage: 'A child sees a lost mitten. The child gives it back.', question: 'What is the child like?', correct: 'Honest', wrong: ['Mean', 'Greedy'] },
        { passage: 'A kid lets a friend go first. The kid smiles.', question: 'What is the kid like?', correct: 'Kind', wrong: ['Rude', 'Mean'] },
        { passage: 'A boy tries a new slide. The boy says I am brave.', question: 'How does the boy feel?', correct: 'Brave', wrong: ['Scared', 'Sleepy'] },
        { passage: 'A girl says I will help. The girl carries the box.', question: 'What is the girl like?', correct: 'Helpful', wrong: ['Mean', 'Rude'] },
        { passage: 'A child looks at a mess. The child cleans it up.', question: 'What is the child like?', correct: 'Responsible', wrong: ['Lazy', 'Mean'] },
        { passage: 'A kid laughs when a friend falls. The kid does not help.', question: 'What is the kid like?', correct: 'Mean', wrong: ['Kind', 'Helpful'] }
      ],
      pronounReference: [
        { passage: 'Mia has a dog. She pets it.', question: 'Who is she?', correct: 'Mia', wrong: ['The dog', 'It'] },
        { passage: 'Ben has two cats. They run.', question: 'Who are they?', correct: 'The cats', wrong: ['Ben', 'A dog'] },
        { passage: 'I have a ball. It is red.', question: 'What is it?', correct: 'The ball', wrong: ['Red', 'I'] },
        { passage: 'Sara eats an apple. It is sweet.', question: 'What is it?', correct: 'The apple', wrong: ['Sara', 'Sweet'] },
        { passage: 'Tom and Ana play a game. They laugh.', question: 'Who are they?', correct: 'Tom and Ana', wrong: ['A game', 'Laugh'] },
        { passage: 'Dad fixes the bike. He smiles.', question: 'Who is he?', correct: 'Dad', wrong: ['The bike', 'Smiles'] },
        { passage: 'The fish swims in water. It is wet.', question: 'What is it?', correct: 'The fish', wrong: ['Water', 'Wet'] },
        { passage: 'The baby drinks milk. She looks happy.', question: 'Who is she?', correct: 'The baby', wrong: ['Milk', 'Happy'] },
        { passage: 'The teacher reads. She points to the words.', question: 'Who is she?', correct: 'The teacher', wrong: ['The words', 'Points'] },
        { passage: 'My friends come here. They sit down.', question: 'Who are they?', correct: 'My friends', wrong: ['Here', 'Down'] },
        { passage: 'Max has a kite. He flies it.', question: 'Who is he?', correct: 'Max', wrong: ['The kite', 'It'] },
        { passage: 'The cats are hungry. They eat.', question: 'Who are they?', correct: 'The cats', wrong: ['Hungry', 'Eat'] },
        { passage: 'Mom makes soup. She stirs it.', question: 'What is it?', correct: 'The soup', wrong: ['Mom', 'Stirs'] },
        { passage: 'A bird has a nest. It sits there.', question: 'What is it?', correct: 'The bird', wrong: ['The nest', 'There'] },
        { passage: 'Ben and Mia read. They look at the words.', question: 'Who are they?', correct: 'Ben and Mia', wrong: ['The words', 'Look'] }
      ],
      problemSolution: [
        { passage: 'Mia is thirsty. Mia gets a drink.', problem: 'Mia is thirsty', solution: 'Mia gets a drink', wrongProblem: ['Mia is sleepy', 'Mia is hungry'], wrongSolution: ['Mia drops the cup', 'Mia goes to bed'] },
        { passage: 'Ben is cold. Ben puts on a coat.', problem: 'Ben is cold', solution: 'Ben puts on a coat', wrongProblem: ['Ben is hot', 'Ben is hungry'], wrongSolution: ['Ben puts on a hat', 'Ben takes off his coat'] },
        { passage: 'The room is messy. We clean up.', problem: 'The room is messy', solution: 'We clean up', wrongProblem: ['The room is quiet', 'The room is bright'], wrongSolution: ['We make a mess', 'We run away'] },
        { passage: 'The soup is hot. I wait before I eat.', problem: 'The soup is hot', solution: 'I wait before I eat', wrongProblem: ['The soup is cold', 'The soup is loud'], wrongSolution: ['I eat very fast', 'I blow on the soup'] },
        { passage: 'Sara cannot find her pencil. Sara looks under the desk.', problem: 'Sara cannot find her pencil', solution: 'Sara looks under the desk', wrongProblem: ['Sara is sleepy', 'Sara is hungry'], wrongSolution: ['Sara looks in her bag', 'Sara looks in a drawer'] },
        { passage: 'The dog is thirsty. The dog drinks water.', problem: 'The dog is thirsty', solution: 'The dog drinks water', wrongProblem: ['The dog is hungry', 'The dog is tired'], wrongSolution: ['The dog eats food', 'The dog takes a nap'] },
        { passage: 'The rain starts. We use an umbrella.', problem: 'The rain starts', solution: 'We use an umbrella', wrongProblem: ['The wind blows', 'The sky is cloudy'], wrongSolution: ['We wear a coat', 'We run in the rain'] },
        { passage: 'Tom spills milk. Tom wipes it up.', problem: 'Tom spills milk', solution: 'Tom wipes it up', wrongProblem: ['Tom drops a cup', 'Tom is thirsty'], wrongSolution: ['Tom leaves it there', 'Tom goes to bed'] },
        { passage: 'The toy breaks. Dad fixes it.', problem: 'The toy breaks', solution: 'Dad fixes it', wrongProblem: ['The toy is dirty', 'The toy is lost'], wrongSolution: ['Dad breaks it more', 'Dad hides the toy'] },
        { passage: 'The door is locked. We find a key.', problem: 'The door is locked', solution: 'We find a key', wrongProblem: ['The door is stuck', 'The door is heavy'], wrongSolution: ['We throw the key away', 'We paint the lock'] },
        { passage: 'I am hungry. I eat a sandwich.', problem: 'I am hungry', solution: 'I eat a sandwich', wrongProblem: ['I am thirsty', 'I am sleepy'], wrongSolution: ['I drink water', 'I go to bed'] },
        { passage: 'The floor is wet. We walk slowly.', problem: 'The floor is wet', solution: 'We walk slowly', wrongProblem: ['The floor is slippery', 'The floor is messy'], wrongSolution: ['We run fast', 'We jump on the floor'] }
      ],

      spelling: {
        cvc: [
          { word: 'cat', wrong: ['cet', 'cta'] },
          { word: 'dog', wrong: ['dug', 'god'] },
          { word: 'sun', wrong: ['son', 'snu'] },
          { word: 'bed', wrong: ['bde', 'bad'] },
          { word: 'map', wrong: ['mop', 'mpa'] },
          { word: 'pig', wrong: ['peg', 'pg i'.replace(' ', '')] },
          { word: 'hat', wrong: ['hot', 'hta'] },
          { word: 'cup', wrong: ['cap', 'cpu'] },
          { word: 'log', wrong: ['lag', 'lgo'] },
          { word: 'fin', wrong: ['fan', 'fni'] },
          { word: 'pen', wrong: ['pan', 'pne'] },
          { word: 'sit', wrong: ['set', 'sti'] },
          { word: 'rug', wrong: ['rag', 'rgu'] },
          { word: 'top', wrong: ['tap', 'tpo'] }
        ],
        digraph: [
          { word: 'ship', wrong: ['sip', 'shp'] },
          { word: 'shop', wrong: ['sop', 'shpo'] },
          { word: 'fish', wrong: ['fis', 'fihs'] },
          { word: 'dish', wrong: ['dis', 'dihs'] },
          { word: 'wish', wrong: ['wis', 'wihs'] },
          { word: 'chip', wrong: ['cip', 'chp'] },
          { word: 'chop', wrong: ['cop', 'chpo'] },
          { word: 'chin', wrong: ['cin', 'chni'] },
          { word: 'this', wrong: ['tis', 'thsi'] },
          { word: 'that', wrong: ['tat', 'thta'] },
          { word: 'thin', wrong: ['tin', 'thni'] },
          { word: 'with', wrong: ['wit', 'wthi'] }
        ],
        sight: [
          { word: 'there', wrong: ['thare', 'ther'] },
          { word: 'want', wrong: ['went', 'wnat'] },
          { word: 'like', wrong: ['liek', 'lik'] },
          { word: 'come', wrong: ['com', 'cme'] },
          { word: 'said', wrong: ['sed', 'siad'] },
          { word: 'have', wrong: ['hve', 'haev'] },
          { word: 'they', wrong: ['thay', 'tehy'] },
          { word: 'were', wrong: ['wer', 'we re'.replace(' ', '')] },
          { word: 'from', wrong: ['form', 'frmo'] },
          { word: 'who', wrong: ['hoo', 'woh'] },
          { word: 'could', wrong: ['coud', 'colud'] },
          { word: 'once', wrong: ['onc', 'ocne'] },
          { word: 'because', wrong: ['becaus', 'becuase'] },
          { word: 'does', wrong: ['doas', 'dose'] },
          { word: 'where', wrong: ['wher', 'whare'] },
          { word: 'again', wrong: ['agin', 'agian'] }
        ]
      }
    };

    function generateSkillPages(skillId, count = 10) {
      const pages = [];
      const bank = skillWordBanks;
      const usedPoolItems = new Set();

      function pickPoolItem(poolKey, items) {
        if (!Array.isArray(items) || items.length === 0) return null;
        const start = Math.floor(Math.random() * items.length);
        for (let offset = 0; offset < items.length; offset++) {
          const idx = (start + offset) % items.length;
          const key = `${poolKey}:${idx}`;
          if (!usedPoolItems.has(key)) {
            usedPoolItems.add(key);
            return items[idx];
          }
        }
        return pickOne(items);
      }

      function pickUniqueValue(valueKey, candidates) {
        if (!Array.isArray(candidates) || candidates.length === 0) return null;
        const pool = shuffleInPlace([...candidates]);
        for (const value of pool) {
          const token = `${valueKey}:${String(value).toLowerCase()}`;
          if (!usedPoolItems.has(token)) {
            usedPoolItems.add(token);
            return value;
          }
        }
        return pickOne(candidates);
      }

      function pickWordStartingWith(letter) {
        const candidates = bank.cvc.filter(w => (w[0] || '').toLowerCase() === letter.toLowerCase());
        return candidates.length ? pickOne(candidates) : null;
      }

      function pickWordEndingWith(letter) {
        const candidates = bank.cvc.filter(w => w.endsWith(letter.toLowerCase()));
        return candidates.length ? pickOne(candidates) : null;
      }

      function flattenValues(obj) {
        if (!obj) return [];
        return Object.keys(obj).reduce((acc, key) => acc.concat(obj[key] || []), []);
      }

      function pickWrongWords(pool, count, excludeSet) {
        const candidates = (pool || []).filter(w => !excludeSet.has(w));
        return pickDistinct(candidates.length ? candidates : bank.cvc, count, excludeSet);
      }

      for (let i = 0; i < count; i++) {
        if (skillId.startsWith('vowel-team-')) {
          const team = skillId.replace('vowel-team-', '');
          const teamWords = (bank.vowelTeams && bank.vowelTeams[team]) ? bank.vowelTeams[team] : [];
          const correct = pickUniqueValue(`vowel-team-${team}`, teamWords) || (teamWords.length ? pickOne(teamWords) : 'see');
          const wrongPool = flattenValues(bank.vowelTeams).concat(bank.cvc);
          const wrong = pickWrongWords(wrongPool.filter(w => !w.includes(team)), 2, new Set([correct]));
          const answers = shuffleInPlace([correct, ...wrong]);
          const stems = [
            { q: `Which word has ${team.toUpperCase()}?`, h: `Look for the letters ${team}.` },
            { q: `Find the word with ${team.toUpperCase()}.`, h: `Scan for ${team}.` },
            { q: `Which word contains ${team.toUpperCase()}?`, h: `The vowel team is ${team}.` }
          ];
          const stem = pickOne(stems);
          pages.push(makeMCQ({
            passage: `Vowel team is ${team.toUpperCase()}.`,
            question: stem.q,
            hint: stem.h,
            answers,
            correctAnswerName: correct,
            successMessage: 'Nice! You found the vowel team.'
          }));
        } else if (skillId.startsWith('r-controlled-')) {
          const pattern = skillId.replace('r-controlled-', '');
          const patternWords = (bank.rControlled && bank.rControlled[pattern]) ? bank.rControlled[pattern] : [];
          const correct = pickUniqueValue(`r-controlled-${pattern}`, patternWords) || (patternWords.length ? pickOne(patternWords) : 'car');
          const wrongPool = flattenValues(bank.rControlled).concat(bank.cvc, bank.ccvc, bank.cvcc);
          const wrong = pickWrongWords(wrongPool.filter(w => !w.includes(pattern)), 2, new Set([correct]));
          const answers = shuffleInPlace([correct, ...wrong]);
          const stems = [
            { q: `Which word has ${pattern.toUpperCase()}?`, h: `Look for the letters ${pattern}.` },
            { q: `Find the word with ${pattern.toUpperCase()}.`, h: `Scan for ${pattern}.` },
            { q: `Which word contains ${pattern.toUpperCase()}?`, h: `R-controlled means the vowel + R.` }
          ];
          const stem = pickOne(stems);
          pages.push(makeMCQ({
            passage: `R controlled is ${pattern.toUpperCase()}.`,
            question: stem.q,
            hint: stem.h,
            answers,
            correctAnswerName: correct,
            successMessage: 'Great! You found the r-controlled vowel.'
          }));
        } else if (skillId.startsWith('diphthong-')) {
          const pattern = skillId.replace('diphthong-', '');
          const patternWords = (bank.diphthongs && bank.diphthongs[pattern]) ? bank.diphthongs[pattern] : [];
          const correct = pickUniqueValue(`diphthong-${pattern}`, patternWords) || (patternWords.length ? pickOne(patternWords) : 'coin');
          const wrongPool = flattenValues(bank.diphthongs).concat(bank.cvc, bank.ccvc, bank.cvcc);
          const wrong = pickWrongWords(wrongPool.filter(w => !w.includes(pattern)), 2, new Set([correct]));
          const answers = shuffleInPlace([correct, ...wrong]);
          const stems = [
            { q: `Which word has ${pattern.toUpperCase()}?`, h: `Look for the letters ${pattern}.` },
            { q: `Find the word with ${pattern.toUpperCase()}.`, h: `Scan for ${pattern}.` },
            { q: `Which word contains ${pattern.toUpperCase()}?`, h: `Look for the vowel pattern.` }
          ];
          const stem = pickOne(stems);
          pages.push(makeMCQ({
            passage: `Vowel pattern is ${pattern.toUpperCase()}.`,
            question: stem.q,
            hint: stem.h,
            answers,
            correctAnswerName: correct,
            successMessage: 'Nice! You found the vowel pattern.'
          }));
        } else if (skillId === 'compound-words') {
          const item = pickPoolItem('compoundWords', bank.compoundWords || []);
          const correct = item ? item.word : 'sunset';
          const wrong = pickWrongWords((bank.twoSyllables || []).map(x => x.word).concat(bank.cvc), 2, new Set([correct]));
          const answers = shuffleInPlace([correct, ...wrong]);
          pages.push(makeMCQ({
            passage: `Put the words together. ${item ? item.a : 'sun'} plus ${item ? item.b : 'set'}.`,
            question: 'Which compound word do you make?',
            hint: 'A compound word is two words joined together.',
            answers,
            correctAnswerName: correct,
            successMessage: 'Yes! You made a compound word.'
          }));
        } else if (skillId === 'two-syllable-build') {
          const item = pickPoolItem('twoSyllableBuild', bank.twoSyllableBuild || []);
          const correct = item ? item.word : 'baby';
          const wrong = pickWrongWords((bank.twoSyllableBuild || []).map(x => x.word).concat((bank.twoSyllables || []).map(x => x.word)), 2, new Set([correct]));
          const answers = shuffleInPlace([correct, ...wrong]);
          pages.push(makeMCQ({
            passage: `Put the syllables together. ${item ? item.a : 'ba'} plus ${item ? item.b : 'by'}.`,
            question: 'Which word do you make?',
            hint: 'Blend the two parts.',
            answers,
            correctAnswerName: correct,
            successMessage: 'Nice syllable blending!'
          }));
        } else if (skillId === 'syllables-which') {
          const target = pickUniqueValue('syllables-which-target', ['2', '3']) || pickOne(['2', '3']);
          const correctPool = target === '2' ? (bank.twoSyllables || []).map(x => x.word) : (bank.threeSyllables || []).map(x => x.word);
          const correct = pickUniqueValue(`syllables-which-${target}`, correctPool) || pickOne(correctPool);
          const wrongPool = (target === '2'
            ? (bank.threeSyllables || []).map(x => x.word)
            : (bank.twoSyllables || []).map(x => x.word)).concat(bank.cvc);
          const wrong = pickWrongWords(wrongPool, 2, new Set([correct]));
          const answers = shuffleInPlace([correct, ...wrong]);
          const stems = [
            { q: `Which word has ${target} syllables?`, h: 'Clap the parts you hear.' },
            { q: `Which word has ${target} beats?`, h: 'Say the word slowly.' },
            { q: `Pick the ${target}-syllable word.`, h: 'Each part you clap is a syllable.' }
          ];
          const stem = pickOne(stems);
          pages.push(makeMCQ({
            question: stem.q,
            hint: stem.h,
            answers,
            correctAnswerName: correct,
            successMessage: 'Great syllable listening!'
          }));
        } else if (skillId === 'rhyming-complete') {
          const family = pickPoolItem('rhyming-complete', bank.rhymes) || pickOne(bank.rhymes);
          const base = pickOne(family);
          const correct = pickDistinct(family, 1, new Set([base]))[0];
          const wrong = pickWrongWords(bank.cvc, 2, new Set([base, correct]));
          const answers = shuffleInPlace([correct, ...wrong]);
          pages.push(makeMCQ({
            passage: `I see a ${base}. It wears a _____.`,
            question: 'Which word completes the rhyme?',
            hint: 'Pick a word that rhymes with the first word.',
            answers,
            correctAnswerName: correct,
            successMessage: 'Yes! That makes a rhyme.'
          }));
        } else if (skillId === 'blend-sounds') {
          const word = pickUniqueValue('blend-sounds', bank.cvc) || pickOne(bank.cvc);
          const sounds = word.split('').join(' - ');
          const correct = word;
          const wrong = pickWrongWords(bank.cvc, 2, new Set([correct]));
          const answers = shuffleInPlace([correct, ...wrong]);
          const stems = [
            { q: 'Which word do the sounds make?', h: 'Say the sounds fast and smooth.' },
            { q: 'Blend the sounds. What word do you read?', h: 'Say it slowly, then faster.' },
            { q: 'What word is this?', h: 'Put the sounds together.' }
          ];
          const stem = pickOne(stems);
          pages.push(makeMCQ({
            passage: `Blend the sounds. ${sounds}.`,
            question: stem.q,
            hint: stem.h,
            answers,
            correctAnswerName: correct,
            successMessage: 'Nice blending!'
          }));
        } else if (skillId === 'first-sound') {
          const word = pickUniqueValue('first-sound', bank.cvc) || pickOne(bank.cvc);
          const correct = word[0].toLowerCase();
          const wrong = pickDistinct(bank.consonants.filter(c => c !== correct), 2);
          const answers = shuffleInPlace([correct.toUpperCase(), ...wrong.map(x => x.toUpperCase())]);
          const stems = [
            { q: 'What is the first letter?', h: 'Look at the start of the word.' },
            { q: 'Which letter does the word start with?', h: 'Find the first letter.' },
            { q: 'What letter comes first?', h: 'Point to the first letter.' }
          ];
          const stem = pickOne(stems);
          pages.push(makeMCQ({
            passage: `Word is ${word}.`,
            question: stem.q,
            hint: stem.h,
            answers,
            correctAnswerName: correct.toUpperCase(),
            successMessage: 'Yes! That is the first letter.'
          }));
        } else if (skillId === 'last-sound') {
          const word = pickUniqueValue('last-sound', bank.cvc) || pickOne(bank.cvc);
          const correct = word[word.length - 1].toLowerCase();
          const wrong = pickDistinct(bank.consonants.filter(c => c !== correct), 2);
          const answers = shuffleInPlace([correct.toUpperCase(), ...wrong.map(x => x.toUpperCase())]);
          const stems = [
            { q: 'What is the last letter?', h: 'Look at the end of the word.' },
            { q: 'Which letter does the word end with?', h: 'Find the last letter.' },
            { q: 'What letter comes last?', h: 'Point to the last letter.' }
          ];
          const stem = pickOne(stems);
          pages.push(makeMCQ({
            passage: `Word is ${word}.`,
            question: stem.q,
            hint: stem.h,
            answers,
            correctAnswerName: correct.toUpperCase(),
            successMessage: 'Nice! That is the last letter.'
          }));
        } else if (skillId === 'long-vowel-silent-e') {
          const pair = pickPoolItem('long-vowel-silent-e', bank.silentE) || pickOne(bank.silentE);
          const correct = pair.long;
          const wrong = pickWrongWords([pair.short, ...bank.cvc], 2, new Set([correct]));
          const answers = shuffleInPlace([correct, ...wrong]);
          pages.push(makeMCQ({
            passage: `Short word is ${pair.short}.`,
            question: 'Which word has a long vowel sound?',
            hint: 'Silent e often makes the vowel say its name.',
            answers,
            correctAnswerName: correct,
            successMessage: 'Yes! That word has a long vowel sound.'
          }));
        } else if (skillId === 'sentence-type') {
          const item = pickPoolItem('sentenceTypes', bank.sentenceTypes || []);
          const correct = item ? item.type : 'Statement';
          const types = ['Statement', 'Question', 'Command', 'Exclamation'];
          const wrong = pickDistinct(types.filter(t => t !== correct), 2);
          const answers = shuffleInPlace([correct, ...wrong]);
          pages.push(makeMCQ({
            passage: item ? item.sentence : 'I like pizza.',
            question: 'What kind of sentence is this?',
            hint: 'Look at the end mark and the meaning.',
            answers,
            correctAnswerName: correct,
            successMessage: 'Nice sentence type!'
          }));
        } else if (skillId === 'wh-words') {
          const item = pickPoolItem('whSentences', bank.whSentences || []);
          const answers = shuffleInPlace([item.correct, ...item.wrong]);
          pages.push(makeMCQ({
            passage: item.sentence.replace('____', '_____'),
            question: 'Which word completes the question?',
            hint: 'Who = a person. What = a thing. Where = a place. When = a time. Why = a reason.',
            answers,
            correctAnswerName: item.correct,
            successMessage: 'Great question word!'
          }));
        } else if (skillId === 'contractions') {
          const item = pickPoolItem('contractions', bank.contractions || []);
          const answers = shuffleInPlace([item.contraction, ...item.wrong]);
          pages.push(makeMCQ({
            passage: `Words are ${item.phrase}.`,
            question: 'Choose the contraction.',
            hint: 'A contraction is two words made shorter.',
            answers,
            correctAnswerName: item.contraction,
            successMessage: 'Nice contraction!'
          }));
        } else if (skillId === 'plurals') {
          const item = pickPoolItem('plurals', bank.plurals || []);
          const answers = shuffleInPlace([item.plural, ...item.wrong]);
          pages.push(makeMCQ({
            passage: `One ${item.singular}. Two _____.`,
            question: 'Choose the correct plural.',
            hint: 'Plural means more than one.',
            answers,
            correctAnswerName: item.plural,
            successMessage: 'Great plural!'
          }));
        } else if (skillId === 'irregular-plurals') {
          const item = pickPoolItem('irregular-plurals', bank.irregularPlurals || []);
          const answers = shuffleInPlace([item.plural, ...item.wrong]);
          pages.push(makeMCQ({
            passage: `One ${item.singular}. Two _____.`,
            question: 'Choose the correct irregular plural.',
            hint: 'Some plurals change the word in a special way.',
            answers,
            correctAnswerName: item.plural,
            successMessage: 'Great irregular plural!'
          }));
        } else if (skillId === 'possessive-nouns') {
          const item = pickPoolItem('possessive-nouns', bank.possessiveNouns || []);
          const answers = shuffleInPlace([item.correct, ...item.wrong]);
          pages.push(makeMCQ({
            passage: `This is the ____ ${item.thing}.`,
            question: `Which word shows that the ${item.thing} belongs to the ${item.owner}?`,
            hint: 'A singular possessive often adds apostrophe and s.',
            answers,
            correctAnswerName: item.correct,
            successMessage: 'Nice! That shows ownership.'
          }));
        } else if (skillId === 'conjunctions') {
          const item = pickPoolItem('conjunctions', bank.conjunctions || []);
          const answers = shuffleInPlace([item.correct, ...item.wrong]);
          pages.push(makeMCQ({
            passage: item.sentence.replace('____', '_____'),
            question: 'Which word connects the ideas?',
            hint: 'Try reading the whole sentence.',
            answers,
            correctAnswerName: item.correct,
            successMessage: 'Nice linking word!'
          }));
        } else if (skillId === 'time-order') {
          const item = pickPoolItem('timeOrder', bank.timeOrder || []);
          const answers = shuffleInPlace([item.correct, ...item.wrong]);
          pages.push(makeMCQ({
            passage: item.sentence.replace('____', '_____'),
            question: 'Which time word fits best?',
            hint: 'Time words help us tell the order.',
            answers,
            correctAnswerName: item.correct,
            successMessage: 'Great time-order word!'
          }));
        } else if (skillId === 'context-clues') {
          const item = pickPoolItem('contextClues', bank.contextClues || []);
          const answers = shuffleInPlace([item.correct, ...item.wrong]);
          pages.push(makeMCQ({
            passage: item.passage,
            question: 'What does the new word mean?',
            hint: 'Use the clues in the sentence.',
            answers,
            correctAnswerName: item.correct,
            successMessage: 'Yes! You used context clues.'
          }));
        } else if (skillId === 'multiple-meaning') {
          const item = pickPoolItem('multipleMeaning', bank.multipleMeaning || []);
          const answers = shuffleInPlace([item.correct, ...item.wrong]);
          pages.push(makeMCQ({
            passage: item.context,
            question: 'What does the word mean here?',
            hint: 'Use the sentence to help you.',
            answers,
            correctAnswerName: item.correct,
            successMessage: 'Nice! You used the context.'
          }));
        } else if (skillId === 'shades-of-meaning') {
          const item = pickPoolItem('shadesOfMeaning', bank.shadesOfMeaning || []);
          const answers = shuffleInPlace([...item.answers]);
          pages.push(makeMCQ({
            question: item.question,
            hint: 'Some words are stronger than others.',
            answers,
            correctAnswerName: item.correct,
            successMessage: 'Great word choice!'
          }));
        } else if (skillId === 'shades-order') {
          const item = pickPoolItem('shadesOrder', bank.shadesOrder || []);
          const words = Array.isArray(item.words) ? item.words : [];
          const correctOrder = Array.isArray(item.correct) ? item.correct : words;
          const correct = correctOrder.join(', ');

          // Build two wrong orderings (different permutations).
          const perms = [];
          const base = [...words];
          for (let i = 0; i < 6 && perms.length < 6; i++) {
            const attempt = shuffleInPlace([...base]).join(', ');
            if (!perms.includes(attempt)) perms.push(attempt);
          }
          const wrong = perms.filter(p => p !== correct);
          const wrong1 = wrong[0] || shuffleInPlace([...base]).reverse().join(', ');
          const wrong2 = wrong[1] || shuffleInPlace([...base]).join(', ');
          const answers = shuffleInPlace([correct, wrong1, wrong2]);

          pages.push(makeMCQ({
            passage: `Words are ${words.join(', ')}.`,
            question: item.prompt || 'Put the words in order.',
            hint: 'Think about which word is weaker and which word is stronger.',
            answers,
            correctAnswerName: correct,
            successMessage: 'Nice ordering!'
          }));
        } else if (skillId === 'text-features') {
          const item = pickPoolItem('textFeatures', bank.textFeatures || []);
          const answers = shuffleInPlace([item.correct, ...item.wrong]);
          pages.push(makeMCQ({
            question: item.question,
            hint: 'Text features help us read and learn.',
            answers,
            correctAnswerName: item.correct,
            successMessage: 'Nice text-feature knowledge!'
          }));
        } else if (skillId === 'setting') {
          const items = [
            { passage: 'Ana is at the park. She swings and slides.', correct: 'At the park', wrong: ['At the beach', 'At the store'] },
            { passage: 'Max sits at his desk. He writes with a pencil.', correct: 'At school', wrong: ['At the zoo', 'On a boat'] },
            { passage: 'Ben is in the kitchen. Ben stirs soup.', correct: 'In the kitchen', wrong: ['At the park', 'In the car'] },
            { passage: 'Mia is at the beach. Mia builds a sand castle.', correct: 'At the beach', wrong: ['At school', 'In the snow'] },
            { passage: 'A cat sits on a bed. The room is quiet.', correct: 'In a bedroom', wrong: ['At a zoo', 'In a pool'] },
            { passage: 'A bus stops at a sign. Kids get on.', correct: 'At a bus stop', wrong: ['In a bathtub', 'In a forest'] },
            { passage: 'We stand in line. The teacher opens the door.', correct: 'At school', wrong: ['At the store', 'On a farm'] },
            { passage: 'Dad grills food in the yard. The sun is out.', correct: 'In the yard', wrong: ['In a classroom', 'On a boat'] },
            { passage: 'The fish swims by plants and rocks.', correct: 'In water', wrong: ['In the sky', 'On a bed'] },
            { passage: 'Snow falls. Kids wear coats and hats.', correct: 'Outside in the snow', wrong: ['At the beach', 'In the desert'] }
          ];
          const item = pickPoolItem('setting', items);
          const answers = shuffleInPlace([item.correct, ...item.wrong]);
          pages.push(makeMCQ({
            passage: item.passage,
            question: 'Where does the story happen?',
            hint: 'The setting is where it happens.',
            answers,
            correctAnswerName: item.correct,
            successMessage: 'Yes! You found the setting.'
          }));
        } else if (skillId === 'character') {
          const items = [
            { passage: 'Ben has a kite. Ben runs to make it fly.', correct: 'Ben', wrong: ['The kite', 'The sun'] },
            { passage: 'Mia feeds her cat. The cat purrs.', correct: 'Mia', wrong: ['A bike', 'A book'] },
            { passage: 'Tom kicks the ball. Tom smiles.', correct: 'Tom', wrong: ['The ball', 'The grass'] },
            { passage: 'Sara paints a picture. Sara uses blue.', correct: 'Sara', wrong: ['The paint', 'The paper'] },
            { passage: 'Dad cooks rice. Dad stirs the pot.', correct: 'Dad', wrong: ['The rice', 'The pot'] },
            { passage: 'A dog barks. The dog runs to the door.', correct: 'The dog', wrong: ['The door', 'The yard'] },
            { passage: 'The bird builds a nest. The bird finds sticks.', correct: 'The bird', wrong: ['The nest', 'The sticks'] },
            { passage: 'Lia reads a book. Lia turns each page.', correct: 'Lia', wrong: ['The page', 'The chair'] },
            { passage: 'Mom washes dishes. Mom dries them.', correct: 'Mom', wrong: ['The dishes', 'The sink'] },
            { passage: 'A frog jumps. The frog lands in a pond.', correct: 'The frog', wrong: ['The pond', 'A rock'] },
            { passage: 'A teacher reads a story. The class listens.', correct: 'A teacher', wrong: ['The class', 'A book'] },
            { passage: 'The baby drinks milk. The baby smiles.', correct: 'The baby', wrong: ['Milk', 'A cup'] }
          ];
          const item = pickPoolItem('character', items);
          const answers = shuffleInPlace([item.correct, ...item.wrong]);
          pages.push(makeMCQ({
            passage: item.passage,
            question: 'Who is the main character?',
            hint: 'The main character is who the story is mostly about.',
            answers,
            correctAnswerName: item.correct,
            successMessage: 'Nice! You found the character.'
          }));
        } else if (skillId === 'cause-effect') {
          const items = [
            { passage: 'It is raining. Kai gets an umbrella.', question: 'Why does Kai get an umbrella?', correct: 'Because it is raining', wrong: ['Because it is sunny', 'Because it is snowing'] },
            { passage: 'Lia is hungry. Lia eats an apple.', question: 'Why does Lia eat an apple?', correct: 'Because she is hungry', wrong: ['Because she is thirsty', 'Because she is full'] },
            { passage: 'It is cold. Ben puts on a coat.', question: 'Why does Ben put on a coat?', correct: 'Because it is cold', wrong: ['Because it is hot', 'Because he is swimming'] },
            { passage: 'The floor is wet. Mia walks slowly.', question: 'Why does Mia walk slowly?', correct: 'Because the floor is wet', wrong: ['Because the floor is dry', 'Because she is tired'] },
            { passage: 'Sam drops his pencil. Sam picks it up.', question: 'Why does Sam pick up the pencil?', correct: 'Because he dropped it', wrong: ['Because he wants to write', 'Because he is cleaning up'] },
            { passage: 'The dog is thirsty. The dog drinks water.', question: 'Why does the dog drink water?', correct: 'Because the dog is thirsty', wrong: ['Because the dog is hungry', 'Because the dog is sleepy'] },
            { passage: 'The room is dark. Dad flips the switch. The light turns on.', question: 'Why does Dad flip the switch?', correct: 'Because the room is dark', wrong: ['Because the room is bright', 'Because Dad is hungry'] },
            { passage: 'The soup is hot. I wait before I eat.', question: 'Why do I wait?', correct: 'Because the soup is hot', wrong: ['Because the soup is cold', 'Because I am full'] },
            { passage: 'The bus comes. We want to go to school. We get on.', question: 'Why do we get on the bus?', correct: 'Because we want to go to school', wrong: ['Because we want to go to bed', 'Because we want to stay home'] },
            { passage: 'I lose my hat. I look for it.', question: 'Why do I look for my hat?', correct: 'Because I lost it', wrong: ['Because I found it', 'Because I want a new hat'] },
            { passage: 'The dog barks. Mom opens the door.', question: 'Why does Mom open the door?', correct: 'Because the dog barks', wrong: ['Because the dog is sleeping', 'Because Mom is reading a book'] },
            { passage: 'The room is messy. We clean up.', question: 'Why do we clean up?', correct: 'Because the room is messy', wrong: ['Because the room is clean', 'Because we are going to bed'] }
          ];
          const item = pickPoolItem('cause-effect', items);
          const answers = shuffleInPlace([item.correct, ...item.wrong]);
          pages.push(makeMCQ({
            passage: item.passage,
            question: item.question,
            hint: 'Cause is why. Effect is what happened.',
            answers,
            correctAnswerName: item.correct,
            successMessage: 'Great cause and effect!'
          }));
        } else if (skillId === 'prediction-next') {
          const items = [
            { passage: 'Sam puts bread in the toaster.', correct: 'The bread will toast', wrong: ['Sam will put butter on it', 'Sam will eat the toast'] },
            { passage: 'Mia opens a book and looks at the words.', correct: 'Mia will read', wrong: ['Mia will close the book', 'Mia will turn the page'] },
            { passage: 'The sky gets dark. Rain starts to fall.', correct: 'It will rain more', wrong: ['The sun will come out', 'The rain will stop right away'] },
            { passage: 'A boy ties his shoes. He walks to the door.', correct: 'He will go outside', wrong: ['He will sit back down', 'He will untie his shoes'] },
            { passage: 'Mom cracks eggs into a bowl. Mom stirs.', correct: 'Mom will cook the eggs', wrong: ['Mom will wash the bowl', 'Mom will make toast'] },
            { passage: 'The bus stops. The door opens.', correct: 'People will get on or off', wrong: ['The door will close', 'The bus will drive away'] },
            { passage: 'A dog runs to its bowl. The dog wags its tail.', correct: 'The dog will eat', wrong: ['The dog will take a nap', 'The dog will go outside'] },
            { passage: 'A child yawns. The child gets into bed.', correct: 'The child will sleep', wrong: ['The child will start to play', 'The child will eat lunch'] },
            { passage: 'We put on boots. We walk outside. Rain falls.', correct: 'We will stay dry', wrong: ['We will get wet', 'We will take off our boots'] },
            { passage: 'Dad pours milk. Dad adds cereal.', correct: 'Dad will eat breakfast', wrong: ['Dad will put the cereal away', 'Dad will wash the bowl'] },
            { passage: 'A girl picks up a book. She sits down.', correct: 'She will read', wrong: ['She will stand up', 'She will put the book away'] },
            { passage: 'The bell rings. Kids stand up.', correct: 'Kids will line up', wrong: ['Kids will sit down', 'Kids will start to play'] },
            { passage: 'I feel cold. I get a blanket.', correct: 'I will feel warmer', wrong: ['I will feel colder', 'I will take off the blanket'] }
          ];
          const item = pickPoolItem('prediction-next', items);
          const answers = shuffleInPlace([item.correct, ...item.wrong]);
          pages.push(makeMCQ({
            passage: item.passage,
            question: 'What will happen next?',
            hint: 'Use what you know to make your best guess.',
            answers,
            correctAnswerName: item.correct,
            successMessage: 'Nice prediction!'
          }));
        } else if (skillId === 'vowels-letter') {
          const correct = pickOne(bank.vowels);
          const wrong = pickDistinct(bank.consonants, 2);
          const answers = shuffleInPlace([correct, ...wrong]);
          pages.push(makeMCQ({
            question: 'Which letter is a vowel?',
            hint: 'Vowels are a, e, i, o, u.',
            answers,
            correctAnswerName: correct,
            successMessage: 'Yes! That is a vowel.'
          }));
        } else if (skillId === 'consonant-or-vowel') {
          const consonantPool = bank.consonants.filter(c => c !== 'y');
          const letter = Math.random() < 0.5 ? pickOne(bank.vowels) : pickOne(consonantPool);
          const correctAnswerName = bank.vowels.includes(letter) ? 'Vowel' : 'Consonant';
          pages.push(makeMCQ({
            passage: `Letter is ${letter.toUpperCase()}.`,
            question: 'What kind of letter is this?',
            hint: 'Vowels are a, e, i, o, u. Every other letter is a consonant.',
            answers: shuffleInPlace(['Vowel', 'Consonant', 'Neither']),
            correctAnswerName,
            successMessage: 'Nice!'
          }));
        } else if (skillId === 'vowels-word') {
          const word = pickUniqueValue('vowels-word', bank.cvc) || pickOne(bank.cvc);
          const vowelsIn = Array.from(new Set(word.split('').filter(ch => bank.vowels.includes(ch))));
          const correct = vowelsIn.length ? pickOne(vowelsIn) : 'a';
          const wrong = pickDistinct(bank.vowels, 2, new Set([correct]));
          const answers = shuffleInPlace([correct, ...wrong]);
          const stems = [
            { q: 'Which vowel is in the word?', h: 'Look at the letters in the word.' },
            { q: 'Which vowel do you see?', h: 'Vowels are a, e, i, o, u.' },
            { q: 'What vowel is inside the word?', h: 'Find the vowel letter.' }
          ];
          const stem = pickOne(stems);
          pages.push(makeMCQ({
            passage: `Word is ${word}.`,
            question: stem.q,
            hint: stem.h,
            answers,
            correctAnswerName: correct,
            successMessage: 'Nice! You found the vowel.'
          }));
        } else if (skillId === 'syllables-count') {
          const choicePool = pickPoolItem('syllables-count', [...bank.twoSyllables, ...bank.threeSyllables]) || shuffleInPlace([...bank.twoSyllables, ...bank.threeSyllables]).slice(0, 1)[0];
          const correct = String(choicePool.syllables);
          const answers = shuffleInPlace(['1', '2', '3'].filter(x => x !== correct).slice(0, 2).concat([correct]));
          const word = String(choicePool.word || '').trim() || 'word';
          const stems = [
            { q: `How many syllables are in "${word}"?`, h: 'Clap the parts you hear.' },
            { q: `How many syllables does "${word}" have?`, h: 'Say it slowly and clap.' }
          ];
          const stem = pickOne(stems);
          pages.push(makeMCQ({
            passage: `Word: ${word}.`,
            question: stem.q,
            hint: stem.h,
            answers,
            correctAnswerName: correct,
            successMessage: 'Great counting!'
          }));
        } else if (skillId === 'rhyming-choose') {
          const family = pickPoolItem('rhymes', bank.rhymes);
          const base = pickOne(family);
          const rhymes = pickDistinct(family, 1, new Set([base]));
          const correct = rhymes[0];
          const wrong = pickDistinct(bank.cvc, 2, new Set([base, correct]));
          const answers = shuffleInPlace([correct, ...wrong]);
          const stems = [
            { q: `Which word rhymes with ${base}?`, h: 'Rhyming words have the same ending sound.' },
            { q: `Find a word that rhymes with ${base}.`, h: 'Listen for the same ending sound.' },
            { q: `Which word sounds like ${base} at the end?`, h: 'Same ending sound = rhyme.' }
          ];
          const stem = pickOne(stems);
          pages.push(makeMCQ({
            passage: `Word is ${base}.`,
            question: stem.q,
            hint: stem.h,
            answers,
            correctAnswerName: correct,
            successMessage: 'Yes! Those words rhyme.'
          }));
        } else if (skillId === 'rhyming-odd') {
          const richerFamilies = (bank.rhymes || []).filter(f => Array.isArray(f) && f.length >= 3);
          const family = pickPoolItem('rhymes-odd', richerFamilies) || pickPoolItem('rhymes', bank.rhymes) || pickOne(bank.rhymes);
          const base = pickOne(family);
          const rhymers = pickDistinct(family, 2, new Set([base]));
          const odd = pickDistinct(bank.cvc.filter(w => !family.includes(w)), 1, new Set([base, ...rhymers]))[0] ||
            pickDistinct(bank.cvc, 1, new Set([base, ...rhymers]))[0];
          const answers = shuffleInPlace([...rhymers, odd]);
          const stems = [
            { q: `Which word does not rhyme with ${base}?`, h: 'Two words rhyme with the base word.' },
            { q: `Find the word that does not rhyme.`, h: `Two words rhyme with ${base}.` },
            { q: `Which word has a different ending sound?`, h: `The base word is ${base}.` }
          ];
          const stem = pickOne(stems);
          pages.push(makeMCQ({
            passage: `Word is ${base}.`,
            question: stem.q,
            hint: stem.h,
            answers,
            correctAnswerName: odd,
            successMessage: 'Yes! That one does not rhyme.'
          }));
        } else if (skillId === 'start-letter') {
          const letter = pickUniqueValue('start-letter-letter', bank.consonants) || pickOne(bank.consonants);
          const candidates = bank.cvc.filter(w => (w[0] || '').toLowerCase() === letter.toLowerCase());
          let correct = pickUniqueValue(`start-letter-word-${letter}`, candidates);
          if (!correct) correct = candidates.length ? pickOne(candidates) : pickOne(bank.cvc);
          const wrong = pickDistinct(bank.cvc.filter(w => (w[0] || '').toLowerCase() !== letter), 2, new Set([correct]));
          const answers = shuffleInPlace([correct, ...wrong]);
          const stems = [
            { q: `Which word starts with ${letter.toUpperCase()}?`, h: 'Look at the first letter.' },
            { q: `Pick the word that begins with ${letter.toUpperCase()}.`, h: 'Begins means starts.' },
            { q: `Find a word that starts with ${letter.toUpperCase()}.`, h: 'Check the first letter in each word.' }
          ];
          const stem = pickOne(stems);
          pages.push(makeMCQ({
            question: stem.q,
            hint: stem.h,
            answers,
            correctAnswerName: correct,
            successMessage: 'Great! You found the starting letter.'
          }));
        } else if (skillId === 'end-letter') {
          const letterPool = ['t', 'g', 'p', 'n', 'm', 'd', 'b', 'r', 's'];
          const letter = pickUniqueValue('end-letter-letter', letterPool) || pickOne(letterPool);
          const candidates = bank.cvc.filter(w => w.endsWith(letter.toLowerCase()));
          let correct = pickUniqueValue(`end-letter-word-${letter}`, candidates);
          if (!correct) correct = candidates.length ? pickOne(candidates) : pickOne(bank.cvc);
          const wrong = pickDistinct(bank.cvc.filter(w => !w.endsWith(letter)), 2, new Set([correct]));
          const answers = shuffleInPlace([correct, ...wrong]);
          const stems = [
            { q: `Which word ends with ${letter.toUpperCase()}?`, h: 'Look at the last letter.' },
            { q: `Pick the word that ends with ${letter.toUpperCase()}.`, h: 'Ends means last letter.' },
            { q: `Find a word that ends with ${letter.toUpperCase()}.`, h: 'Check the last letter in each word.' }
          ];
          const stem = pickOne(stems);
          pages.push(makeMCQ({
            question: stem.q,
            hint: stem.h,
            answers,
            correctAnswerName: correct,
            successMessage: 'Nice ending letter!'
          }));
        } else if (skillId === 'digraph-find') {
          const digraph = pickUniqueValue('digraph-find-target', ['sh', 'ch', 'th']) || pickOne(['sh', 'ch', 'th']);
          const correctWord = pickUniqueValue(`digraph-find-${digraph}`, bank.digraphs[digraph]) || pickOne(bank.digraphs[digraph]);
          const otherDigraphs = ['sh', 'ch', 'th'].filter(d => d !== digraph);
          const wrongDigraph = pickUniqueValue('digraph-find-wrong-digraph', otherDigraphs) || pickOne(otherDigraphs);
          const wrong1 = pickUniqueValue(`digraph-find-${wrongDigraph}`, bank.digraphs[wrongDigraph]) || pickOne(bank.digraphs[wrongDigraph]);
          const wrong2 = pickUniqueValue('digraph-find-nodigraph', bank.cvc.filter(w => !/(sh|ch|th)/i.test(w))) || pickOne(bank.cvc);
          const answers = shuffleInPlace([correctWord, wrong1, wrong2]);
          const stems = [
            { q: `Which word has ${digraph.toUpperCase()}?`, h: `Look for the letters ${digraph}.` },
            { q: `Find the word with ${digraph.toUpperCase()}.`, h: `Scan for ${digraph}.` },
            { q: `Which word contains ${digraph.toUpperCase()}?`, h: `Two letters make one sound.` }
          ];
          const stem = pickOne(stems);
          pages.push(makeMCQ({
            question: stem.q,
            hint: stem.h,
            answers,
            correctAnswerName: correctWord,
            successMessage: `Yes! That word has ${digraph.toUpperCase()}.`
          }));
        } else if (skillId === 'digraph-choose') {
          const templates = [
            { pattern: '__ip', word: 'ship', correct: 'sh' },
            { pattern: '__ip', word: 'chip', correct: 'ch' },
            { pattern: '__op', word: 'shop', correct: 'sh' },
            { pattern: '__op', word: 'chop', correct: 'ch' },
            { pattern: '__in', word: 'thin', correct: 'th' },
            { pattern: '__is', word: 'this', correct: 'th' },
            { pattern: '__en', word: 'then', correct: 'th' },
            { pattern: '__at', word: 'chat', correct: 'ch' }
          ];
          const item = pickPoolItem('digraph-choose', templates);
          const correct = item.correct;
          const wrong = pickDistinct(['sh', 'ch', 'th'], 2, new Set([correct]));
          const answers = shuffleInPlace([correct, ...wrong]);
          pages.push(makeMCQ({
            passage: `Complete the word. ${item.pattern}`,
            question: 'Choose the correct digraph.',
            hint: 'A digraph is two letters that make one sound.',
            answers,
            correctAnswerName: correct,
            successMessage: `Nice work. You made the word ${item.word}.`
          }));
        } else if (skillId === 'blends-start') {
          const blend = pickUniqueValue('blends-start-target', bank.blends) || pickOne(bank.blends);
          const correct = pickUniqueValue(`blends-start-${blend}`, bank.blendWords[blend] || ['stop']) || pickOne(bank.blendWords[blend] || ['stop']);
          const wrong = pickDistinct(bank.cvc, 2, new Set([correct]));
          const answers = shuffleInPlace([correct, ...wrong]);
          const stems = [
            { q: `Which word starts with ${blend.toUpperCase()}?`, h: 'Look at the first two letters.' },
            { q: `Pick the word that begins with ${blend.toUpperCase()}.`, h: 'A blend has two consonants.' },
            { q: `Find a word with the blend ${blend.toUpperCase()}.`, h: 'Look at the start of the word.' }
          ];
          const stem = pickOne(stems);
          pages.push(makeMCQ({
            question: stem.q,
            hint: stem.h,
            answers,
            correctAnswerName: correct,
            successMessage: `Yes! That word starts with ${blend.toUpperCase()}.`
          }));
        } else if (skillId === 'short-vowel-fill') {
          const templates = [
            { pattern: 'c_t', correct: 'a', word: 'cat' },
            { pattern: 'd_g', correct: 'o', word: 'dog' },
            { pattern: 'b_g', correct: 'u', word: 'bug' },
            { pattern: 'h_n', correct: 'e', word: 'hen' },
            { pattern: 'p_g', correct: 'i', word: 'pig' },
            { pattern: 'm_p', correct: 'a', word: 'map' },
            { pattern: 's_n', correct: 'u', word: 'sun' },
            { pattern: 'f_n', correct: 'i', word: 'fin' },
            { pattern: 'r_t', correct: 'a', word: 'rat' },
            { pattern: 'b_d', correct: 'e', word: 'bed' },
            { pattern: 'c_p', correct: 'a', word: 'cap' },
            { pattern: 'h_t', correct: 'a', word: 'hat' }
          ];
          const item = pickPoolItem('short-vowel-fill', templates);
          const correct = item.correct;
          const wrong = pickDistinct(bank.vowels, 2, new Set([correct]));
          const answers = shuffleInPlace([correct, ...wrong]);
          pages.push(makeMCQ({
            passage: `Complete the word. ${item.pattern}`,
            question: 'Which vowel makes a real word?',
            hint: 'Try each vowel.',
            answers,
            correctAnswerName: correct,
            successMessage: `Yes! ${item.word} is a real word.`
          }));
        } else if (skillId === 'silent-e') {
          const pair = pickPoolItem('silent-e', bank.silentE);
          const correct = pair.long;
          const wrong = pickDistinct([pair.short, ...bank.cvc], 2, new Set([correct]));
          const answers = shuffleInPlace([correct, ...wrong]);
          pages.push(makeMCQ({
            passage: `Short word is ${pair.short}.`,
            question: 'Which word has a silent e?',
            hint: 'Silent e is the last letter e.',
            answers,
            correctAnswerName: correct,
            successMessage: 'Yes! That word ends with silent e.'
          }));
        } else if (skillId === 'sight-blank') {
          const item = pickPoolItem('sightWordSentences', bank.sightWordSentences || []);
          const focus = item.correct;
          const practicePassage = buildSightWordPracticePassage(focus, bank);
          pages.push({
            type: 'read',
            sentence: practicePassage,
            words: null,
            sightWordFocus: focus,
            requireSightWordTap: false,
            readingTip: 'Sight words are words we memorize. Tap the sight word to hear it.'
          });

          const answers = shuffleInPlace([...item.choices]);
          pages.push(makeMCQ({
            passage: item.sentence.replace('___', '____'),
            question: 'Which sight word completes the sentence?',
            hint: 'Use the sight word you just practiced.',
            answers,
            correctAnswerName: focus,
            successMessage: 'Great! That sight word makes the sentence work.'
          }));
        } else if (skillId === 'main-idea') {
          const passages = [
            { passage: 'Sam is hot. Sam gets a cold drink. Sam feels better.', correct: 'Getting a cold drink', wrong: ['Going to bed', 'Catching a fish'] },
            { passage: 'Mia goes to the bakery. Mia smells buns. Mia picks a sweet treat.', correct: 'Choosing a sweet treat', wrong: ['Riding a train', 'Cleaning a room'] },
            { passage: 'Ben has a kite. Ben runs. The kite goes up high.', correct: 'Flying a kite', wrong: ['Washing dishes', 'Taking a nap'] },
            { passage: 'A dog is wet. The dog shakes. Water goes everywhere.', correct: 'A wet dog shakes', wrong: ['A dog takes a bath', 'A dog runs in the yard'] },
            { passage: 'Kim plants a seed. Kim waters it. A small plant grows.', correct: 'Growing a plant', wrong: ['Breaking a toy', 'Losing a shoe'] },
            { passage: 'Lia is hungry. Lia makes a sandwich. Lia eats it.', correct: 'Making a sandwich', wrong: ['Catching a bug', 'Painting a wall'] },
            { passage: 'Tom has a book. Tom reads each page. Tom learns new facts.', correct: 'Reading a book', wrong: ['Driving a car', 'Jumping in a pool'] },
            { passage: 'We see dark clouds. We hear rain. We go inside.', correct: 'Going inside when it rains', wrong: ['Going to the beach', 'Making popcorn'] },
            { passage: 'The cat wants food. The cat meows. The cat eats.', correct: 'A cat wants food', wrong: ['A cat takes a nap', 'A cat plays with a toy'] },
            { passage: 'Ana paints a picture. Ana uses blue and red. Ana smiles.', correct: 'Painting a picture', wrong: ['Fixing a bike', 'Building a house'] },
            { passage: 'Dad cooks rice. The rice gets soft. We eat dinner.', correct: 'Making dinner', wrong: ['Taking a test', 'Going on a boat'] },
            { passage: 'A boy finds a lost mitten. He gives it back. The owner says thank you.', correct: 'Returning a lost item', wrong: ['Hiding a toy', 'Eating candy'] },
            { passage: 'A girl has a pet fish. She feeds it. The fish swims fast.', correct: 'Feeding a fish', wrong: ['Buying a fish', 'Cleaning a tank'] },
            { passage: 'We go to the park. We swing. We slide. We laugh.', correct: 'Playing at the park', wrong: ['Cooking soup', 'Cleaning a car'] },
            { passage: 'A boy is cold. He puts on a coat. He feels warm.', correct: 'Putting on a coat', wrong: ['Eating a pizza', 'Painting a wall'] },
            { passage: 'Mom bakes a cake. It smells sweet. We taste it.', correct: 'Baking a cake', wrong: ['Cooking soup', 'Riding a bus'] },
            { passage: 'A child drops a pencil. The child picks it up.', correct: 'Picking up a pencil', wrong: ['Throwing a ball', 'Making a nest'] },
            { passage: 'A dog digs in the sand. The dog finds a stick. The dog runs with the stick.', correct: 'Finding a stick', wrong: ['Reading a map', 'Taking a nap'] },
            { passage: 'We brush our teeth. We wash our face. We go to bed.', correct: 'Getting ready for bed', wrong: ['Going to a zoo', 'Building a boat'] },
            { passage: 'A baby cries. Dad hugs the baby. The baby stops crying.', correct: 'Helping a baby feel better', wrong: ['Reading a book', 'Eating lunch'] },
            { passage: 'A girl reads a sign. The sign says STOP. The girl stops.', correct: 'Reading a sign', wrong: ['Making a salad', 'Catching a bug'] },
            { passage: 'It rains. We use an umbrella. We stay dry.', correct: 'Staying dry in the rain', wrong: ['Melting ice cream', 'Planting a tree'] }
          ];
          const item = pickPoolItem('main-idea', passages);
          const answers = shuffleInPlace([item.correct, ...item.wrong]);
          pages.push(makeMCQ({
            passage: item.passage,
            question: 'What is the main idea?',
            hint: 'What is it mostly about?',
            answers,
            correctAnswerName: item.correct,
            successMessage: 'Yes! You found the main idea.'
          }));
        } else if (skillId === 'sequence-first') {
          const items = [
            { passage: 'First, I wash my hands. Next, I eat pizza. Last, I clean up.', question: 'What happened first?', correct: 'I wash my hands', wrong: ['I eat pizza', 'I clean up'] },
            { passage: 'First, I open the book. Next, I read the words. Last, I close the book.', question: 'What happened last?', correct: 'I close the book', wrong: ['I open the book', 'I read the words'] },
            { passage: 'First, I put on socks. Next, I put on shoes. Last, I go outside.', question: 'What happened next?', correct: 'I put on shoes', wrong: ['I go outside', 'I put on socks'] },
            { passage: 'First, I get a bowl. Next, I pour cereal. Last, I eat.', question: 'What happened first?', correct: 'I get a bowl', wrong: ['I pour cereal', 'I eat'] },
            { passage: 'First, I pick up my toys. Next, I put them in a box. Last, I sit down.', question: 'What happened last?', correct: 'I sit down', wrong: ['I pick up my toys', 'I put them in a box'] },
            { passage: 'First, I water the plant. Next, I wait. Last, I see a sprout.', question: 'What happened next?', correct: 'I wait', wrong: ['I water the plant', 'I see a sprout'] },
            { passage: 'First, I mix the batter. Next, I bake it. Last, I taste the cake.', question: 'What happened last?', correct: 'I taste the cake', wrong: ['I mix the batter', 'I bake it'] },
            { passage: 'First, we line up. Next, we walk to class. Last, we sit down.', question: 'What happened first?', correct: 'We line up', wrong: ['We walk to class', 'We sit down'] },
            { passage: 'First, I get my coat. Next, I zip it. Last, I go out.', question: 'What happened next?', correct: 'I zip it', wrong: ['I go out', 'I get my coat'] },
            { passage: 'First, I find a pencil. Next, I write my name. Last, I color.', question: 'What happened next?', correct: 'I write my name', wrong: ['I color', 'I find a pencil'] },
            { passage: 'First, I fill a cup. Next, I take a sip. Last, I put it down.', question: 'What happened last?', correct: 'I put it down', wrong: ['I fill a cup', 'I take a sip'] },
            { passage: 'First, we wash the apples. Next, we cut them. Last, we eat them.', question: 'What happened first?', correct: 'We wash the apples', wrong: ['We cut them', 'We eat them'] },
            { passage: 'First, I open the door. Next, I step in. Last, I shut the door.', question: 'What happened last?', correct: 'I shut the door', wrong: ['I open the door', 'I step in'] },
            { passage: 'First, I pick a book. Next, I read a page. Last, I put it away.', question: 'What happened next?', correct: 'I read a page', wrong: ['I put it away', 'I pick a book'] },
            { passage: 'First, we pack snacks. Next, we get on the train. Last, we arrive.', question: 'What happened next?', correct: 'We get on the train', wrong: ['We arrive', 'We pack snacks'] },
            { passage: 'First, I see a mess. Next, I clean it up. Last, the room looks neat.', question: 'What happened first?', correct: 'I see a mess', wrong: ['I clean it up', 'The room looks neat'] }
          ];
          const item = pickPoolItem('sequence-first', items);
          const answers = shuffleInPlace([item.correct, ...item.wrong]);
          pages.push(makeMCQ({
            passage: item.passage,
            question: item.question,
            hint: 'Use the time words first, next, last.',
            answers,
            correctAnswerName: item.correct,
            successMessage: 'Nice sequencing!'
          }));
        } else if (skillId === 'inference-feeling') {
          const items = [
            { passage: 'Ben smiles. Ben laughs. Ben plays.', correct: 'Happy', wrong: ['Sad', 'Angry'] },
            { passage: 'Lia drops her ice cream. Lia cries.', correct: 'Sad', wrong: ['Happy', 'Proud'] },
            { passage: 'Tom hears a loud clap. Tom jumps back.', correct: 'Scared', wrong: ['Excited', 'Sleepy'] },
            { passage: 'Kai jumps up and down. Kai claps.', correct: 'Excited', wrong: ['Bored', 'Sleepy'] },
            { passage: 'Mia hugs her new puppy. Mia smiles.', correct: 'Happy', wrong: ['Angry', 'Scared'] },
            { passage: 'A boy cannot find his backpack. He looks and looks.', correct: 'Worried', wrong: ['Proud', 'Happy'] },
            { passage: 'A girl wins a ribbon. She smiles big.', correct: 'Proud', wrong: ['Sad', 'Scared'] },
            { passage: 'A child yawns. The child rubs their eyes.', correct: 'Sleepy', wrong: ['Angry', 'Excited'] },
            { passage: 'A boy loses his turn. He frowns. He crosses his arms.', correct: 'Angry', wrong: ['Happy', 'Proud'] },
            { passage: 'The class is loud. A boy covers his ears.', correct: 'Upset', wrong: ['Proud', 'Excited'] },
            { passage: 'A girl gets a gift. She smiles. She says thank you.', correct: 'Happy', wrong: ['Angry', 'Sleepy'] },
            { passage: 'A boy drops his lunch. He frowns.', correct: 'Sad', wrong: ['Proud', 'Excited'] },
            { passage: 'A balloon pops. A child jumps back.', correct: 'Scared', wrong: ['Sleepy', 'Proud'] },
            { passage: 'A kid solves the hard puzzle. The kid smiles.', correct: 'Proud', wrong: ['Angry', 'Scared'] }
          ];
          const item = pickPoolItem('inference-feeling', items);
          const answers = shuffleInPlace([item.correct, ...item.wrong]);
          pages.push(makeMCQ({
            passage: item.passage,
            question: 'How does the character feel?',
            hint: 'Use the clues in the story.',
            answers,
            correctAnswerName: item.correct,
            successMessage: 'Yes! You used clues to infer the feeling.'
          }));
        } else if (skillId === 'reality-fiction') {
          const items = [
            { question: 'Which could happen in real life?', correct: 'A dog eats food.', wrong: ['A dog reads a book.', 'A dog drives a car.'] },
            { question: 'Which could happen in real life?', correct: 'A child drinks water.', wrong: ['A child walks on the ceiling.', 'A child swims in the sky.'] },
            { question: 'Which could happen in real life?', correct: 'A bird builds a nest.', wrong: ['A bird writes a letter.', 'A bird cooks soup.'] },
            { question: 'Which could happen in real life?', correct: 'A fish swims in water.', wrong: ['A fish rides a bike.', 'A fish talks on the phone.'] },
            { question: 'Which could happen in real life?', correct: 'A cat sleeps on a bed.', wrong: ['A cat paints a house.', 'A cat drives a bus.'] },
            { question: 'Which could happen in real life?', correct: 'A child reads a book.', wrong: ['A child walks through a wall.', 'A child floats in the air.'] },
            { question: 'Which could happen in real life?', correct: 'Rain falls from clouds.', wrong: ['Rain falls from a lamp.', 'Rain falls from a shoe.'] },
            { question: 'Which could happen in real life?', correct: 'A teacher writes on a board.', wrong: ['A teacher writes on the ceiling.', 'A board writes a story.'] },
            { question: 'Which could happen in real life?', correct: 'A child ties a shoe.', wrong: ['A shoe ties itself.', 'A child ties a cloud.'] },
            { question: 'Which could happen in real life?', correct: 'A dog barks at a door.', wrong: ['A door barks at a dog.', 'A door runs outside.'] },
            { question: 'Which could happen in real life?', correct: 'Snow falls in winter.', wrong: ['Snow falls from a spoon.', 'Snow falls in a bed.'] },
            { question: 'Which could happen in real life?', correct: 'A baby drinks milk.', wrong: ['A baby drives a bus.', 'A bus drinks milk.'] }
          ];
          const item = pickPoolItem('reality-fiction', items);
          const answers = shuffleInPlace([item.correct, ...item.wrong]);
          pages.push(makeMCQ({
            question: item.question,
            hint: 'Real life means it can really happen.',
            answers,
            correctAnswerName: item.correct,
            successMessage: 'Good thinking!'
          }));
        } else if (skillId === 'character-actions') {
          const item = pickPoolItem('characterActions', bank.characterActions || []);
          const answers = shuffleInPlace([item.correct, ...item.wrong]);
          const stems = [
            { h: 'Use the action or words to help you.' },
            { h: 'What the character does tells what they are like.' },
            { h: 'Look for clues in the passage.' }
          ];
          const stem = pickOne(stems);
          pages.push(makeMCQ({
            passage: item.passage,
            question: item.question || 'What is the character like?',
            hint: stem.h,
            answers,
            correctAnswerName: item.correct,
            successMessage: 'Nice! You used clues about the character.'
          }));
        } else if (skillId === 'problem-solution') {
          const item = pickPoolItem('problemSolution', bank.problemSolution || []);
          const ask = pickUniqueValue('problem-solution-ask', ['problem', 'solution']) || 'problem';
          const isProblem = ask === 'problem';
          const correct = isProblem ? item.problem : item.solution;
          const wrong = isProblem ? item.wrongProblem : item.wrongSolution;
          const answers = shuffleInPlace([correct, ...(wrong || []).slice(0, 2)]);
          const stems = isProblem
            ? [
              { q: 'What is the problem?', h: 'Problem means what is wrong.' },
              { q: 'What goes wrong first?', h: 'Find the trouble in the passage.' },
              { q: 'What is happening that needs help?', h: 'Look for the problem.' }
            ]
            : [
              { q: 'What is the solution?', h: 'Solution means what fixes the problem.' },
              { q: 'What does the character do to fix it?', h: 'Find what helps.' },
              { q: 'What happens to help the problem?', h: 'Look for the solution.' }
            ];
          const stem = pickOne(stems);
          pages.push(makeMCQ({
            passage: item.passage,
            question: stem.q,
            hint: stem.h,
            answers,
            correctAnswerName: correct,
            successMessage: 'Great! You found the problem/solution.'
          }));
        } else if (skillId === 'best-title') {
          const item = pickPoolItem('bestTitle', bank.bestTitle || []);
          const answers = shuffleInPlace([item.correct, ...item.wrong]);
          const stems = [
            { q: 'What is the best title for the passage?', h: 'A title tells what the passage is mostly about.' },
            { q: 'Choose the best title.', h: 'Pick the title that matches the main idea.' },
            { q: 'Which title fits best?', h: 'Think: what is it mostly about?' }
          ];
          const stem = pickOne(stems);
          pages.push(makeMCQ({
            passage: item.passage,
            question: stem.q,
            hint: stem.h,
            answers,
            correctAnswerName: item.correct,
            successMessage: 'Nice! That title matches the passage.'
          }));
        } else if (skillId === 'supporting-detail') {
          const item = pickPoolItem('supportingDetail', bank.supportingDetail || []);
          const answers = shuffleInPlace([item.correct, ...item.wrong]);
          pages.push(makeMCQ({
            passage: item.passage,
            question: item.question || 'Which detail is in the passage?',
            hint: 'Read the passage again and find the exact detail.',
            answers,
            correctAnswerName: item.correct,
            successMessage: 'Great! You found a detail from the passage.'
          }));
        } else if (skillId === 'punctuation-endmark') {
          const items = [
            { sentence: 'What do you want', correct: '?' },
            { sentence: 'Where is my hat', correct: '?' },
            { sentence: 'Can you help me', correct: '?' },
            { sentence: 'I like pizza', correct: '.' },
            { sentence: 'We ride the train', correct: '.' },
            { sentence: 'The fish is fresh', correct: '.' },
            { sentence: 'Stop', correct: '!' },
            { sentence: 'Watch out', correct: '!' },
            { sentence: 'That is amazing', correct: '!' }
          ];
          const item = pickPoolItem('punctuation-endmark', items);
          const answers = shuffleInPlace(['.', '?', '!']);
          pages.push(makeMCQ({
            passage: item.sentence,
            question: 'Choose the best end mark.',
            hint: 'Questions use ?  Statements use .  Strong feelings use !',
            answers,
            correctAnswerName: item.correct,
            successMessage: 'Nice punctuation!'
          }));
        } else if (skillId === 'parts-noun') {
          const correct = pickUniqueValue('parts-noun', bank.nouns) || pickOne(bank.nouns);
          const wrong = [pickOne(bank.verbs), pickOne(bank.adjectives)];
          const answers = shuffleInPlace([correct, ...wrong]);
          pages.push(makeMCQ({
            question: 'Which word is a noun?',
            hint: 'A noun is a person, place, or thing.',
            answers,
            correctAnswerName: correct,
            successMessage: 'Yes! That is a noun.'
          }));
        } else if (skillId === 'parts-verb') {
          const correct = pickUniqueValue('parts-verb', bank.verbs) || pickOne(bank.verbs);
          const wrong = [pickOne(bank.nouns), pickOne(bank.adjectives)];
          const answers = shuffleInPlace([correct, ...wrong]);
          pages.push(makeMCQ({
            question: 'Which word is an action verb?',
            hint: 'Action verbs are doing words.',
            answers,
            correctAnswerName: correct,
            successMessage: 'Yes! That is an action.'
          }));
        } else if (skillId === 'parts-adj') {
          const correct = pickUniqueValue('parts-adj', bank.adjectives) || pickOne(bank.adjectives);
          const wrong = [pickOne(bank.nouns), pickOne(bank.verbs)];
          const answers = shuffleInPlace([correct, ...wrong]);
          pages.push(makeMCQ({
            question: 'Which word is an adjective?',
            hint: 'Adjectives describe.',
            answers,
            correctAnswerName: correct,
            successMessage: 'Yes! That word describes.'
          }));
        } else if (skillId === 'noun-type') {
          const types = [
            { label: 'Person', key: 'person' },
            { label: 'Place', key: 'place' },
            { label: 'Animal', key: 'animal' },
            { label: 'Thing', key: 'thing' }
          ];
          const chosenType = pickPoolItem('noun-type-type', types) || pickOne(types);
          const word = pickUniqueValue(`noun-type-word-${chosenType.key}`, bank.nounTypes?.[chosenType.key] || bank.nouns) || pickOne(bank.nouns);
          const wrong = pickDistinct(types.map(t => t.label).filter(label => label !== chosenType.label), 2);
          const answers = shuffleInPlace([chosenType.label, ...wrong]);
          pages.push(makeMCQ({
            passage: `Word is ${word}.`,
            question: 'What kind of noun is this word?',
            hint: 'Nouns can be people, places, animals, or things.',
            answers,
            correctAnswerName: chosenType.label,
            successMessage: 'Nice noun sorting!'
          }));
        } else if (skillId === 'adjectives-compare') {
          const item = pickPoolItem('adjectiveDegrees', bank.adjectiveDegrees) || pickOne(bank.adjectiveDegrees);
          const mode = pickUniqueValue('adjectives-compare-mode', ['comparative', 'superlative']) || pickOne(['comparative', 'superlative']);
          const correct = mode === 'comparative' ? item.comparative : item.superlative;
          const wrongPool = mode === 'comparative' ? [item.base, item.superlative] : [item.base, item.comparative];
          const answers = shuffleInPlace([correct, ...wrongPool]).slice(0, 3);
          const stems = mode === 'comparative'
            ? [
              { q: 'Choose the word that means more.', h: 'Comparative words often end with -er.' },
              { q: 'Choose the comparative form.', h: 'Comparative = comparing two things.' },
              { q: 'Which word means more than the base word?', h: 'Look for -er.' }
            ]
            : [
              { q: 'Choose the word that means the most.', h: 'Superlative words often end with -est.' },
              { q: 'Choose the superlative form.', h: 'Superlative = the most of three or more.' },
              { q: 'Which word means the most of all?', h: 'Look for -est.' }
            ];
          const stem = pickOne(stems);
          pages.push(makeMCQ({
            passage: `Base word is ${item.base}.`,
            question: stem.q,
            hint: stem.h,
            answers,
            correctAnswerName: correct,
            successMessage: 'Great adjective form!'
          }));
        } else if (skillId === 'unscramble-sentence') {
          const item = pickPoolItem('unscramble-sentence', bank.unscrambleSentences) || pickOne(bank.unscrambleSentences);
          const scrambled = shuffleInPlace([...item.words]).join(' ');
          const answers = shuffleInPlace([item.correct, ...item.wrong]);
          pages.push(makeMCQ({
            passage: `Words are ${scrambled}.`,
            question: 'Which sentence uses the words in the best order?',
            hint: 'A sentence starts with a capital letter and makes sense.',
            answers,
            correctAnswerName: item.correct,
            successMessage: 'Nice sentence building!'
          }));
        } else if (skillId === 'articles-a-an') {
          const items = [
            { sentence: 'I see ___ apple.', correct: 'an', wrong: ['a', 'the'] },
            { sentence: 'I see ___ dog.', correct: 'a', wrong: ['an', 'the'] },
            { sentence: 'I eat ___ orange.', correct: 'an', wrong: ['a', 'the'] },
            { sentence: 'I have ___ egg.', correct: 'an', wrong: ['a', 'the'] },
            { sentence: 'I want ___ hat.', correct: 'a', wrong: ['an', 'the'] },
            { sentence: 'I see ___ inchworm.', correct: 'an', wrong: ['a', 'the'] },
            { sentence: 'I draw ___ octopus.', correct: 'an', wrong: ['a', 'the'] },
            { sentence: 'I see ___ rabbit.', correct: 'a', wrong: ['an', 'the'] },
            { sentence: 'I eat ___ sandwich.', correct: 'a', wrong: ['an', 'the'] }
          ];
          const item = pickPoolItem('articles-a-an', items);
          const answers = shuffleInPlace([item.correct, ...item.wrong]);
          pages.push(makeMCQ({
            passage: item.sentence.replace('___', '____'),
            question: 'Choose a or an.',
            hint: 'Use an before a vowel sound.',
            answers,
            correctAnswerName: item.correct,
            successMessage: 'Nice article choice!'
          }));
        } else if (skillId === 'prepositions') {
          const items = [
            { passage: 'The cat is ____ the box.', correct: 'in', wrong: ['on', 'under'] },
            { passage: 'The book is ____ the table.', correct: 'on', wrong: ['in', 'under'] },
            { passage: 'The ball is ____ the chair.', correct: 'under', wrong: ['on', 'in'] },
            { passage: 'The frog is ____ the log.', correct: 'on', wrong: ['under', 'in'] },
            { passage: 'The dog is ____ the bed.', correct: 'on', wrong: ['under', 'in'] },
            { passage: 'The coin is ____ the cup.', correct: 'in', wrong: ['on', 'under'] },
            { passage: 'The shoes are ____ the bed.', correct: 'under', wrong: ['on', 'in'] },
            { passage: 'The cat is ____ the chair.', correct: 'under', wrong: ['on', 'in'] },
            { passage: 'The fish is ____ the water.', correct: 'in', wrong: ['on', 'under'] },
            { passage: 'The bird is ____ the tree.', correct: 'in', wrong: ['under', 'on'] },
            { passage: 'The cup is ____ the shelf.', correct: 'on', wrong: ['in', 'under'] },
            { passage: 'The toy is ____ the rug.', correct: 'under', wrong: ['on', 'in'] }
          ];
          const item = pickPoolItem('prepositions', items);
          const answers = shuffleInPlace([item.correct, ...item.wrong]);
          pages.push(makeMCQ({
            passage: item.passage,
            question: 'Which word shows where?',
            hint: 'Prepositions tell where something is.',
            answers,
            correctAnswerName: item.correct,
            successMessage: 'Great! That word shows where.'
          }));
        } else if (skillId === 'point-of-view') {
          const items = [
            { passage: 'I go to the park. I play.', correct: 'I, first person', wrong: ['He, third person', 'They, third person'] },
            { passage: 'She has a dog. She runs.', correct: 'She, third person', wrong: ['I, first person', 'We, first person'] },
            { passage: 'We ride the train. We sit down.', correct: 'We, first person', wrong: ['He, third person', 'She, third person'] },
            { passage: 'They walk to the store. They buy milk.', correct: 'They, third person', wrong: ['I, first person', 'We, first person'] },
            { passage: 'He jumps. He laughs.', correct: 'He, third person', wrong: ['I, first person', 'They, third person'] },
            { passage: 'I read a book. I learn.', correct: 'I, first person', wrong: ['She, third person', 'They, third person'] },
            { passage: 'We wash our hands. We eat lunch.', correct: 'We, first person', wrong: ['He, third person', 'They, third person'] },
            { passage: 'They play a game. They laugh.', correct: 'They, third person', wrong: ['I, first person', 'We, first person'] },
            { passage: 'She paints a picture. She smiles.', correct: 'She, third person', wrong: ['He, third person', 'I, first person'] },
            { passage: 'He reads the sign. He stops.', correct: 'He, third person', wrong: ['They, third person', 'We, first person'] },
            { passage: 'I am hungry. I eat an apple.', correct: 'I, first person', wrong: ['He, third person', 'She, third person'] },
            { passage: 'We go home. We rest.', correct: 'We, first person', wrong: ['She, third person', 'They, third person'] }
          ];
          const item = pickPoolItem('point-of-view', items);
          const answers = shuffleInPlace([item.correct, ...item.wrong]);
          pages.push(makeMCQ({
            passage: item.passage,
            question: 'Who is telling the story?',
            hint: 'Look for I, we, he, she, they.',
            answers,
            correctAnswerName: item.correct,
            successMessage: 'Nice point of view!'
          }));
        } else if (skillId === 'phoneme-change-first') {
          const item = pickPoolItem('phoneme-change', bank.phonemeChange) || pickOne(bank.phonemeChange);
          const passage = `Change the first sound in ${item.base} to ${item.firstTo}.`;
          const correct = item.result;
          const wrong = pickDistinct(bank.cvc, 2, new Set([correct, item.base]));
          const answers = shuffleInPlace([correct, ...wrong]);
          pages.push(makeMCQ({
            passage,
            question: 'Which word do you make?',
            hint: 'Look at the first letter.',
            answers,
            correctAnswerName: correct,
            successMessage: 'Yes! You changed the first sound.'
          }));
        } else if (skillId === 'phoneme-change-last') {
          const item = pickPoolItem('phoneme-change', bank.phonemeChange) || pickOne(bank.phonemeChange);
          const passage = `Change the last sound in ${item.base} to ${item.lastTo}.`;
          const correct = item.lastResult;
          const wrong = pickDistinct(bank.cvc, 2, new Set([correct, item.base]));
          const answers = shuffleInPlace([correct, ...wrong]);
          pages.push(makeMCQ({
            passage,
            question: 'Which word do you make?',
            hint: 'Look at the last letter.',
            answers,
            correctAnswerName: correct,
            successMessage: 'Nice! You changed the last sound.'
          }));
        } else if (skillId === 'phoneme-change-vowel') {
          const item = pickPoolItem('phoneme-change', bank.phonemeChange) || pickOne(bank.phonemeChange);
          const passage = `Change the vowel in ${item.base} to ${item.vowelTo}.`;
          const correct = item.vowelResult;
          const wrong = pickDistinct(bank.cvc, 2, new Set([correct, item.base]));
          const answers = shuffleInPlace([correct, ...wrong]);
          pages.push(makeMCQ({
            passage,
            question: 'Which word do you make?',
            hint: 'The vowel is in the middle.',
            answers,
            correctAnswerName: correct,
            successMessage: 'Good vowel change!'
          }));
        } else if (skillId === 'abc-order') {
          const words = pickDistinct(bank.cvc, 3);
          const correct = [...words].sort((a, b) => a.localeCompare(b)).join(', ');
          const wrong1 = [...words].sort((a, b) => b.localeCompare(a)).join(', ');
          const wrong2 = shuffleInPlace([...words]).join(', ');
          const answers = shuffleInPlace([correct, wrong1, wrong2]);
          pages.push(makeMCQ({
            passage: `Words are ${words.join(', ')}.`,
            question: 'Which list is in ABC order?',
            hint: 'ABC order means alphabetical order.',
            answers,
            correctAnswerName: correct,
            successMessage: 'Nice ABC order!'
          }));
        } else if (skillId === 'synonyms') {
          const item = pickPoolItem('synonyms', bank.synonyms);
          const answers = shuffleInPlace([item.synonym, ...item.wrong]);
          pages.push(makeMCQ({
            passage: `Word is ${item.word}.`,
            question: 'Which word means almost the same?',
            hint: 'A synonym means nearly the same thing.',
            answers,
            correctAnswerName: item.synonym,
            successMessage: 'Yes! Those words are synonyms.'
          }));
        } else if (skillId === 'antonyms') {
          const item = pickPoolItem('antonyms', bank.antonyms);
          const answers = shuffleInPlace([item.antonym, ...item.wrong]);
          pages.push(makeMCQ({
            passage: `Word is ${item.word}.`,
            question: 'Which word means the opposite?',
            hint: 'An antonym means the opposite.',
            answers,
            correctAnswerName: item.antonym,
            successMessage: 'Yes! That is the opposite.'
          }));
        } else if (skillId === 'categories-odd') {
          const item = pickPoolItem('categories', bank.categories);
          const words = shuffleInPlace([...pickDistinct(item.words, 2), item.odd]);
          pages.push(makeMCQ({
            passage: `Category is ${item.category}.`,
            question: 'Which word does not belong?',
            hint: 'Two words fit the category.',
            answers: words,
            correctAnswerName: item.odd,
            successMessage: 'Good sorting!'
          }));
        } else if (skillId === 'number-words') {
          const item = pickPoolItem('numberWords', bank.numberWords || []);
          const answers = shuffleInPlace([item.word, ...item.wrong]);
          const stems = [
            { q: 'Which word names this number?', h: 'Read the number, then pick the matching word.' },
            { q: 'What number word is this?', h: 'Match the digit to the word.' },
            { q: 'Choose the correct number word.', h: 'Look carefully at each word.' }
          ];
          const stem = pickOne(stems);
          pages.push(makeMCQ({
            passage: `Number is ${item.digit}.`,
            question: stem.q,
            hint: stem.h,
            answers,
            correctAnswerName: item.word,
            successMessage: 'Nice number word!'
          }));
        } else if (skillId === 'prefix-un') {
          const item = pickPoolItem('prefix-un', bank.prefixesUn || []);
          const answers = shuffleInPlace([item.derived, ...item.wrong]);
          pages.push(makeMCQ({
            passage: `Base word is ${item.base}.`,
            question: `Which word means ${item.meaning}?`,
            hint: 'The prefix un- can mean not, or it can mean to undo.',
            answers,
            correctAnswerName: item.derived,
            successMessage: 'Great! You used a prefix.'
          }));
        } else if (skillId === 'suffix-ful') {
          const item = pickPoolItem('suffix-ful', bank.suffixesFul || []);
          const answers = shuffleInPlace([item.derived, ...item.wrong]);
          pages.push(makeMCQ({
            passage: `Base word is ${item.base}.`,
            question: `Which word means ${item.meaning}?`,
            hint: 'The suffix -ful can mean full of.',
            answers,
            correctAnswerName: item.derived,
            successMessage: 'Great! You used a suffix.'
          }));
        } else if (skillId === 'pronouns') {
          const items = [
            { passage: 'Ben has a hat.', sentence: '___ runs to play.', correct: 'He', wrong: ['They', 'We'] },
            { passage: 'Mia has a doll.', sentence: '___ likes it.', correct: 'She', wrong: ['He', 'We'] },
            { passage: 'The kids go to the park.', sentence: '___ swing and slide.', correct: 'They', wrong: ['He', 'She'] },
            { passage: 'You and I play a game.', sentence: '___ take turns.', correct: 'We', wrong: ['He', 'She'] },
            { passage: 'Tom and Sara have a dog.', sentence: '___ walk it.', correct: 'They', wrong: ['He', 'I'] },
            { sentence: '___ am hungry.', correct: 'I', wrong: ['He', 'They'] },
            { passage: 'Dad runs fast.', sentence: '___ wins the race.', correct: 'He', wrong: ['We', 'They'] },
            { passage: 'Mom likes milk.', sentence: '___ drinks it.', correct: 'She', wrong: ['They', 'We'] },
            { passage: 'The teacher reads a story.', sentence: '___ shows the pictures.', correct: 'She', wrong: ['They', 'We'] },
            { passage: 'My friends come over.', sentence: '___ play in the yard.', correct: 'They', wrong: ['He', 'She'] },
            { passage: 'Ben is at school.', sentence: '___ works hard.', correct: 'He', wrong: ['We', 'They'] },
            { passage: 'Ana eats lunch.', sentence: '___ feels full.', correct: 'She', wrong: ['He', 'They'] }
          ];
          const item = pickPoolItem('pronouns', items);
          const answers = shuffleInPlace([item.correct, ...item.wrong]);
          const displayPassage = item.passage ? `${item.passage} ${item.sentence.replace('___', '____')}` : item.sentence.replace('___', '____');
          pages.push(makeMCQ({
            passage: displayPassage,
            question: 'Choose the best pronoun.',
            hint: 'Pronouns can be he, she, they, we, I.',
            answers,
            correctAnswerName: item.correct,
            successMessage: 'Nice pronoun!'
          }));
        } else if (skillId === 'possessive-pronouns') {
          const item = pickPoolItem('possessive-pronouns', bank.possessivePronouns || []);
          const answers = shuffleInPlace([item.correct, ...item.wrong]);
          const passage = String(item.sentence || '').replace('___', '____');
          pages.push(makeMCQ({
            passage,
            question: 'Choose the correct possessive pronoun.',
            hint: 'Possessive pronouns show who owns something.',
            answers,
            correctAnswerName: item.correct,
            successMessage: 'Nice! That shows ownership.'
          }));
        } else if (skillId === 'pronoun-reference') {
          const item = pickPoolItem('pronounReference', bank.pronounReference || []);
          const answers = shuffleInPlace([item.correct, ...item.wrong]);
          const stems = [
            { q: item.question || 'What does the pronoun mean?', h: 'A pronoun stands for a noun. Look back at the passage.' },
            { q: item.question || 'Who or what is the pronoun talking about?', h: 'Find the pronoun and look for the name or thing it replaces.' }
          ];
          const stem = pickOne(stems);
          pages.push(makeMCQ({
            passage: item.passage,
            question: stem.q,
            hint: stem.h,
            answers,
            correctAnswerName: item.correct,
            successMessage: 'Great! You found what the pronoun means.'
          }));
        } else if (skillId === 'subject-verb') {
          const items = [
            { sentence: 'He ____.', correct: 'runs', wrong: ['run', 'running'] },
            { sentence: 'They ____.', correct: 'run', wrong: ['runs', 'running'] },
            { sentence: 'She ____.', correct: 'jumps', wrong: ['jump', 'jumping'] },
            { sentence: 'We ____.', correct: 'play', wrong: ['plays', 'playing'] },
            { sentence: 'The dog ____.', correct: 'barks', wrong: ['bark', 'barking'] },
            { sentence: 'The cats ____.', correct: 'sleep', wrong: ['sleeps', 'sleeping'] },
            { sentence: 'I ____.', correct: 'read', wrong: ['reads', 'reading'] },
            { sentence: 'My friend ____.', correct: 'walks', wrong: ['walk', 'walking'] }
          ];
          const item = pickPoolItem('subject-verb', items);
          const answers = shuffleInPlace([item.correct, ...item.wrong]);
          pages.push(makeMCQ({
            passage: item.sentence.replace('____', '_____'),
            question: 'Choose the best verb.',
            hint: 'One person: runs/jumps. More than one: run/jump.',
            answers,
            correctAnswerName: item.correct,
            successMessage: 'Good subject-verb match!'
          }));
        } else if (skillId === 'verb-tense') {
          const items = [
            { question: 'Which sentence tells about the past?', correct: 'I jumped.', wrong: ['I jump.', 'I will jump.'] },
            { question: 'Which sentence tells about the future?', correct: 'I will eat.', wrong: ['I eat.', 'I ate.'] },
            { question: 'Which sentence tells about the present?', correct: 'I run.', wrong: ['I ran.', 'I will run.'] },
            { question: 'Which sentence tells about the past?', correct: 'She played.', wrong: ['She plays.', 'She will play.'] },
            { question: 'Which sentence tells about the future?', correct: 'They will read.', wrong: ['They read.', 'They readed.'] },
            { question: 'Which sentence tells about the present?', correct: 'He walks.', wrong: ['He walked.', 'He will walk.'] },
            { question: 'Which sentence tells about the past?', correct: 'We ate.', wrong: ['We eat.', 'We will eat.'] },
            { question: 'Which sentence tells about the future?', correct: 'I will go.', wrong: ['I went.', 'I go.'] }
          ];
          const item = pickPoolItem('verb-tense', items);
          const answers = shuffleInPlace([item.correct, ...item.wrong]);
          pages.push(makeMCQ({
            question: item.question,
            hint: 'Past already happened. Present is now. Future will happen.',
            answers,
            correctAnswerName: item.correct,
            successMessage: 'Nice tense!'
          }));
        } else if (skillId === 'capitalization') {
          const items = [
            { question: 'Choose the sentence with correct capitalization.', correct: 'I like pizza.', wrong: ['i like pizza.', 'i Like pizza.'] },
            { question: 'Choose the sentence with correct capitalization.', correct: 'We go to the park.', wrong: ['we go to the park.', 'We go to the Park.'] },
            { question: 'Choose the sentence with correct capitalization.', correct: 'She has a dog.', wrong: ['she has a dog.', 'She has a Dog.'] },
            { question: 'Choose the sentence with correct capitalization.', correct: 'He can read.', wrong: ['he can read.', 'He Can read.'] },
            { question: 'Choose the sentence with correct capitalization.', correct: 'Today is Monday.', wrong: ['today is monday.', 'Today is monday.'] },
            { question: 'Choose the sentence with correct capitalization.', correct: 'My mom is here.', wrong: ['my mom is here.', 'My Mom is here.'] },
            { question: 'Choose the sentence with correct capitalization.', correct: 'I see a cat.', wrong: ['i see a cat.', 'I see a Cat.'] }
          ];
          const item = pickPoolItem('capitalization', items);
          const answers = shuffleInPlace([item.correct, ...item.wrong]);
          pages.push(makeMCQ({
            question: item.question,
            hint: 'Start a sentence with a capital letter. The word I is always capital.',
            answers,
            correctAnswerName: item.correct,
            successMessage: 'Great capitalization!'
          }));
        } else if (skillId === 'proper-nouns') {
          const item = pickPoolItem('proper-nouns', bank.properNouns || []);
          const answers = shuffleInPlace([item.correct, ...item.wrong]);
          pages.push(makeMCQ({
            question: item.question,
            hint: 'Names of people, days, and months start with a capital letter.',
            answers,
            correctAnswerName: item.correct,
            successMessage: 'Nice! That is a proper noun.'
          }));
        } else if (skillId === 'complete-sentence') {
          const items = [
            { question: 'Which is a complete sentence?', correct: 'The dog runs.', wrong: ['The dog.', 'Runs fast.'] },
            { question: 'Which is a complete sentence?', correct: 'I see a cat.', wrong: ['See a cat.', 'A cat.'] },
            { question: 'Which is a complete sentence?', correct: 'We play outside.', wrong: ['We play.', 'Outside.'] },
            { question: 'Which is a complete sentence?', correct: 'She eats lunch.', wrong: ['Eats lunch.', 'She lunch.'] },
            { question: 'Which is a complete sentence?', correct: 'My dad cooks.', wrong: ['My dad.', 'Cooks.'] },
            { question: 'Which is a complete sentence?', correct: 'The fish swims.', wrong: ['The fish.', 'Swims fast.'] },
            { question: 'Which is a complete sentence?', correct: 'They read books.', wrong: ['Read books.', 'They books.'] }
          ];
          const item = pickPoolItem('complete-sentence', items);
          const answers = shuffleInPlace([item.correct, ...item.wrong]);
          pages.push(makeMCQ({
            question: item.question,
            hint: 'A complete sentence has a naming part and an action part.',
            answers,
            correctAnswerName: item.correct,
            successMessage: 'Yes! That is a complete sentence.'
          }));
        } else if (skillId === 'spelling-cvc') {
          const item = pickPoolItem('spelling-cvc', bank.spelling.cvc);
          const answers = shuffleInPlace([item.word, ...item.wrong]);
          pages.push(makeMCQ({
            passage: `Word is ${item.word}.`,
            question: 'Choose the correct spelling.',
            hint: 'Look carefully at each letter.',
            answers,
            correctAnswerName: item.word,
            successMessage: 'Yes! That spelling is correct.'
          }));
        } else if (skillId === 'spelling-digraph') {
          const item = pickPoolItem('spelling-digraph', bank.spelling.digraph);
          const answers = shuffleInPlace([item.word, ...item.wrong]);
          pages.push(makeMCQ({
            passage: `Word is ${item.word}.`,
            question: 'Choose the correct spelling.',
            hint: 'Look for the digraph.',
            answers,
            correctAnswerName: item.word,
            successMessage: 'Yes! That spelling is correct.'
          }));
        } else if (skillId === 'spelling-sight') {
          const item = pickPoolItem('spelling-sight', bank.spelling.sight);
          const answers = shuffleInPlace([item.word, ...item.wrong]);
          pages.push(makeMCQ({
            passage: `Sight word is ${item.word}.`,
            question: 'Choose the correct spelling.',
            hint: 'Sight words are words we memorize.',
            answers,
            correctAnswerName: item.word,
            successMessage: 'Great! You spelled the sight word.'
          }));
        } else {
          // Fallback: main idea
          const answers = shuffleInPlace(['Getting a cold drink', 'Going to bed', 'Catching a fish']);
          pages.push(makeMCQ({
            passage: 'Sam is hot. Sam gets a cold drink. Sam feels better.',
            question: 'What is the main idea?',
            hint: 'What is it mostly about?',
            answers,
            correctAnswerName: 'Getting a cold drink'
          }));
        }
      }

      return pages;
    }

    const skillsCatalog = [
      // ===== LEVEL 1 =====
      { id: 'consonant-or-vowel', level: 1, category: 'Reading foundations', name: 'Consonant or Vowel', description: 'Tell if a letter is a vowel or consonant' },
      { id: 'vowels-letter', level: 1, category: 'Reading foundations', name: 'Vowels', description: 'Identify vowels a, e, i, o, u' },
      { id: 'start-letter', level: 1, category: 'Reading foundations', name: 'Starting Letter', description: 'Find the word that starts with a letter' },
      { id: 'end-letter', level: 1, category: 'Reading foundations', name: 'Ending Letter', description: 'Find the word that ends with a letter' },
      { id: 'first-sound', level: 1, category: 'Reading foundations', name: 'First Letter', description: 'Find the first letter in a word' },
      { id: 'last-sound', level: 1, category: 'Reading foundations', name: 'Last Letter', description: 'Find the last letter in a word' },
      { id: 'rhyming-choose', level: 1, category: 'Reading foundations', name: 'Rhyming', description: 'Choose a rhyming word' },
      { id: 'rhyming-odd', level: 1, category: 'Reading foundations', name: 'Rhyming: Odd One Out', description: 'Find the word that does not rhyme' },
      { id: 'rhyming-complete', level: 1, category: 'Reading foundations', name: 'Complete the Rhyme', description: 'Pick the word that rhymes' },
      { id: 'blend-sounds', level: 1, category: 'Reading foundations', name: 'Blend Sounds', description: 'Blend sounds to read a word' },
      { id: 'short-vowel-fill', level: 1, category: 'Reading foundations', name: 'Short Vowels', description: 'Complete a word with the right vowel' },
      { id: 'spelling-cvc', level: 1, category: 'Reading foundations', name: 'Spell CVC Words', description: 'Choose the correct spelling' },
      { id: 'compound-words', level: 1, category: 'Reading foundations', name: 'Compound Words', description: 'Put two words together' },
      { id: 'sight-blank', level: 1, category: 'Sight words', name: 'Sight Words', description: 'Complete a sentence with a sight word' },
      { id: 'punctuation-endmark', level: 1, category: 'Grammar', name: 'End Marks', description: 'Pick the best end mark' },
      { id: 'sentence-type', level: 1, category: 'Grammar', name: 'Sentence Types', description: 'Statement, question, command, or exclamation' },
      { id: 'complete-sentence', level: 1, category: 'Grammar', name: 'Complete Sentences', description: 'Find a complete sentence' },
      { id: 'capitalization', level: 1, category: 'Grammar', name: 'Capitalization', description: 'Choose correct capitalization' },

      // ===== LEVEL 2 =====
      { id: 'vowels-word', level: 2, category: 'Reading foundations', name: 'Vowels in a Word', description: 'Find a vowel inside a word' },
      { id: 'syllables-count', level: 2, category: 'Reading foundations', name: 'Syllables: Count', description: 'Count syllables in a word' },
      { id: 'syllables-which', level: 2, category: 'Reading foundations', name: 'Syllables: Choose', description: 'Choose the word with 2 or 3 syllables' },
      { id: 'two-syllable-build', level: 2, category: 'Reading foundations', name: 'Build Two-Syllable Words', description: 'Put syllables together to make a word' },
      { id: 'categories-odd', level: 2, category: 'Vocabulary', name: 'Categories', description: 'Find the word that does not belong' },
      { id: 'synonyms', level: 2, category: 'Vocabulary', name: 'Synonyms', description: 'Choose words with similar meanings' },
      { id: 'antonyms', level: 2, category: 'Vocabulary', name: 'Antonyms', description: 'Choose words with opposite meanings' },
      { id: 'abc-order', level: 2, category: 'Vocabulary', name: 'ABC Order', description: 'Put words in ABC order' },
      { id: 'number-words', level: 2, category: 'Vocabulary', name: 'Number Words', description: 'Match digits to number words' },
      { id: 'noun-type', level: 2, category: 'Vocabulary', name: 'Noun Types', description: 'Person, place, animal, or thing' },
      { id: 'main-idea', level: 2, category: 'Reading strategies', name: 'Main Idea', description: 'Find what the passage is mostly about' },
      { id: 'sequence-first', level: 2, category: 'Reading strategies', name: 'Sequence', description: 'Use first, next, and last' },
      { id: 'setting', level: 2, category: 'Reading strategies', name: 'Setting', description: 'Find where the story happens' },
      { id: 'character', level: 2, category: 'Reading strategies', name: 'Characters', description: 'Find who the story is about' },
      { id: 'inference-feeling', level: 2, category: 'Reading strategies', name: 'Inference: Feelings', description: 'Use clues to pick a feeling' },
      { id: 'reality-fiction', level: 2, category: 'Reading strategies', name: 'Reality vs. Fiction', description: 'Choose what could happen' },
      { id: 'best-title', level: 2, category: 'Reading strategies', name: 'Best Title', description: 'Pick the best title for a passage' },
      { id: 'supporting-detail', level: 2, category: 'Reading strategies', name: 'Supporting Details', description: 'Find a detail from a passage' },
      { id: 'articles-a-an', level: 2, category: 'Grammar', name: 'A or An', description: 'Choose a or an' },
      { id: 'parts-noun', level: 2, category: 'Grammar', name: 'Nouns', description: 'Find a noun' },
      { id: 'parts-verb', level: 2, category: 'Grammar', name: 'Verbs', description: 'Find an action verb' },
      { id: 'parts-adj', level: 2, category: 'Grammar', name: 'Adjectives', description: 'Find a describing word' },
      { id: 'unscramble-sentence', level: 2, category: 'Grammar', name: 'Unscramble Sentences', description: 'Choose the sentence in the right order' },
      { id: 'pronouns', level: 2, category: 'Grammar', name: 'Pronouns', description: 'Choose he, she, or they' },
      { id: 'prepositions', level: 2, category: 'Grammar', name: 'Prepositions', description: 'Pick a word that shows where' },
      { id: 'conjunctions', level: 2, category: 'Grammar', name: 'Linking Words', description: 'Choose and, but, so, or because' },
      { id: 'time-order', level: 2, category: 'Grammar', name: 'Time-Order Words', description: 'Choose first, next, or last' },

      // ===== LEVEL 3 =====
      { id: 'digraph-find', level: 3, category: 'Reading foundations', name: 'Digraphs', description: 'Find words with sh, ch, and th' },
      { id: 'digraph-choose', level: 3, category: 'Reading foundations', name: 'Choose a Digraph', description: 'Pick the digraph that fits' },
      { id: 'spelling-digraph', level: 3, category: 'Reading foundations', name: 'Spell Digraph Words', description: 'Choose the correct spelling with sh, ch, or th' },
      { id: 'blends-start', level: 3, category: 'Reading foundations', name: 'Consonant Blends', description: 'Find words that start with blends' },
      { id: 'phoneme-change-first', level: 3, category: 'Reading foundations', name: 'Change First Sound', description: 'Change the first sound in a word' },
      { id: 'phoneme-change-last', level: 3, category: 'Reading foundations', name: 'Change Last Sound', description: 'Change the last sound in a word' },
      { id: 'phoneme-change-vowel', level: 3, category: 'Reading foundations', name: 'Change Vowel', description: 'Change the vowel in a word' },
      { id: 'silent-e', level: 3, category: 'Reading foundations', name: 'Silent E', description: 'Find words with silent e' },
      { id: 'long-vowel-silent-e', level: 3, category: 'Reading foundations', name: 'Long Vowels', description: 'Pick the long-vowel word' },
      { id: 'point-of-view', level: 3, category: 'Reading strategies', name: 'Point of View', description: 'Who is telling the story?' },
      { id: 'character-actions', level: 3, category: 'Reading strategies', name: 'Character Clues', description: 'Use actions and words to understand a character' },
      { id: 'problem-solution', level: 3, category: 'Reading strategies', name: 'Problem and Solution', description: 'Find the problem or the solution in a passage' },
      { id: 'cause-effect', level: 3, category: 'Reading strategies', name: 'Cause and Effect', description: 'Why did it happen?' },
      { id: 'prediction-next', level: 3, category: 'Reading strategies', name: 'Prediction', description: 'What will happen next?' },
      { id: 'subject-verb', level: 3, category: 'Grammar', name: 'Subject-Verb Agreement', description: 'Choose the best verb' },
      { id: 'verb-tense', level: 3, category: 'Grammar', name: 'Verb Tense', description: 'Past, present, or future' },
      { id: 'wh-words', level: 3, category: 'Grammar', name: 'Question Words', description: 'Choose who, what, where, when, or why' },
      { id: 'proper-nouns', level: 3, category: 'Grammar', name: 'Proper Nouns', description: 'Find names that start with a capital letter' },
      { id: 'pronoun-reference', level: 3, category: 'Grammar', name: 'Pronoun Reference', description: 'Find what a pronoun means' },
      { id: 'contractions', level: 3, category: 'Grammar', name: 'Contractions', description: 'Choose the contraction' },
      { id: 'plurals', level: 3, category: 'Grammar', name: 'Plurals', description: 'Choose the correct plural word' },
      { id: 'irregular-plurals', level: 3, category: 'Grammar', name: 'Irregular Plurals', description: 'Choose special plural words like children and feet' },
      { id: 'adjectives-compare', level: 3, category: 'Grammar', name: 'Comparative & Superlative', description: 'Choose -er or -est words' },

      // ===== LEVEL 4 =====
      { id: 'vowel-team-ee', level: 4, category: 'Reading foundations', name: 'Vowel Teams: EE', description: 'Find words with ee' },
      { id: 'vowel-team-ea', level: 4, category: 'Reading foundations', name: 'Vowel Teams: EA', description: 'Find words with ea' },
      { id: 'vowel-team-ai', level: 4, category: 'Reading foundations', name: 'Vowel Teams: AI', description: 'Find words with ai' },
      { id: 'vowel-team-ay', level: 4, category: 'Reading foundations', name: 'Vowel Teams: AY', description: 'Find words with ay' },
      { id: 'vowel-team-oa', level: 4, category: 'Reading foundations', name: 'Vowel Teams: OA', description: 'Find words with oa' },
      { id: 'vowel-team-ow', level: 4, category: 'Reading foundations', name: 'Vowel Teams: OW', description: 'Find ow words with the long o sound' },
      { id: 'r-controlled-ar', level: 4, category: 'Reading foundations', name: 'R-Controlled: AR', description: 'Find words with ar' },
      { id: 'r-controlled-er', level: 4, category: 'Reading foundations', name: 'R-Controlled: ER', description: 'Find words with er' },
      { id: 'r-controlled-ir', level: 4, category: 'Reading foundations', name: 'R-Controlled: IR', description: 'Find words with ir' },
      { id: 'r-controlled-or', level: 4, category: 'Reading foundations', name: 'R-Controlled: OR', description: 'Find words with or' },
      { id: 'r-controlled-ur', level: 4, category: 'Reading foundations', name: 'R-Controlled: UR', description: 'Find words with ur' },
      { id: 'diphthong-oi', level: 4, category: 'Reading foundations', name: 'Diphthongs: OI', description: 'Find words with oi' },
      { id: 'diphthong-oy', level: 4, category: 'Reading foundations', name: 'Diphthongs: OY', description: 'Find words with oy' },
      { id: 'diphthong-ou', level: 4, category: 'Reading foundations', name: 'Diphthongs: OU', description: 'Find words with ou' },
      { id: 'diphthong-ow', level: 4, category: 'Reading foundations', name: 'Diphthongs: OW', description: 'Find ow words that sound like cow' },
      { id: 'context-clues', level: 4, category: 'Vocabulary', name: 'Context Clues', description: 'Use the sentence to find the meaning' },
      { id: 'prefix-un', level: 4, category: 'Vocabulary', name: 'Prefixes: un-', description: 'Use un- to change a word' },
      { id: 'suffix-ful', level: 4, category: 'Vocabulary', name: 'Suffixes: -ful', description: 'Use -ful to change a word' },
      { id: 'multiple-meaning', level: 4, category: 'Vocabulary', name: 'Multiple-Meaning Words', description: 'Use context to choose the meaning' },
      { id: 'shades-of-meaning', level: 4, category: 'Vocabulary', name: 'Shades of Meaning', description: 'Pick the strongest word' },
      { id: 'shades-order', level: 4, category: 'Vocabulary', name: 'Shades: Order', description: 'Order words by strength' },
      { id: 'possessive-nouns', level: 4, category: 'Grammar', name: 'Possessive Nouns', description: 'Show ownership with apostrophe and s' },
      { id: 'possessive-pronouns', level: 4, category: 'Grammar', name: 'Possessive Pronouns', description: 'my, his, her, our, or their' },
      { id: 'text-features', level: 4, category: 'Reading strategies', name: 'Text Features', description: 'Headings, captions, table of contents' },
      { id: 'spelling-sight', level: 4, category: 'Sight words', name: 'Spell Sight Words', description: 'Choose the correct spelling' }
    ];

    function setSkillsLevelFilter(level) {
      state.skillsLevelFilter = level;
      updateSkillsFilterButtons();
      renderSkillsScreen();
    }

    function updateSkillsFilterButtons() {
      const mapping = [
        { id: 'skillsFilterAll', value: 'all' },
        { id: 'skillsFilter1', value: 1 },
        { id: 'skillsFilter2', value: 2 },
        { id: 'skillsFilter3', value: 3 },
        { id: 'skillsFilter4', value: 4 },
      ];

      mapping.forEach(item => {
        const el = document.getElementById(item.id);
        if (!el) return;
        const isActive = state.skillsLevelFilter === item.value;
        el.classList.toggle('active', isActive);
      });
    }

    function renderSkillsScreen() {
      const container = document.getElementById('skillsList');
      if (!container) return;

      container.innerHTML = '';

      const visibleSkills = skillsCatalog.filter(s => {
        if (state.skillsLevelFilter === 'all') return true;
        return s.level === state.skillsLevelFilter;
      });

      const categoryOrder = ['Reading foundations', 'Sight words', 'Reading strategies', 'Vocabulary', 'Grammar'];
      const categories = Array.from(new Set(visibleSkills.map(s => s.category))).sort((a, b) => {
        const ai = categoryOrder.indexOf(a);
        const bi = categoryOrder.indexOf(b);
        if (ai !== -1 || bi !== -1) return (ai === -1 ? 999 : ai) - (bi === -1 ? 999 : bi);
        return a.localeCompare(b);
      });
      categories.forEach(category => {
        const heading = document.createElement('div');
        heading.style.width = '100%';
        heading.style.margin = '12px 0 6px';
        heading.style.fontFamily = 'var(--font-display)';
        heading.style.fontWeight = '700';
        heading.style.color = 'var(--text-primary)';
        heading.textContent = category;
        container.appendChild(heading);

        visibleSkills
          .filter(s => s.category === category)
          .sort((a, b) => a.level - b.level || a.name.localeCompare(b.name))
          .forEach(skill => {
            const btn = document.createElement('button');
            btn.className = 'station-btn';
            btn.onclick = () => startSkillPractice(skill.id);
            btn.innerHTML = `
	            <div class="station-info">
	              <div class="station-name">${skill.name}</div>
	              <div class="station-desc">Level ${skill.level} â€¢ ${skill.description}</div>
	            </div>
	            <span class="station-status">Start</span>
	          `;
            container.appendChild(btn);
          });
      });
    }

    function hashStringToSeed(text) {
      const str = String(text || '');
      let h = 2166136261;
      for (let i = 0; i < str.length; i++) {
        h ^= str.charCodeAt(i);
        h = Math.imul(h, 16777619);
      }
      return h >>> 0;
    }

    function mulberry32(seed) {
      let t = seed >>> 0;
      return () => {
        t += 0x6D2B79F5;
        let x = t;
        x = Math.imul(x ^ (x >>> 15), x | 1);
        x ^= x + Math.imul(x ^ (x >>> 7), x | 61);
        return ((x ^ (x >>> 14)) >>> 0) / 4294967296;
      };
    }

    function withSeededMathRandom(seedText, fn) {
      const seed = hashStringToSeed(seedText);
      const rng = mulberry32(seed);
      const original = Math.random;
      Math.random = rng;
      try {
        return fn();
      } finally {
        Math.random = original;
      }
    }

    function startSkillPractice(skillId) {
      const skill = skillsCatalog.find(s => s.id === skillId);
      if (!skill) return;

      state.practiceSkillId = skillId;
      state.practiceCorrect = 0;
      state.practiceFirstTryCorrect = 0;

      const pages = withSeededMathRandom(`skill-practice:${skillId}:v1`, () => generateSkillPages(skillId, 10));
      state.practiceTotal = pages.filter(p => p.type === 'question').length;

      stationContent.practice.name = `Skill Practice: ${skill.name}`;
      stationContent.practice.pages = pages;

      state.currentStation = 'practice';
      state.currentPage = 0;
      state.currentOrder = null;
      state.sessionPages = stationContent.practice.pages;

      showRestaurant();
    }

    // ===== ADAPTIVE RECOMMENDATIONS (AUTO "WHAT TO PRACTICE NEXT") =====
    function normalizeAnalyticsData(raw) {
      const obj = raw && typeof raw === 'object' ? raw : {};

      const ensureBucket = bucket => {
        if (!bucket || typeof bucket !== 'object') return {};
        const out = {};
        for (const [key, value] of Object.entries(bucket)) {
          const v = value && typeof value === 'object' ? value : {};
          out[key] = {
            totalQuestions: Number.isFinite(v.totalQuestions) ? v.totalQuestions : 0,
            firstTryCorrect: Number.isFinite(v.firstTryCorrect) ? v.firstTryCorrect : 0,
            wrongFirstTry: Number.isFinite(v.wrongFirstTry) ? v.wrongFirstTry : 0,
            totalAttempts: Number.isFinite(v.totalAttempts) ? v.totalAttempts : 0,
            lastAt: Number.isFinite(v.lastAt) ? v.lastAt : 0,
            // Optional: menu choice preferences
            choices: (v.choices && typeof v.choices === 'object') ? v.choices : undefined,
          };
        }
        return out;
      };

      const recentAnswers = Array.isArray(obj.recentAnswers) ? obj.recentAnswers : [];
      const recentMistakes = Array.isArray(obj.recentMistakes) ? obj.recentMistakes : [];

      const trimRecent = (arr, max) =>
        arr
          .filter(x => x && typeof x === 'object' && Number.isFinite(x.at))
          .sort((a, b) => a.at - b.at)
          .slice(-max);

      return {
        schemaVersion: 1,
        stations: ensureBucket(obj.stations),
        skills: ensureBucket(obj.skills),
        strategies: ensureBucket(obj.strategies),
        recentAnswers: trimRecent(recentAnswers, 30),
        recentMistakes: trimRecent(recentMistakes, 20),
        updatedAt: Number.isFinite(obj.updatedAt) ? obj.updatedAt : 0,
      };
    }

    function ensureAnalyticsState() {
      state.analytics = normalizeAnalyticsData(state.analytics);
      return state.analytics;
    }

    function getSkillById(skillId) {
      if (!skillId) return null;
      return (Array.isArray(skillsCatalog) ? skillsCatalog : []).find(s => s && s.id === skillId) || null;
    }

    // ===== MASTERY MODEL (v2) â€” BKT + FORGETTING =====
    function clamp01(n) {
      const x = Number(n);
      if (!Number.isFinite(x)) return 0;
      return Math.max(0, Math.min(1, x));
    }

    function normalizeMasteryData(raw) {
      const obj = raw && typeof raw === 'object' ? raw : {};
      const attemptsBySkillRaw = obj.attemptsBySkill && typeof obj.attemptsBySkill === 'object' ? obj.attemptsBySkill : {};
      const skillsRaw = obj.skills && typeof obj.skills === 'object' ? obj.skills : {};

      const normalizeAttempts = (arrRaw) => {
        const arr = Array.isArray(arrRaw) ? arrRaw : [];
        const out = [];
        for (const item of arr) {
          const id = item && typeof item.id === 'string' ? item.id.trim() : '';
          const at = item && Number.isFinite(item.at) ? item.at : null;
          if (!id || at === null) continue;
          out.push({
            id,
            at,
            correct: !!item.correct,
            supportUsed: !!item.supportUsed,
            itemId: item && typeof item.itemId === 'string' ? item.itemId : null,
            stationId: item && typeof item.stationId === 'string' ? item.stationId : null,
            difficulty: item && Number.isFinite(item.difficulty) ? item.difficulty : null,
          });
        }
        out.sort((a, b) => (a.at - b.at) || a.id.localeCompare(b.id));
        return out;
      };

      const attemptsBySkill = {};
      for (const [skillId, arrRaw] of Object.entries(attemptsBySkillRaw)) {
        const id = String(skillId || '').trim();
        if (!id) continue;
        const attempts = normalizeAttempts(arrRaw);
        if (attempts.length) attemptsBySkill[id] = attempts;
      }

      const normalizeSkillState = (value) => {
        const v = value && typeof value === 'object' ? value : {};
        return {
          pKnown: clamp01(v.pKnown),
          opportunities: Number.isFinite(v.opportunities) ? Math.max(0, v.opportunities) : 0,
          supported: Number.isFinite(v.supported) ? Math.max(0, v.supported) : 0,
          streak: Number.isFinite(v.streak) ? Math.max(0, v.streak) : 0,
          lastAt: Number.isFinite(v.lastAt) ? v.lastAt : 0,
          masteredAt: Number.isFinite(v.masteredAt) ? v.masteredAt : null,
          dueAt: Number.isFinite(v.dueAt) ? v.dueAt : 0,
        };
      };

      const skills = {};
      for (const [skillId, value] of Object.entries(skillsRaw)) {
        const id = String(skillId || '').trim();
        if (!id) continue;
        skills[id] = normalizeSkillState(value);
      }

      return {
        schemaVersion: 1,
        attemptsBySkill,
        skills,
        updatedAt: Number.isFinite(obj.updatedAt) ? obj.updatedAt : 0,
      };
    }

    function ensureMasteryState() {
      state.mastery = normalizeMasteryData(state.mastery);
      return state.mastery;
    }

    function getMasteryParamsForSkill(skillId) {
      const skill = getSkillById(skillId);
      const category = skill && typeof skill.category === 'string' ? skill.category.toLowerCase() : '';

      let learn = 0.10;
      if (category.includes('reading foundations') || category.includes('sight')) learn = 0.12;
      else if (category.includes('reading strategies')) learn = 0.08;
      else if (category.includes('grammar')) learn = 0.09;
      else if (category.includes('vocabulary')) learn = 0.09;

      return {
        g: 1 / 3,    // 3-choice MCQ
        s: 0.10,     // slip
        t: learn,    // learn
        pBase: 0.15, // baseline with forgetting
        lambda: 0.08,
      };
    }

    function applyForgetting(pKnown, deltaDays, { pBase, lambda }) {
      const days = Math.max(0, Number(deltaDays) || 0);
      const decay = Math.exp(-lambda * days);
      return clamp01(pBase + (pKnown - pBase) * decay);
    }

    function bktUpdate(pKnown, correct, { g, s, t }) {
      const p = clamp01(pKnown);
      const guess = clamp01(g);
      const slip = clamp01(s);
      const learn = clamp01(t);

      let pGiven = p;
      if (correct) {
        const num = p * (1 - slip);
        const den = num + (1 - p) * guess;
        pGiven = den > 0 ? (num / den) : p;
      } else {
        const num = p * slip;
        const den = num + (1 - p) * (1 - guess);
        pGiven = den > 0 ? (num / den) : p;
      }

      const pNext = pGiven + (1 - pGiven) * learn;
      return clamp01(pNext);
    }

    function computeNextReviewDays(pKnown, correct) {
      if (!correct) return 0;
      const p = clamp01(pKnown);
      if (p < 0.50) return 0;
      if (p < 0.70) return 1;
      if (p < 0.85) return 3;
      if (p < 0.93) return 7;
      return 14;
    }

    function getDecayedPKnown(skillState, nowMs = null) {
      const now = Number.isFinite(nowMs) ? nowMs : getSyncNowMs();
      const lastAt = skillState && Number.isFinite(skillState.lastAt) ? skillState.lastAt : 0;
      const pKnown = skillState && Number.isFinite(skillState.pKnown) ? skillState.pKnown : 0;
      if (!lastAt || now <= lastAt) return clamp01(pKnown);
      const params = getMasteryParamsForSkill(skillState && skillState.skillId ? skillState.skillId : null);
      const deltaDays = (now - lastAt) / (1000 * 60 * 60 * 24);
      return applyForgetting(pKnown, deltaDays, params);
    }

    function updateSkillMasteryFromAttempt(skillId, attempt) {
      const mastery = ensureMasteryState();
      const params = getMasteryParamsForSkill(skillId);
      const existing = mastery.skills[skillId] || {
        pKnown: params.pBase,
        opportunities: 0,
        supported: 0,
        streak: 0,
        lastAt: 0,
        masteredAt: null,
        dueAt: 0,
      };

      const at = Number.isFinite(attempt.at) ? attempt.at : getSyncNowMs();
      const lastAt = Number.isFinite(existing.lastAt) ? existing.lastAt : 0;
      const deltaDays = lastAt > 0 ? ((at - lastAt) / (1000 * 60 * 60 * 24)) : 0;

      const pBefore = applyForgetting(existing.pKnown, deltaDays, params);
      const pUpdatedRaw = bktUpdate(pBefore, !!attempt.correct, params);

      // Donâ€™t over-credit supported correct answers (weaker evidence of automaticity).
      const weight = attempt.correct && attempt.supportUsed ? 0.55 : 1.0;
      const pAfter = clamp01(pBefore + weight * (pUpdatedRaw - pBefore));

      const opportunities = (Number.isFinite(existing.opportunities) ? existing.opportunities : 0) + 1;
      const supported = (Number.isFinite(existing.supported) ? existing.supported : 0) + (attempt.supportUsed ? 1 : 0);
      const streak = (attempt.correct && !attempt.supportUsed) ? ((Number.isFinite(existing.streak) ? existing.streak : 0) + 1) : 0;

      const masteredAt =
        existing.masteredAt
          ? existing.masteredAt
          : (opportunities >= 10 && pAfter >= 0.85 && streak >= 3 ? at : null);

      const nextReviewDays = computeNextReviewDays(pAfter, !!attempt.correct);
      const dueAt = at + (nextReviewDays * 24 * 60 * 60 * 1000);

      mastery.skills[skillId] = {
        pKnown: pAfter,
        opportunities,
        supported,
        streak,
        lastAt: at,
        masteredAt,
        dueAt,
      };
      mastery.updatedAt = Math.max(mastery.updatedAt || 0, at);
    }

    function resolveSkillIdForAttempt({ isPractice, page, practiceSkillId }) {
      if (isPractice) return practiceSkillId || null;
      const explicit = page && typeof page.skillId === 'string' ? page.skillId.trim() : '';
      if (explicit) return explicit;
      if (page && page.questionType === 'comprehension') return classifyReadingStrategyForQuestion(page);
      if (page && page.questionType === 'sightWord') return 'sight-blank';
      return null;
    }

    function deriveItemIdForAttempt({ stationId, pageIndex, page, skillId }) {
      const explicit = page && typeof page.itemId === 'string' ? page.itemId.trim() : '';
      if (explicit) return explicit;
      const key = JSON.stringify({
        stationId: stationId || null,
        pageIndex: Number.isFinite(pageIndex) ? pageIndex : null,
        skillId: skillId || null,
        question: page && page.question ? String(page.question) : null,
        passage: page && page.passage ? String(page.passage) : null,
        correctAnswerName: page && page.correctAnswerName ? String(page.correctAnswerName) : null,
      });
      const h = hashStringToSeed(`item:${key}`);
      return `${stationId || 'station'}:${skillId || 'skill'}:${h.toString(36)}`;
    }

    function recordMasteryAttempt({ skillId, itemId, stationId, correct, supportUsed, difficulty }) {
      if (!skillId) return;
      const mastery = ensureMasteryState();

      const at = getSyncNowMs();
      const id = (() => {
        const device = (state.deviceId && typeof state.deviceId === 'string') ? state.deviceId : 'device';
        const base = `${device}|${at}|${skillId}|${itemId || ''}`;
        return `att_${device}_${at.toString(36)}_${hashStringToSeed(base).toString(36)}`;
      })();

      if (!mastery.attemptsBySkill[skillId]) mastery.attemptsBySkill[skillId] = [];
      const arr = mastery.attemptsBySkill[skillId];
      if (arr.some(x => x && x.id === id)) return;

      arr.push({
        id,
        at,
        correct: !!correct,
        supportUsed: !!supportUsed,
        itemId: itemId || null,
        stationId: stationId || null,
        difficulty: Number.isFinite(difficulty) ? difficulty : null,
      });

      const MAX_ATTEMPTS_PER_SKILL = 40;
      arr.sort((a, b) => (a.at - b.at) || a.id.localeCompare(b.id));
      if (arr.length > MAX_ATTEMPTS_PER_SKILL) {
        mastery.attemptsBySkill[skillId] = arr.slice(-MAX_ATTEMPTS_PER_SKILL);
      }

      updateSkillMasteryFromAttempt(skillId, { at, correct: !!correct, supportUsed: !!supportUsed });
    }

    function classifyReadingStrategyForQuestion(page) {
      const q = String(page && page.question ? page.question : '').toLowerCase();
      const hint = String(page && page.comprehensionHint ? page.comprehensionHint : '').toLowerCase();

      const has = needle => q.includes(needle) || hint.includes(needle);

      if (has('setting') || has('where am i') || has('where does') || has('what place') || has('place name')) return 'setting';
      if (has('main idea') || has('mostly about') || has('main topic')) return 'main-idea';
      if (has('feel') || has('feeling')) return 'inference-feeling';
      if (has('who') || has('character') || has('helper')) return 'character';
      if (has('title')) return 'best-title';
      if (has('real') || has('fiction') || has('could happen')) return 'reality-fiction';
      if (has('what will happen next') || has('happen next') || has('predict')) return 'prediction-next';
      if (has('why') || has('because') || has('cause') || has('effect')) return 'cause-effect';
      if (has('first') || has('last') || has('sequence') || has('in order') || has('time-order')) return 'sequence-first';
      if (has('first / next / last')) return 'sequence-first';

      return 'supporting-detail';
    }

    function getLearningLevelFromProgress() {
      const completed = Array.isArray(state.completedStations) ? state.completedStations : [];
      let maxLevel = 1;
      completed.forEach(id => {
        const st = stationContent[id];
        if (st && Number.isFinite(st.level)) maxLevel = Math.max(maxLevel, st.level);
      });
      return maxLevel;
    }

	    function getStationOrder() {
	      return Array.isArray(FOOD_STORY_PILOT_ORDER)
	        ? FOOD_STORY_PILOT_ORDER.slice()
	        : ['fruit', 'drink', 'bakery', 'pizza', 'bubbletea', 'icecream'];
	    }

    function getNextUnlockedIncompleteStation() {
      const order = getStationOrder();
      for (let i = 0; i < order.length; i++) {
        const id = order[i];
        const st = stationContent[id];
        if (!st || st.isPractice) continue;
        if (!isStationUnlocked(id, i)) continue;
        if (state.completedStations.includes(id)) continue;
        return id;
      }
      return null;
    }

    function recordQuestionAnalytics({ isPractice, correct, attempt, page, stationId, skillId }) {
      const analytics = ensureAnalyticsState();
      const now = getSyncNowMs();

      const bump = (bucket, key) => {
        if (!key) return null;
        if (!bucket[key] || typeof bucket[key] !== 'object') {
          bucket[key] = { totalQuestions: 0, firstTryCorrect: 0, wrongFirstTry: 0, totalAttempts: 0, lastAt: 0 };
        } else {
          const existingChoices =
            bucket[key].choices && typeof bucket[key].choices === 'object'
              ? bucket[key].choices
              : undefined;
          bucket[key] = {
            totalQuestions: Number.isFinite(bucket[key].totalQuestions) ? bucket[key].totalQuestions : 0,
            firstTryCorrect: Number.isFinite(bucket[key].firstTryCorrect) ? bucket[key].firstTryCorrect : 0,
            wrongFirstTry: Number.isFinite(bucket[key].wrongFirstTry) ? bucket[key].wrongFirstTry : 0,
            totalAttempts: Number.isFinite(bucket[key].totalAttempts) ? bucket[key].totalAttempts : 0,
            lastAt: Number.isFinite(bucket[key].lastAt) ? bucket[key].lastAt : 0,
            ...(existingChoices ? { choices: existingChoices } : {}),
          };
        }
        return bucket[key];
      };

      const stationKey = !isPractice ? stationId : null;
      const skillKey = isPractice ? skillId : null;
      const strategyId = (!isPractice && page && page.questionType === 'comprehension') ? classifyReadingStrategyForQuestion(page) : null;

      const stationStat = stationKey ? bump(analytics.stations, stationKey) : null;
      const skillStat = skillKey ? bump(analytics.skills, skillKey) : null;
      const strategyStat = strategyId ? bump(analytics.strategies, strategyId) : null;

      const bumpAttempt = stat => {
        if (!stat) return;
        stat.totalAttempts += 1;
        stat.lastAt = now;
      };

      bumpAttempt(stationStat);
      bumpAttempt(skillStat);
      bumpAttempt(strategyStat);

      if (attempt === 1) {
        const bumpFirstTry = stat => {
          if (!stat) return;
          stat.totalQuestions += 1;
          if (correct) stat.firstTryCorrect += 1;
          else stat.wrongFirstTry += 1;
          stat.lastAt = now;
        };

        bumpFirstTry(stationStat);
        bumpFirstTry(skillStat);
        bumpFirstTry(strategyStat);

        analytics.recentAnswers.push({
          at: now,
          context: isPractice ? 'skill' : 'station',
          stationId: stationKey || null,
          skillId: skillKey || null,
          strategyId: strategyId || null,
          correct: !!correct,
        });
        analytics.recentAnswers = analytics.recentAnswers.slice(-30);

        if (!correct) {
          analytics.recentMistakes.push({
            at: now,
            context: isPractice ? 'skill' : 'station',
            stationId: stationKey || null,
            skillId: skillKey || null,
            strategyId: strategyId || null,
          });
          analytics.recentMistakes = analytics.recentMistakes.slice(-20);
        }
      }

      analytics.updatedAt = now;
      saveProgress();
    }

    function recordMenuChoiceAnalytics(stationId, itemName) {
      if (!stationId || !itemName) return;
      const station = stationContent[stationId];
      if (!station || station.isPractice) return;

      const analytics = ensureAnalyticsState();
      const now = getSyncNowMs();

      if (!analytics.stations[stationId] || typeof analytics.stations[stationId] !== 'object') {
        analytics.stations[stationId] = { totalQuestions: 0, firstTryCorrect: 0, wrongFirstTry: 0, totalAttempts: 0, lastAt: 0, choices: {} };
      }
      if (!analytics.stations[stationId].choices || typeof analytics.stations[stationId].choices !== 'object') {
        analytics.stations[stationId].choices = {};
      }
      const key = String(itemName);
      analytics.stations[stationId].choices[key] = (analytics.stations[stationId].choices[key] || 0) + 1;
      analytics.stations[stationId].lastAt = now;
      analytics.updatedAt = now;
      saveProgress();
    }

    function mergeAnalyticsBuckets(aBucket, bBucket) {
      const out = {};
      const keys = new Set([...(aBucket ? Object.keys(aBucket) : []), ...(bBucket ? Object.keys(bBucket) : [])]);
      keys.forEach(key => {
        const a = (aBucket && aBucket[key]) ? aBucket[key] : null;
        const b = (bBucket && bBucket[key]) ? bBucket[key] : null;
        const aa = a && typeof a === 'object' ? a : {};
        const bb = b && typeof b === 'object' ? b : {};

        const merged = {
          // Use max to keep merges roughly idempotent across devices.
          totalQuestions: Math.max(Number.isFinite(aa.totalQuestions) ? aa.totalQuestions : 0, Number.isFinite(bb.totalQuestions) ? bb.totalQuestions : 0),
          firstTryCorrect: Math.max(Number.isFinite(aa.firstTryCorrect) ? aa.firstTryCorrect : 0, Number.isFinite(bb.firstTryCorrect) ? bb.firstTryCorrect : 0),
          wrongFirstTry: Math.max(Number.isFinite(aa.wrongFirstTry) ? aa.wrongFirstTry : 0, Number.isFinite(bb.wrongFirstTry) ? bb.wrongFirstTry : 0),
          totalAttempts: Math.max(Number.isFinite(aa.totalAttempts) ? aa.totalAttempts : 0, Number.isFinite(bb.totalAttempts) ? bb.totalAttempts : 0),
          lastAt: Math.max(Number.isFinite(aa.lastAt) ? aa.lastAt : 0, Number.isFinite(bb.lastAt) ? bb.lastAt : 0),
        };

        // Merge menu choice prefs (stations only; optional)
        const choices = {};
        const aChoices = aa.choices && typeof aa.choices === 'object' ? aa.choices : null;
        const bChoices = bb.choices && typeof bb.choices === 'object' ? bb.choices : null;
        if (aChoices || bChoices) {
          const choiceKeys = new Set([...(aChoices ? Object.keys(aChoices) : []), ...(bChoices ? Object.keys(bChoices) : [])]);
          choiceKeys.forEach(c => {
            choices[c] = Math.max((aChoices && aChoices[c] ? aChoices[c] : 0), (bChoices && bChoices[c] ? bChoices[c] : 0));
          });
          merged.choices = choices;
        }

        out[key] = merged;
      });
      return out;
    }

    function mergeAnalyticsData(localRaw, remoteRaw) {
      const local = normalizeAnalyticsData(localRaw);
      const remote = normalizeAnalyticsData(remoteRaw);

      const mergedRecent = (arrA, arrB, max) =>
        [...(Array.isArray(arrA) ? arrA : []), ...(Array.isArray(arrB) ? arrB : [])]
          .filter(x => x && typeof x === 'object' && Number.isFinite(x.at))
          .sort((a, b) => a.at - b.at)
          .slice(-max);

      return normalizeAnalyticsData({
        stations: mergeAnalyticsBuckets(local.stations, remote.stations),
        skills: mergeAnalyticsBuckets(local.skills, remote.skills),
        strategies: mergeAnalyticsBuckets(local.strategies, remote.strategies),
        recentAnswers: mergedRecent(local.recentAnswers, remote.recentAnswers, 30),
        recentMistakes: mergedRecent(local.recentMistakes, remote.recentMistakes, 20),
        updatedAt: Math.max(local.updatedAt || 0, remote.updatedAt || 0),
      });
    }

    function getRecommendedNextAction() {
      const nextStationId = getNextUnlockedIncompleteStation();
      const analytics = ensureAnalyticsState();

      const level = getLearningLevelFromProgress();
      const maxSkillLevel = Math.max(2, level);

      const recent = Array.isArray(analytics.recentAnswers) ? analytics.recentAnswers : [];
      const recentWindow = recent.slice(-8);
      const recentTotal = recentWindow.length;
      const recentCorrect = recentWindow.filter(x => x && x.correct).length;
      const recentAccuracy = recentTotal ? (recentCorrect / recentTotal) : 1;

      const recentWrong = recentWindow.filter(x => x && x.correct === false);
      const topRecentStrategy = (() => {
        const counts = {};
        recentWrong.forEach(x => {
          const s = x.strategyId;
          if (!s) return;
          counts[s] = (counts[s] || 0) + 1;
        });
        let best = null;
        let bestCount = 0;
        Object.entries(counts).forEach(([k, v]) => {
          if (v > bestCount) {
            best = k;
            bestCount = v;
          }
        });
        return best;
      })();

      const topRecentSkill = (() => {
        const counts = {};
        recentWrong.forEach(x => {
          if (!x || x.context !== 'skill') return;
          const id = x.skillId;
          if (!id) return;
          counts[id] = (counts[id] || 0) + 1;
        });
        let best = null;
        let bestCount = 0;
        Object.entries(counts).forEach(([k, v]) => {
          if (v > bestCount) {
            best = k;
            bestCount = v;
          }
        });
        return best;
      })();

      const strategyToSkill = {
        'setting': 'setting',
        'main-idea': 'main-idea',
        'sequence-first': 'sequence-first',
        'supporting-detail': 'supporting-detail',
        'inference-feeling': 'inference-feeling',
        'character': 'character',
        'best-title': 'best-title',
        'reality-fiction': 'reality-fiction',
        'cause-effect': 'cause-effect',
        'prediction-next': 'prediction-next',
      };

      const pickSkillIfAllowed = (skillId, reason) => {
        const skill = getSkillById(skillId);
        if (!skill) return null;
        if (Number.isFinite(skill.level) && skill.level > maxSkillLevel) return null;
        return { type: 'skill', id: skill.id, title: skill.name, reason, altStationId: nextStationId };
      };

      // If the learner is struggling recently, prioritize targeted skill practice.
      if (recentTotal >= 4 && recentAccuracy < 0.6 && topRecentStrategy) {
        const skillId = strategyToSkill[topRecentStrategy] || null;
        const picked = pickSkillIfAllowed(skillId, 'A quick practice will make the next story easier.');
        if (picked) return picked;
      }

      // If the learner is struggling in skill practice recently, repeat that skill once.
      if (recentTotal >= 4 && recentAccuracy < 0.6 && topRecentSkill) {
        const picked = pickSkillIfAllowed(topRecentSkill, 'One more practice can help you remember.');
        if (picked) return picked;
      }

      // If there's a clear weakest strategy overall (with enough data), recommend it.
      const weakestStrategy = (() => {
        const entries = Object.entries(analytics.strategies || {});
        const scored = entries
          .map(([id, stat]) => {
            const total = stat && Number.isFinite(stat.totalQuestions) ? stat.totalQuestions : 0;
            const first = stat && Number.isFinite(stat.firstTryCorrect) ? stat.firstTryCorrect : 0;
            const lastAt = stat && Number.isFinite(stat.lastAt) ? stat.lastAt : 0;
            const acc = total ? first / total : 1;
            return { id, total, acc, lastAt };
          })
          .filter(x => x.total >= 6)
          .sort((a, b) => (a.acc - b.acc) || (b.lastAt - a.lastAt));
        return scored.length ? scored[0] : null;
      })();

      if (weakestStrategy && weakestStrategy.acc < 0.75) {
        const skillId = strategyToSkill[weakestStrategy.id] || null;
        const picked = pickSkillIfAllowed(skillId, 'Practice your weakest reading skill next.');
        if (picked) return picked;
      }

      // Default: continue the story progression.
      if (nextStationId) {
        const st = stationContent[nextStationId];
        return {
          type: 'station',
          id: nextStationId,
          title: st ? st.name : 'Next station',
          reason: 'Keep going on your MRT adventure!',
        };
      }

      // If all stations are complete, recommend a skill based on weakest recent performance.
      const weakestSkill = (() => {
        const entries = Object.entries(analytics.skills || {});
        const scored = entries
          .map(([id, stat]) => {
            const total = stat && Number.isFinite(stat.totalQuestions) ? stat.totalQuestions : 0;
            const first = stat && Number.isFinite(stat.firstTryCorrect) ? stat.firstTryCorrect : 0;
            const lastAt = stat && Number.isFinite(stat.lastAt) ? stat.lastAt : 0;
            const acc = total ? first / total : 1;
            return { id, total, acc, lastAt };
          })
          .filter(x => x.total >= 6)
          .sort((a, b) => (a.acc - b.acc) || (b.lastAt - a.lastAt));
        return scored.length ? scored[0] : null;
      })();

      if (weakestSkill && weakestSkill.acc < 0.85) {
        const skill = getSkillById(weakestSkill.id);
        if (skill && skill.level <= maxSkillLevel) {
          return { type: 'skill', id: skill.id, title: skill.name, reason: 'Practice to get even stronger!' };
        }
      }

      // Fallback skill suggestion (level-appropriate).
      const fallbackSkill = getSkillById('supporting-detail') || getSkillById('setting');
      if (fallbackSkill && fallbackSkill.level <= maxSkillLevel) {
        return { type: 'skill', id: fallbackSkill.id, title: fallbackSkill.name, reason: 'Try a quick skill practice.' };
      }

      return null;
    }

    function updateRecommendationPanel() {
      const panel = document.getElementById('mrtRecommendation');
      const titleEl = document.getElementById('recommendationTitle');
      const reasonEl = document.getElementById('recommendationReason');
      const primaryBtn = document.getElementById('recommendationContinueBtn');
      const altBtn = document.getElementById('recommendationAltBtn');

      if (!panel || !titleEl || !reasonEl || !primaryBtn || !altBtn) return;

      const rec = getRecommendedNextAction();
      if (!rec) {
        panel.style.display = 'none';
        return;
      }

      panel.style.display = 'block';

      if (rec.type === 'station') {
        titleEl.textContent = `Continue: ${rec.title || 'Next station'}`;
        reasonEl.textContent = rec.reason || '';
        primaryBtn.textContent = 'Continue';
        altBtn.style.display = 'none';
      } else if (rec.type === 'skill') {
        titleEl.textContent = `Recommended practice: ${rec.title || 'Skill Practice'}`;
        reasonEl.textContent = rec.reason || '';
        primaryBtn.textContent = 'Practice now';

        if (rec.altStationId) {
          const st = stationContent[rec.altStationId];
          altBtn.textContent = st ? `Story: ${st.name}` : 'Story next';
          altBtn.style.display = 'inline-flex';
        } else {
          altBtn.style.display = 'none';
        }
      }

      panel.dataset.recType = rec.type;
      panel.dataset.recId = rec.id || '';
      panel.dataset.altStationId = rec.altStationId || '';
    }

    function runRecommendation(recType, recId) {
      if (!recType || !recId) return;
      if (recType === 'station') {
        selectStation(recId);
        return;
      }
      if (recType === 'skill') {
        startSkillPractice(recId);
      }
    }

    function bindRecommendationUiHandlers() {
      const panel = document.getElementById('mrtRecommendation');
      const primaryBtn = document.getElementById('recommendationContinueBtn');
      const altBtn = document.getElementById('recommendationAltBtn');

      if (!panel || !primaryBtn || !altBtn) return;

      primaryBtn.onclick = () => {
        const recType = panel.dataset.recType;
        const recId = panel.dataset.recId;
        runRecommendation(recType, recId);
      };

      altBtn.onclick = () => {
        const stationId = panel.dataset.altStationId;
        if (stationId) runRecommendation('station', stationId);
      };
    }

    // ===== MAP HELPERS & CONSTANTS =====
    // Note: MRT_MAP_TRAIN_OFFSET_PX, clampNumber, easeInOutCubic, findMrtLinePathElement are defined earlier (around lines 18074+).

    function setMapTrainTransform(group, pose) {
      if (!group || !pose) return;
      group.setAttribute('transform', `translate(${pose.x}, ${pose.y}) rotate(${pose.angle})`);
    }

    // ===== GENERATE MRT MAP - AUTHENTIC TAIPEI MRT NETWORK =====
    function generateMRTMap() {
      console.log('=== Generating Taipei MRT Network Map ===');

      // Clear any station transition state when map is regenerated
      clearStationTransitionState();
      cancelMapTrainMotion();

      const map = document.getElementById('mrtMap');

      if (!map) {
        console.error('MRT map element not found!');
        return;
      }

      try {
        // Station data with positions on the map
        // Map coordinates: viewBox 0 0 500 700 (expanded for 15 stations)
	        const stationData = {
	          // Red Line (Level 1) - Runs north to south (4 stations)
	          fruit: { x: 250, y: 50, line: 'red', level: 1, labelPos: 'right', emoji: 'ðŸŽ' },
	          drink: { x: 250, y: 115, line: 'red', level: 1, labelPos: 'right', emoji: 'ðŸ§ƒ' },
	          bakery: { x: 250, y: 180, line: 'red', level: 1, labelPos: 'right', emoji: 'ðŸ§' },
	          redbean: { x: 250, y: 245, line: 'red', level: 1, labelPos: 'right', emoji: 'ðŸž' },
	          // Central hub (train can park here; not a playable station)
	          hub: { x: 250, y: 320, line: 'red', level: 0, labelPos: 'top', emoji: '' },
	          // Blue Line (Level 2) - Runs west to east (4 stations)
	          // Labels positioned above (top) to avoid overlapping with horizontal line
	          pizza: { x: 50, y: 320, line: 'blue', level: 2, labelPos: 'top', emoji: 'ðŸ•' },
	          bubbletea: { x: 140, y: 320, line: 'blue', level: 2, labelPos: 'top', emoji: 'ðŸ§‹' },
          burger: { x: 360, y: 320, line: 'blue', level: 2, labelPos: 'top', emoji: 'ðŸ”' },
          icecream: { x: 450, y: 320, line: 'blue', level: 2, labelPos: 'top', emoji: 'ðŸ¦' },
          // Green Line (Level 3) - Branches southwest (4 stations)
          fishshop: { x: 170, y: 410, line: 'green', level: 3, labelPos: 'left', emoji: 'ðŸŸ' },
          sushi: { x: 110, y: 480, line: 'green', level: 3, labelPos: 'left', emoji: 'ðŸ£' },
          cheese: { x: 60, y: 550, line: 'green', level: 3, labelPos: 'left', emoji: 'ðŸ§€' },
          chicken: { x: 30, y: 620, line: 'green', level: 3, labelPos: 'left', emoji: 'ðŸ—' },
          // Orange Line (Level 4) - Branches southeast (3 stations)
          noodle: { x: 330, y: 410, line: 'orange', level: 4, labelPos: 'right', emoji: 'ðŸœ' },
          smoothie: { x: 390, y: 490, line: 'orange', level: 4, labelPos: 'right', emoji: 'ðŸ¥¤' },
          teahouse: { x: 450, y: 570, line: 'orange', level: 4, labelPos: 'right', emoji: 'ðŸµ' }
        };

        // Central hub position
        const hub = { x: 250, y: 320 };

        // Build the station unlock/complete status (15 stations)
        const stationOrder = [
          'fruit', 'drink', 'bakery', 'redbean',           // Red Line (Level 1)
          'pizza', 'bubbletea', 'burger', 'icecream',      // Blue Line (Level 2)
          'fishshop', 'sushi', 'cheese', 'chicken',        // Green Line (Level 3)
          'noodle', 'smoothie', 'teahouse'                 // Orange Line (Level 4)
        ];
        const stationStatus = {};
        stationOrder.forEach((id, index) => {
          stationStatus[id] = {
            isCompleted: state.completedStations.includes(id),
            isUnlocked: isStationUnlocked(id, index)
          };
        });

        // Find recommended station (adaptive: may be a skill; fall back to next unlocked station)
        const nextAction = getRecommendedNextAction();
        const recommendedStation =
          nextAction && nextAction.type === 'station'
            ? nextAction.id
            : stationOrder.find(id => stationStatus[id].isUnlocked && !stationStatus[id].isCompleted);

        // Create SVG element
        const svgNS = 'http://www.w3.org/2000/svg';

        // Clear and build
        map.innerHTML = '';

        // Add pan hint for mobile
        const isMobileView = window.innerWidth <= 600;
        if (isMobileView) {
          const panHint = document.createElement('div');
          panHint.className = 'mrt-pan-hint';
          panHint.id = 'mrtPanHint';
          panHint.innerHTML = '<span class="mrt-pan-hint-icon">ðŸ‘†</span> Swipe to explore map';
          map.appendChild(panHint);

          // Hide hint after first touch
          map.addEventListener('touchstart', function hidePanHint() {
            const hint = document.getElementById('mrtPanHint');
            if (hint) hint.classList.add('hidden');
            map.removeEventListener('touchstart', hidePanHint);
          }, { once: true, passive: true });
        }

        // Create scroll container for mobile panning
        const scrollContainer = document.createElement('div');
        scrollContainer.className = 'mrt-map-scroll-container';
        scrollContainer.id = 'mrtScrollContainer';

        // Create SVG (expanded viewBox for 15 stations)
        const svg = document.createElementNS(svgNS, 'svg');
        svg.setAttribute('class', 'mrt-network-svg');
        // Mobile gets extra padding so edge labels aren't clipped at larger zoom.
        svg.setAttribute('viewBox', isMobileView ? '-130 -30 660 760' : '-30 -20 560 720');
        // iOS/Safari can compute a 0-height SVG if we rely on CSS sizing alone; give it an intrinsic size.
        svg.setAttribute('width', isMobileView ? '660' : '560');
        svg.setAttribute('height', isMobileView ? '760' : '720');
        svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');

        // === DRAW LINE PATHS (underneath stations) ===
        const linesGroup = document.createElementNS(svgNS, 'g');
        linesGroup.setAttribute('class', 'mrt-lines-layer');

        // Red Line: Fruit â†’ Drink â†’ Bakery â†’ Red Bean â†’ Hub (4 stations, north to south)
        const redPath = document.createElementNS(svgNS, 'path');
        redPath.setAttribute('id', 'mrtLinePathRed');
        redPath.setAttribute('class', 'mrt-line-path line-red');
        redPath.setAttribute('d', `M 250 50 L 250 320`);
        linesGroup.appendChild(redPath);

        // Blue Line: Pizza â†’ Bubble Tea â†’ Hub â†’ Burger â†’ Ice Cream (4 stations, west to east)
        const bluePath = document.createElementNS(svgNS, 'path');
        bluePath.setAttribute('id', 'mrtLinePathBlue');
        bluePath.setAttribute('class', 'mrt-line-path line-blue');
        bluePath.setAttribute('d', `M 50 320 L 450 320`);
        linesGroup.appendChild(bluePath);

        // Green Line: Hub â†’ Fish Shop â†’ Sushi â†’ Cheese â†’ Chicken (4 stations, diagonal southwest)
        const greenPath = document.createElementNS(svgNS, 'path');
        greenPath.setAttribute('id', 'mrtLinePathGreen');
        greenPath.setAttribute('class', 'mrt-line-path line-green');
        greenPath.setAttribute('d', `M 250 320 L 250 360 Q 250 380, 220 400 L 170 410 L 110 480 L 60 550 L 30 620`);
        linesGroup.appendChild(greenPath);

        // Orange Line: Hub â†’ Noodle â†’ Smoothie â†’ Tea House (3 stations, diagonal southeast)
        const orangePath = document.createElementNS(svgNS, 'path');
        orangePath.setAttribute('id', 'mrtLinePathOrange');
        orangePath.setAttribute('class', 'mrt-line-path line-orange');
        orangePath.setAttribute('d', `M 250 320 L 250 360 Q 250 380, 280 400 L 330 410 L 390 490 L 450 570`);
        linesGroup.appendChild(orangePath);

        svg.appendChild(linesGroup);

        // === DRAW CENTRAL HUB (Transfer Station) ===
        const hubGroup = document.createElementNS(svgNS, 'g');
        hubGroup.setAttribute('class', 'mrt-central-hub');
        hubGroup.setAttribute('transform', `translate(${hub.x}, ${hub.y})`);

        // Outer white circle
        const hubOuter = document.createElementNS(svgNS, 'circle');
        hubOuter.setAttribute('class', 'mrt-hub-outer');
        hubOuter.setAttribute('r', '22');
        hubOuter.setAttribute('cx', '0');
        hubOuter.setAttribute('cy', '0');
        hubGroup.appendChild(hubOuter);

        // Colored rings for each line
        const ringColors = [
          { color: 'var(--taipei-red)', offset: 0 },
          { color: 'var(--taipei-blue)', offset: 90 },
          { color: 'var(--taipei-green)', offset: 180 },
          { color: 'var(--taipei-orange)', offset: 270 }
        ];
        ringColors.forEach((ring, i) => {
          const arc = document.createElementNS(svgNS, 'circle');
          arc.setAttribute('class', 'mrt-hub-ring');
          arc.setAttribute('r', '15');
          arc.setAttribute('cx', '0');
          arc.setAttribute('cy', '0');
          arc.setAttribute('stroke', ring.color);
          arc.setAttribute('stroke-dasharray', '23.5 70.7');
          arc.setAttribute('stroke-dashoffset', -ring.offset * 0.262);
          arc.setAttribute('transform', `rotate(${ring.offset - 45})`);
          hubGroup.appendChild(arc);
        });

        // Inner circle
        const hubInner = document.createElementNS(svgNS, 'circle');
        hubInner.setAttribute('class', 'mrt-hub-inner');
        hubInner.setAttribute('r', '6');
        hubInner.setAttribute('cx', '0');
        hubInner.setAttribute('cy', '0');
        hubGroup.appendChild(hubInner);

        // Hub label
        const hubLabel = document.createElementNS(svgNS, 'text');
        hubLabel.setAttribute('class', 'mrt-hub-label');
        hubLabel.setAttribute('x', '0');
        hubLabel.setAttribute('y', '38');
        hubLabel.setAttribute('text-anchor', 'middle');
        hubLabel.textContent = 'TAIPEI FOOD';
        hubGroup.appendChild(hubLabel);

        const hubLabel2 = document.createElementNS(svgNS, 'text');
        hubLabel2.setAttribute('class', 'mrt-hub-label');
        hubLabel2.setAttribute('x', '0');
        hubLabel2.setAttribute('y', '48');
        hubLabel2.setAttribute('text-anchor', 'middle');
        hubLabel2.textContent = 'STATION';
        hubGroup.appendChild(hubLabel2);

        svg.appendChild(hubGroup);

        // === DRAW STATIONS ===
        const stationsGroup = document.createElementNS(svgNS, 'g');
        stationsGroup.setAttribute('class', 'mrt-stations-layer');

	        Object.entries(stationData).forEach(([stationId, data]) => {
	          const station = stationContent[stationId];
	          if (!station) return;

          const status = stationStatus[stationId];
          const isRecommended = stationId === recommendedStation;

	          // Station group
	          const stationGroup = document.createElementNS(svgNS, 'g');
	          stationGroup.setAttribute(
	            'class',
	            `mrt-station line-${data.line}${status.isCompleted ? ' completed' : ''}${!status.isUnlocked ? ' locked' : ''}${isRecommended ? ' recommended' : ''}`
	          );
	          stationGroup.setAttribute('data-station', stationId);
	          stationGroup.setAttribute('transform', `translate(${data.x}, ${data.y})`);

          // Click handler
          if (status.isUnlocked) {
            stationGroup.style.cursor = 'pointer';
            stationGroup.onclick = () => selectStation(stationId);
          }

          // Station circle (white with colored border) - larger to fit emoji inside
          const circle = document.createElementNS(svgNS, 'circle');
          circle.setAttribute('class', 'mrt-station-circle');
          circle.setAttribute('r', '18');
          circle.setAttribute('cx', '0');
          circle.setAttribute('cy', '0');
          stationGroup.appendChild(circle);

          // Food emoji INSIDE the station circle
          const emoji = document.createElementNS(svgNS, 'text');
          emoji.setAttribute('class', 'mrt-station-emoji');
          emoji.setAttribute('text-anchor', 'middle');
          emoji.setAttribute('x', '0');
          emoji.setAttribute('y', '6');
          emoji.textContent = data.emoji;
          stationGroup.appendChild(emoji);

          // Completed badge overlay (small checkmark in corner)
          if (status.isCompleted) {
            const checkBg = document.createElementNS(svgNS, 'circle');
            checkBg.setAttribute('cx', '12');
            checkBg.setAttribute('cy', '-12');
            checkBg.setAttribute('r', '8');
            checkBg.setAttribute('fill', '#4CAF50');
            checkBg.setAttribute('stroke', 'white');
            checkBg.setAttribute('stroke-width', '2');
            stationGroup.appendChild(checkBg);

            const check = document.createElementNS(svgNS, 'text');
            check.setAttribute('x', '12');
            check.setAttribute('y', '-8');
            check.setAttribute('text-anchor', 'middle');
            check.setAttribute('font-size', '10');
            check.setAttribute('fill', 'white');
            check.setAttribute('font-weight', 'bold');
            check.textContent = 'âœ“';
            stationGroup.appendChild(check);
          }

          // Station label - offset to account for larger circle with emoji inside
          const label = document.createElementNS(svgNS, 'text');
          label.setAttribute('class', 'mrt-station-label');
          label.setAttribute('y', '5');

          if (data.labelPos === 'right') {
            label.setAttribute('x', '26');
            label.setAttribute('text-anchor', 'start');
          } else if (data.labelPos === 'left') {
            label.setAttribute('x', '-26');
            label.setAttribute('text-anchor', 'end');
          } else {
            label.setAttribute('x', '0');
            label.setAttribute('y', '-28');
            label.setAttribute('text-anchor', 'middle');
          }
          label.textContent = station.name;
          stationGroup.appendChild(label);

          // Lock overlay for locked stations (pilot mode shows â€œSOONâ€ on coming-soon stops)
          if (!status.isUnlocked) {
            const isSoon = !!(station && station.comingSoon);
            if (isSoon) {
              const soon = document.createElementNS(svgNS, 'text');
              soon.setAttribute('x', '0');
              soon.setAttribute('y', '34');
              soon.setAttribute('text-anchor', 'middle');
              soon.setAttribute('font-size', '8');
              soon.setAttribute('font-weight', '900');
              soon.setAttribute('fill', '#90A4AE');
              soon.textContent = 'SOON';
              stationGroup.appendChild(soon);
            } else {
              const lock = document.createElementNS(svgNS, 'text');
              lock.setAttribute('x', '0');
              lock.setAttribute('y', '6');
              lock.setAttribute('text-anchor', 'middle');
              lock.setAttribute('font-size', '10');
              lock.setAttribute('fill', '#90A4AE');
              lock.textContent = 'ðŸ”’';
              stationGroup.appendChild(lock);
            }
          }

          stationsGroup.appendChild(stationGroup);
        });

        svg.appendChild(stationsGroup);

        // === ADD MAP TRAIN (shows user's current position) ===
        const trainLayer = document.createElementNS(svgNS, 'g');
        trainLayer.setAttribute('class', 'mrt-train-layer');

	        // Determine train position: hub override â†’ current station â†’ remembered map position â†’ last completed â†’ first station.
	        const completedStations = stationOrder.filter(id => stationStatus[id].isCompleted);
	        const trainStationId = (() => {
	          if (state.mapTrainAtHub && stationData.hub) return 'hub';
	          if (state.currentStation && stationData[state.currentStation]) return state.currentStation;
	          if (state.mapTrainStation && stationData[state.mapTrainStation]) return state.mapTrainStation;
	          if (completedStations.length > 0) return completedStations[completedStations.length - 1];
	          return 'fruit';
	        })();

        const trainStationData = stationData[trainStationId];
        const trainLine = trainStationData ? trainStationData.line : 'red';

	        // Create the train group
	        const trainGroup = document.createElementNS(svgNS, 'g');
	        const isAtHub = trainStationId === 'hub';
	        // Add hub-spin class for 360 spin animation when at hub
	        const trainClasses = isAtHub
	          ? `mrt-map-train line-${trainLine} hub-spin`
	          : `mrt-map-train line-${trainLine} idle`;
	        trainGroup.setAttribute('class', trainClasses);
	        trainGroup.setAttribute('id', 'mapTrain');

	        // After spin animation, transition to idle bounce
	        if (isAtHub) {
	          setTimeout(() => {
	            const train = document.getElementById('mapTrain');
	            if (train) {
	              train.classList.remove('hub-spin');
	              train.classList.add('idle');
	            }
	          }, 1600); // After 1.5s spin animation completes
	        }

        if (trainStationData) {
          try {
            const pathEl = findMrtLinePathElement(trainLine, svg);
            if (pathEl) {
              const stationLen = getClosestLengthOnPath(pathEl, trainStationData.x, trainStationData.y);
              const hubLen = getClosestLengthOnPath(pathEl, hub.x, hub.y);
              const dir = (stationLen !== null && hubLen !== null && hubLen < stationLen) ? -1 : 1;
              if (stationLen !== null) {
                const pose = computeTrainPoseOnPath(pathEl, stationLen, dir);
                if (pose) setMapTrainTransform(trainGroup, pose);
                else trainGroup.setAttribute('transform', `translate(${trainStationData.x}, ${trainStationData.y})`);
              } else {
                trainGroup.setAttribute('transform', `translate(${trainStationData.x}, ${trainStationData.y})`);
              }
            } else {
              trainGroup.setAttribute('transform', `translate(${trainStationData.x}, ${trainStationData.y})`);
            }
          } catch (e) {
            trainGroup.setAttribute('transform', `translate(${trainStationData.x}, ${trainStationData.y})`);
          }
        }

        // Train SVG - top-down stylized Taipei MRT train (no wheels)
        // Use an inner group for bounce/pulse so the outer translate+rotate stays correct.
        const trainInner = document.createElementNS(svgNS, 'g');
        trainInner.setAttribute('class', 'mrt-map-train-inner');
        trainGroup.appendChild(trainInner);

	        // Art group lets us scale the train without fighting CSS transforms on `.mrt-map-train-inner`.
	        const trainArt = document.createElementNS(svgNS, 'g');
	        trainArt.setAttribute('transform', 'scale(1.15)');
	        trainInner.appendChild(trainArt);

        // Body outline (top-down)
        const trainBody = document.createElementNS(svgNS, 'rect');
        trainBody.setAttribute('class', 'mrt-map-train-body');
        trainBody.setAttribute('x', '-18');
        trainBody.setAttribute('y', '-9');
        trainBody.setAttribute('width', '36');
        trainBody.setAttribute('height', '18');
        trainBody.setAttribute('rx', '7');
        trainArt.appendChild(trainBody);

        // Side shading (suggests depth; still top-down)
        const sideTop = document.createElementNS(svgNS, 'rect');
        sideTop.setAttribute('class', 'mrt-map-train-side');
        sideTop.setAttribute('x', '-16.9');
        sideTop.setAttribute('y', '-8.7');
        sideTop.setAttribute('width', '33.8');
        sideTop.setAttribute('height', '2.6');
        sideTop.setAttribute('rx', '1.3');
        trainArt.appendChild(sideTop);

        const sideBottom = document.createElementNS(svgNS, 'rect');
        sideBottom.setAttribute('class', 'mrt-map-train-side');
        sideBottom.setAttribute('x', '-16.9');
        sideBottom.setAttribute('y', '6.1');
        sideBottom.setAttribute('width', '33.8');
        sideBottom.setAttribute('height', '2.6');
        sideBottom.setAttribute('rx', '1.3');
        trainArt.appendChild(sideBottom);

        // Main roof panel
        const roof = document.createElementNS(svgNS, 'rect');
        roof.setAttribute('class', 'mrt-map-train-roof');
        roof.setAttribute('x', '-16.5');
        roof.setAttribute('y', '-7.5');
        roof.setAttribute('width', '33');
        roof.setAttribute('height', '15');
        roof.setAttribute('rx', '6.2');
        trainArt.appendChild(roof);

        // Line stripes (Top and Bottom for symmetry)
        const stripeBottom = document.createElementNS(svgNS, 'rect');
        stripeBottom.setAttribute('class', 'mrt-map-train-stripe');
        stripeBottom.setAttribute('x', '-15.8');
        stripeBottom.setAttribute('y', '5.2');
        stripeBottom.setAttribute('width', '31.6');
        stripeBottom.setAttribute('height', '2.3');
        stripeBottom.setAttribute('rx', '1.15');
        trainArt.appendChild(stripeBottom);

        const stripeTop = document.createElementNS(svgNS, 'rect');
        stripeTop.setAttribute('class', 'mrt-map-train-stripe');
        stripeTop.setAttribute('x', '-15.8');
        stripeTop.setAttribute('y', '-7.5');
        stripeTop.setAttribute('width', '31.6');
        stripeTop.setAttribute('height', '2.3');
        stripeTop.setAttribute('rx', '1.15');
        trainArt.appendChild(stripeTop);

        // Rooftop equipment (HVAC)
        const hvac1 = document.createElementNS(svgNS, 'rect');
        hvac1.setAttribute('class', 'mrt-map-train-hvac');
        hvac1.setAttribute('x', '-6.6');
        hvac1.setAttribute('y', '-1.9');
        hvac1.setAttribute('width', '13.2');
        hvac1.setAttribute('height', '3.8');
        hvac1.setAttribute('rx', '1.6');
        trainArt.appendChild(hvac1);

        const hvac2 = document.createElementNS(svgNS, 'rect');
        hvac2.setAttribute('class', 'mrt-map-train-hvac');
        hvac2.setAttribute('x', '-4.8');
        hvac2.setAttribute('y', '-6.0');
        hvac2.setAttribute('width', '9.6');
        hvac2.setAttribute('height', '3.0');
        hvac2.setAttribute('rx', '1.4');
        trainArt.appendChild(hvac2);

        // Cab windows (front + rear) to make the direction obvious
        const frontWindow = document.createElementNS(svgNS, 'rect');
        frontWindow.setAttribute('class', 'mrt-map-train-front-window');
        frontWindow.setAttribute('x', '10.1');
        frontWindow.setAttribute('y', '-4.9');
        frontWindow.setAttribute('width', '5.8');
        frontWindow.setAttribute('height', '9.8');
        frontWindow.setAttribute('rx', '2.4');
        trainArt.appendChild(frontWindow);

        const rearWindow = document.createElementNS(svgNS, 'rect');
        rearWindow.setAttribute('class', 'mrt-map-train-window');
        rearWindow.setAttribute('x', '-15.9');
        rearWindow.setAttribute('y', '-4.6');
        rearWindow.setAttribute('width', '4.8');
        rearWindow.setAttribute('height', '9.2');
        rearWindow.setAttribute('rx', '2.2');
        trainArt.appendChild(rearWindow);

        // Door seams (subtle)
        const seam1 = document.createElementNS(svgNS, 'line');
        seam1.setAttribute('class', 'mrt-map-train-door-line');
        seam1.setAttribute('x1', '-4.0');
        seam1.setAttribute('y1', '-7.2');
        seam1.setAttribute('x2', '-4.0');
        seam1.setAttribute('y2', '-4.3');
        trainArt.appendChild(seam1);

        const seam2 = document.createElementNS(svgNS, 'line');
        seam2.setAttribute('class', 'mrt-map-train-door-line');
        seam2.setAttribute('x1', '2.2');
        seam2.setAttribute('y1', '-7.2');
        seam2.setAttribute('x2', '2.2');
        seam2.setAttribute('y2', '-4.3');
        trainArt.appendChild(seam2);

        const seam3 = document.createElementNS(svgNS, 'line');
        seam3.setAttribute('class', 'mrt-map-train-door-line');
        seam3.setAttribute('x1', '-4.0');
        seam3.setAttribute('y1', '4.3');
        seam3.setAttribute('x2', '-4.0');
        seam3.setAttribute('y2', '7.2');
        trainArt.appendChild(seam3);

        const seam4 = document.createElementNS(svgNS, 'line');
        seam4.setAttribute('class', 'mrt-map-train-door-line');
        seam4.setAttribute('x1', '2.2');
        seam4.setAttribute('y1', '4.3');
        seam4.setAttribute('x2', '2.2');
        seam4.setAttribute('y2', '7.2');
        trainArt.appendChild(seam4);

        // Bumpers (front/rear)
        const bumperFront = document.createElementNS(svgNS, 'line');
        bumperFront.setAttribute('class', 'mrt-map-train-bumper');
        bumperFront.setAttribute('x1', '17.1');
        bumperFront.setAttribute('y1', '-5.8');
        bumperFront.setAttribute('x2', '17.1');
        bumperFront.setAttribute('y2', '5.8');
        trainArt.appendChild(bumperFront);

        const bumperRear = document.createElementNS(svgNS, 'line');
        bumperRear.setAttribute('class', 'mrt-map-train-bumper');
        bumperRear.setAttribute('x1', '-17.1');
        bumperRear.setAttribute('y1', '-5.8');
        bumperRear.setAttribute('x2', '-17.1');
        bumperRear.setAttribute('y2', '5.8');
        trainArt.appendChild(bumperRear);

        // Lights (front headlights + rear tail lights)
        const headlight1 = document.createElementNS(svgNS, 'circle');
        headlight1.setAttribute('class', 'mrt-map-train-headlight');
        headlight1.setAttribute('cx', '16.0');
        headlight1.setAttribute('cy', '-5.8');
        headlight1.setAttribute('r', '1.25');
        trainArt.appendChild(headlight1);

        const headlight2 = document.createElementNS(svgNS, 'circle');
        headlight2.setAttribute('class', 'mrt-map-train-headlight');
        headlight2.setAttribute('cx', '16.0');
        headlight2.setAttribute('cy', '5.8');
        headlight2.setAttribute('r', '1.25');
        trainArt.appendChild(headlight2);

        const taillight1 = document.createElementNS(svgNS, 'circle');
        taillight1.setAttribute('class', 'mrt-map-train-taillight');
        taillight1.setAttribute('cx', '-16.0');
        taillight1.setAttribute('cy', '-5.6');
        taillight1.setAttribute('r', '1.05');
        trainArt.appendChild(taillight1);

        const taillight2 = document.createElementNS(svgNS, 'circle');
        taillight2.setAttribute('class', 'mrt-map-train-taillight');
        taillight2.setAttribute('cx', '-16.0');
        taillight2.setAttribute('cy', '5.6');
        taillight2.setAttribute('r', '1.05');
        trainArt.appendChild(taillight2);

        trainLayer.appendChild(trainGroup);
        svg.appendChild(trainLayer);

        // Store train position for animation
        state.mapTrainStation = trainStationId;

        // Append SVG to scroll container, then scroll container to map
        scrollContainer.appendChild(svg);
        map.appendChild(scrollContainer);

        // On mobile, ensure edge labels aren't clipped and center on the recommended station.
        if (isMobileView) {
          requestAnimationFrame(() => {
            // Fit the viewBox to the actual SVG content so left/right labels are reachable.
            try {
              const bbox = svg.getBBox();
              const pad = 40;
              const x = Math.floor(bbox.x - pad);
              const y = Math.floor(bbox.y - pad);
              const width = Math.ceil(bbox.width + pad * 2);
              const height = Math.ceil(bbox.height + pad * 2);
              svg.setAttribute('viewBox', `${x} ${y} ${width} ${height} `);
              svg.style.aspectRatio = `${width} / ${height}`;
            } catch (e) {
              // If getBBox fails (rare), keep the default viewBox.
            }

            if (!recommendedStation || !stationData[recommendedStation]) return;
            if (map.scrollWidth <= map.clientWidth && map.scrollHeight <= map.clientHeight) return;

            const stationPos = stationData[recommendedStation];
            const viewBox = svg.viewBox && svg.viewBox.baseVal
              ? svg.viewBox.baseVal
              : { x: -30, y: -20, width: 560, height: 720 };
            const svgRect = svg.getBoundingClientRect();
            const svgWidth = svgRect.width || svg.clientWidth || 520;
            const svgHeight = svgRect.height || svg.clientHeight || Math.round(svgWidth * viewBox.height / viewBox.width);

            const scaleX = svgWidth / viewBox.width;
            const scaleY = svgHeight / viewBox.height;

            // Position of station in actual pixels (account for viewBox offset)
            const stationPixelX = (stationPos.x - viewBox.x) * scaleX;
            const stationPixelY = (stationPos.y - viewBox.y) * scaleY;

            // Center the station in the viewport
            const scrollX = Math.max(0, stationPixelX - map.clientWidth / 2 + 50);
            const scrollY = Math.max(0, stationPixelY - map.clientHeight / 2 + 50);

            map.scrollTo({ left: scrollX, top: scrollY, behavior: 'auto' });
          });
        }

        // === ADD MAP LEGEND ===
        const legend = document.createElement('div');
        legend.className = 'mrt-map-legend';
        legend.innerHTML = `
        <div class="mrt-legend-item">
          <span class="mrt-legend-line line-red"></span>
          <span>Tamsui-Xinyi</span>
          <span class="mrt-legend-level level-1">L1</span>
        </div>
        <div class="mrt-legend-item">
          <span class="mrt-legend-line line-blue"></span>
          <span>Bannan</span>
          <span class="mrt-legend-level level-2">L2</span>
        </div>
        <div class="mrt-legend-item">
          <span class="mrt-legend-line line-green"></span>
          <span>Songshan</span>
          <span class="mrt-legend-level level-3">L3</span>
        </div>
        <div class="mrt-legend-item">
          <span class="mrt-legend-line line-orange"></span>
          <span>Zhonghe</span>
          <span class="mrt-legend-level level-4">L4</span>
        </div>
      `;
        scrollContainer.appendChild(legend);

        updateRecommendationPanel();

        console.log(`=== MRT Network Map complete ===`);
      } catch (e) {
        console.error('Failed to generate MRT map', e);
        try {
          map.innerHTML = '';
          const msg = document.createElement('div');
          msg.style.maxWidth = '560px';
          msg.style.margin = '0 auto';
          msg.style.padding = '16px';
          msg.style.background = 'rgba(255,255,255,0.92)';
          msg.style.borderRadius = '16px';
          msg.style.boxShadow = '0 6px 18px rgba(0,0,0,0.12)';
          msg.style.fontFamily = 'var(--font-display)';
          msg.style.color = 'var(--text-primary)';
          msg.innerHTML = `
	            <div style="font-weight: 900; font-size: 1.05rem; margin-bottom: 6px;">Map could not load</div>
	            <div style="font-weight: 600; font-size: 0.95rem; color: var(--text-secondary); margin-bottom: 12px;">
	              Tap reload to try again.
	            </div>
	          `;
          const btn = document.createElement('button');
          btn.className = 'modal-action-btn';
          btn.type = 'button';
          btn.textContent = 'Reload map';
          btn.onclick = () => generateMRTMap();
          msg.appendChild(btn);
          map.appendChild(msg);
        } catch (e2) { }
      }
    }


    function isStationUnlocked(stationId, index) {
      const station = stationContent[stationId];

      if (!station) {
        console.error(`Cannot check unlock for missing station: ${stationId}`);
        return false;
      }

      // Food-only pivot: hide non-pilot food stations for now.
      if (station.comingSoon) return false;

      // TEST MODE: All (pilot) stations unlocked
      if (TEST_MODE) return true;

      const stationOrder = FOOD_STORY_PILOT_ORDER;
      const pilotIndex = stationOrder.indexOf(stationId);

      // Not in the pilot set.
      if (pilotIndex < 0) return false;

      // First pilot station is always unlocked.
      if (pilotIndex === 0) return true;

      // Check if previous station is completed
      const prevStationId = stationOrder[pilotIndex - 1];
      if (state.completedStations.includes(prevStationId)) {
        console.log(`Station ${stationId}: unlocked because ${prevStationId} completed`);
        return true;
      }

      // Also unlock if this station itself was already completed (for replay)
      if (state.completedStations.includes(stationId)) {
        console.log(`Station ${stationId}: unlocked because already completed`);
        return true;
      }

      // Also unlock if any station from a higher level is completed (for replay flexibility)
      const higherLevelCompleted = state.completedStations.some(id => {
        const s = stationContent[id];
        return s && s.level >= station.level;
      });

      if (higherLevelCompleted) {
        console.log(`Station ${stationId}: unlocked because higher level completed`);
      }

      return higherLevelCompleted;
    }

    // Update unlockNextStation to use the new system
    function unlockNextStation() {
      // Re-generate the map to reflect new unlock status
      generateMRTMap();
    }

    // ===== INIT =====
    window.onload = () => {
      console.log('App initializing...');

      // Device-stable ID (for multi-device merge) + server time offset (clock-skew mitigation).
      state.deviceId = getOrCreateDeviceId();
      loadServerTimeOffsetFromStorage();
      refreshServerTimeOffset().catch(() => { });

      // Load voices
      if (window.speechSynthesis) {
        window.speechSynthesis.getVoices();
      }

      // Cloud save (Firebase) UI wiring (safe even if Firebase isn't configured).
      bindCloudUiHandlers();
      bindWelcomeAccountHandlers();
      updateCloudSettingsUi();
      bindRecommendationUiHandlers();

      // Prime mobile audio unlock on the first interaction (iOS Safari requirement).
      const unlockOnce = () => unlockAudioContext();
      document.addEventListener('touchstart', unlockOnce, { passive: true, once: true });
      document.addEventListener('pointerdown', unlockOnce, { passive: true, once: true });
      document.addEventListener('mousedown', unlockOnce, { once: true });

      // Track interactions so queued guidance doesn't interrupt active learners.
      document.addEventListener('touchstart', markUserInteraction, { passive: true });
      document.addEventListener('pointerdown', markUserInteraction, { passive: true });
      document.addEventListener('keydown', markUserInteraction);

      // Load saved progress (supports per-child local storage when a child is selected).
      let cachedChildId = null;
      try { cachedChildId = localStorage.getItem(CLOUD_ACTIVE_CHILD_KEY); } catch (e) { cachedChildId = null; }
      if (cachedChildId) state.cloud.activeChildId = cachedChildId;
      loadLocalProfiles();
      if (state.cloud.activeChildId) {
        const localChild = state.localProfiles.find(p => p.id === state.cloud.activeChildId) || null;
        if (localChild) {
          state.cloud.activeChild = localChild;
          setActiveChildSnapshot({ id: localChild.id, name: localChild.name || null, avatar: localChild.avatar || null });
        }
      }
      loadProgress({ storageKey: getProgressStorageKey() });
      syncSettingsButtonsToState();
      updateWelcomeTitle();

      // Generate MRT map
      generateMRTMap();

      // Build skills list
      updateSkillsFilterButtons();
      renderSkillsScreen();

      // Preload all images in background for instant station loading
      preloadAllStationAssets();

      // Prime the local TTS manifest cache early so word taps feel instant.
      loadTtsManifest().catch(() => { });

      // Preload short voice-guidance clips (best effort).
      preloadGuidanceAudio();

      updateHomeButtonState();

      // Initialize the bubble tea buddy character and menu
      initBuddyCharacter();

      // Initialize welcome screen train animation
      initWelcomeTrainAnimation();

      // Start cloud backend initialization in the background (does not block gameplay).
      initCloudBackend();

      // Best-effort: flush cloud progress when the tab is backgrounded.
      const flushCloudOnBackground = () => {
        syncProgressToCloud({ reason: 'background', force: true }).catch(() => { });
      };
      document.addEventListener('visibilitychange', () => {
        if (document.hidden) flushCloudOnBackground();
      });
      window.addEventListener('pagehide', flushCloudOnBackground);

      console.log('App initialized. Stations:', Object.keys(stationContent));
      console.log('Completed stations:', state.completedStations);
    };

    // ===== DELIGHT & ACCESSIBILITY ENHANCEMENTS =====

    // 1. Idle Buddy System
    setInterval(() => {
      const now = Date.now();
      const idleTime = now - state.lastUserInteractionAt;
      const IDLE_THRESHOLD = 12000; // 12 seconds

      const buddy = document.getElementById('buddyCharacter');
      if (buddy) {
        if (idleTime > IDLE_THRESHOLD && state.currentScreen !== 'welcomeScreen') {
          buddy.classList.add('idle-hint');
        } else {
          buddy.classList.remove('idle-hint');
        }
      }
    }, 1000);

    // Track interaction to reset idle timer
    ['click', 'touchstart', 'scroll', 'keydown'].forEach(evt => {
      window.addEventListener(evt, () => {
        state.lastUserInteractionAt = Date.now();
        const buddy = document.getElementById('buddyCharacter');
        if (buddy) buddy.classList.remove('idle-hint');
      }, { passive: true });
    });

    // 2. Audio Feedback (Simple Success Tone)
    function playSuccessTone() {
      if (!state.soundEnabled) return;

      try {
        const ctx = initAudioContext();
        if (!ctx) return;

        const osc = ctx.createOscillator();
        const gain = ctx.createGain();

        osc.connect(gain);
        gain.connect(ctx.destination);

        // Pleasant major chord arpeggio (rapid)
        const now = ctx.currentTime;

        // C5
        osc.frequency.setValueAtTime(523.25, now);
        gain.gain.setValueAtTime(0.1, now);

        // E5
        osc.frequency.setValueAtTime(659.25, now + 0.1);

        // G5
        osc.frequency.setValueAtTime(783.99, now + 0.2);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.6);

        osc.start(now);
        osc.stop(now + 0.6);
      } catch (e) {
        console.error('Audio feedback failed', e);
      }
    }

    // 3. Tap-to-Read (Accessibility)
    // Add listener to Reading Section to read whole sentence if background tapped
    document.addEventListener('click', (e) => {
      // Only if we are on reading screen
      if (state.currentScreen !== 'restaurantScreen') return;

      // If clicked word, that is handled by .word click listener
      if (e.target.closest('.word')) return;

      // If clicked sentence display container
      const sentenceDisplay = e.target.closest('.sentence-display');
      if (sentenceDisplay) {
        // Read full sentence
        const fullText = state.currentStation?.sentence;
        if (fullText) speak(fullText);
      }
    });

    // Hook into existing success events
    // We can't easily hook into 'showRewardScreen' without modifying it,
    // but we can add it to where stickers are incremented if we want.
    // For now, let's just expose it for future use.

  </script>
</body>

</html>
